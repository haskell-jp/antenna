<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title type="text">Haskell Antenna</title><id>https://haskell.jp/antenna/feed.xml</id><updated>2018-05-05T00:22:42+09:00</updated><link href="https://haskell.jp/antenna"/><entry><id>https://qiita.com/aiya000/items/7efdfd1102ffd5712422</id><title type="text">Haskellでコンパイル時に「(ファイル名):L(現在の行）」を埋め込む</title><updated>2018-05-05T00:22:42+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/aiya000/items/7efdfd1102ffd5712422"/></entry><entry><id>https://qiita.com/KNaito/items/385fb1701f70ffb8ffd4</id><title type="text">初心者卒業試験のブラックジャック作成に挑戦してみました（Haskell編）</title><updated>2018-05-04T12:04:13+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/KNaito/items/385fb1701f70ffb8ffd4"/></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/05-04-stack171.html</id><title type="text">Stack 1.7.1 がリリースされました。</title><updated>2018-05-04T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/05-04-stack171.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;4月28日に Stack version 1.7.1 が&lt;a href="https://github.com/commercialhaskell/stack/blob/v1.7.1/ChangeLog.md#v171"&gt;リリース&lt;/a&gt;されました。&lt;/p&gt;
&lt;p&gt;更新は以下のコマンドですぐに終わります。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack upgrade
...

$ stack --version
Version 1.7.1, Git revision 681c800873816c022739ca7ed14755e85a579565 (5807 commits) x86_64 hpack-0.28.2&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;h2 id="リリースノート"&gt;リリースノート&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;aarch64 (64ビットARM) で初めて stack が利用できるようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/commit/9a23b91bd1ba4d120a77c9982e85079f825ebf06#diff-e705c8fadf1193ab59443a5e6c8cbe8b"&gt;9a23b91bd1ba4d120a77c9982e85079f825ebf06&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;stack のダウンロードリンクが &lt;code&gt;https://www.stackage.org/stack/&lt;/code&gt; から &lt;code&gt;https://get.haskellstack.org/stable/&lt;/code&gt; に変わりました。&lt;/p&gt;
&lt;p&gt;各種バイナリへのリンクは &lt;code&gt;https://get.haskellstack.org/stable/&amp;lt;PLATFORM&amp;gt;.&amp;lt;EXTENSION&amp;gt;&lt;/code&gt; という形式になるようです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GHC 8.2.2 への対応が困難なため、静的にリンクされた Alpile Linux 向け stack は利用できなくなりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/2387"&gt;Official support for Alpine Linux #2387&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://ghc.haskell.org/trac/ghc/ticket/14739"&gt;Cannot compile ghc 8.2.1 or 8.2.2 on armv7l architectures&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/commit/9a23b91bd1ba4d120a77c9982e85079f825ebf06#diff-e705c8fadf1193ab59443a5e6c8cbe8b"&gt;9a23b91bd1ba4d120a77c9982e85079f825ebf06&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GHC 8.2.2 から CentOS 6 の 32-bit Linux GMP4 はサポートされなくなりました。そのため stack も利用できなくなりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3613"&gt;linux64-gmp4 variant for GHC 8.2.2 #3613&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/commit/9a23b91bd1ba4d120a77c9982e85079f825ebf06#diff-e705c8fadf1193ab59443a5e6c8cbe8b"&gt;9a23b91bd1ba4d120a77c9982e85079f825ebf06&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;実際の&lt;a href="https://github.com/commercialhaskell/stack/blob/9a23b91bd1ba4d120a77c9982e85079f825ebf06/etc/scripts/get-stack.sh#L224"&gt;コード&lt;/a&gt;を見てみるとまだ使えそうな気がしますが、stack 1.7.1 からは&lt;a href="https://github.com/commercialhaskell/stack/releases/download/v1.7.1/stack-1.7.1-linux-i386-gmp4.tar.gz"&gt;リンク切れ&lt;/a&gt;になります。(stack v1.6.5 とかであれば&lt;a href="https://github.com/commercialhaskell/stack/releases/download/v1.6.5/stack-1.6.5-linux-i386-gmp4.tar.gz"&gt;ダウンロード可能&lt;/a&gt;です。)&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;  &lt;span class="kw"&gt;else&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;    &lt;span class="ex"&gt;install_dependencies&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="va"&gt;$1&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="kw"&gt; in&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;      &lt;span class="st"&gt;&amp;quot;6&amp;quot;&lt;/span&gt;&lt;span class="kw"&gt;)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;        &lt;span class="ex"&gt;print_bindist_notice&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;libgmp4&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;        &lt;span class="ex"&gt;install_32bit_gmp4_linked_binary&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;        &lt;span class="kw"&gt;;;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;      *&lt;span class="kw"&gt;)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;        &lt;span class="ex"&gt;print_bindist_notice&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;        &lt;span class="ex"&gt;install_32bit_standard_binary&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;        &lt;span class="kw"&gt;;;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;    &lt;span class="kw"&gt;esac&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;  &lt;span class="kw"&gt;fi&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="大きな変更"&gt;大きな変更&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cabal のバージョンを 2.0 から 2.2 にアップグレードしました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3878"&gt;Switch to Cabal 2.2 (prerelease) #3878&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="変更点"&gt;変更点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC を利用する Linux ディストリビューションで、デフォルトで PIE が有効になっている場合、&lt;code&gt;stack setup&lt;/code&gt; コマンドは異なる GHC 設定オプションを利用しなくなりました。ghc-8.0.2 から GHC は自分自身で検出できるようになり、Stack’s attempted workaround for older versions caused more problems than it solved.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3636"&gt;Setup fails with ‘No information found for ghc-8.2.2’ for OS key ‘linux64-ncurses6-nopie’ #3636&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3715"&gt;setup: improvements to selecting bindists on Linux #3715&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://github.com/fpco/stackage-content/pull/34"&gt;stack-setup-2: nopie fixes for Arch, Gentoo, and Void Linux #34&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;いまいち良くわかってないですが、&lt;a href="https://github.com/commercialhaskell/stack/pull/3715/files#diff-4968f87e674615592e572f2ec593e5b0L558"&gt;コードの差分&lt;/a&gt;を見ると &lt;code&gt;noPie&lt;/code&gt; に関する部分が全部削除されてるので、その辺りを GHC が上手く処理するようになったんでしょう・・・。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack new&lt;/code&gt; コマンドは、プロジェクトテンプレートに stack.yaml ファイルが含まれる場合に、初期化処理を行わないようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3888"&gt;Initialize a new project only when no stack.yaml #3888&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;今まで通り &lt;code&gt;stack.yaml&lt;/code&gt; が含まれている場合でも初期化させたい場合は&lt;code&gt;forceOverwrite initOpts&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; になれば良いので、&lt;code&gt;--force&lt;/code&gt; フラグをつければ良さそうですね。&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode diff"&gt;&lt;code class="sourceCode diff"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="st"&gt;-        initProject IsNewCmd dir initOpts globalResolver&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="va"&gt;+        exists &amp;lt;- doesFileExist $ dir &amp;lt;/&amp;gt; stackDotYaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="va"&gt;+        when (forceOverwrite initOpts || not exists) $&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;span class="va"&gt;+            initProject IsNewCmd dir initOpts globalResolver&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="その他の改良点"&gt;その他の改良点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stack に新たなサブコマンド &lt;code&gt;ls&lt;/code&gt; が導入されました。このコマンドによってローカル及びリモートのスナップショットを確認することができます。詳細は &lt;code&gt;stack ls snapshots --help&lt;/code&gt; コマンドでご確認ください。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/1614"&gt;A new stack show command and missing informative commands #1614&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3252"&gt;Introduce new sub command ls #3252&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;過去の&lt;a href="../2017/12-20-stack-ls-command.html"&gt;ブログ記事&lt;/a&gt;で紹介しているので気になる方はご参照ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;list-dependencies&lt;/code&gt; コマンドが廃止されます。同等の機能は &lt;code&gt;ls dependencies&lt;/code&gt; コマンドで引き続き提供されます。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3669"&gt;Stack list-dependencies : Bring it under the new ls umbrella command #3669&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3706"&gt;Port &lt;code&gt;list-dependencies&lt;/code&gt; under the new ls sub command #3706&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;v1.7.1 ではまだ利用できますが、以下のように &lt;code&gt;DEPRECATED&lt;/code&gt; メッセージが表示されます。一応 v1.8 で削除される予定です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;stack&lt;/span&gt; list-dependencies&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;span class="ex"&gt;DEPRECATED&lt;/span&gt;: Use ls dependencies instead. Will be removed in next major version.&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="ex"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全ての HTTP リクエストヘッダに User-Agent が追加されるようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3628"&gt;Specify User-Agent to get over my company’s firewall #3628&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3682/"&gt;Specify User-Agent on every HTTP request (#3628) #3682&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;今までは &lt;code&gt;User-Agent&lt;/code&gt; が付いていなかったみたいですが、&lt;code&gt;The Haskell Stack&lt;/code&gt; が全てのHTTPリクエストに対して付与されるようになったみたいです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode diff"&gt;&lt;code class="sourceCode diff"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="va"&gt;+setUserAgent :: Request -&amp;gt; Request&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="va"&gt;+setUserAgent = setRequestHeader &amp;quot;User-Agent&amp;quot; [&amp;quot;The Haskell Stack&amp;quot;]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack setup&lt;/code&gt; コマンドは互換性のある GHC をインストールするために、任意の OS キーによるインストールを試すようになりました (これは OS キーをどれか1つだけチェックするよりも良い方法です)。この変更は Linux の各ディストリビューションで libinfo 5/6, ncurses 5/6, gmp 4/5 の異なった組み合わせに起因するものです。今後の GHC リリースを見据えて、セットアップに関する YAML メタデータをシンプルに保つことができます。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3521"&gt;Check for ncurses6 before checking for tinfo6 #3521&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3715"&gt;setup: improvements to selecting bindists on Linux #3715&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ビルドプログレスバーが現在ビルドしているパッケージ名を表示するようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3763"&gt;Report currently building packages along with “Progress:” label #3763&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;変更前の表示結果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Progress: 3/74&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;変更後の表示結果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Progress: 3/74; [Cabal-2.0.1.1|basement-0.0.4|old-time-1.1.0.3|simple-sendfile-0.2.26|stm-2.4.4.1|stringsearch-0.3.6.6]&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack setup --verbose&lt;/code&gt; の出力に GHC 設定処理のログを含めるようにしました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3716"&gt;“stack setup –verbose” should also cause verbose output of GHC configure process if possible #3716&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3712"&gt;Never ending “Configuring GHC…” #3712&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3740"&gt;Log GHC configure output on &lt;code&gt;stack -v setup&lt;/code&gt; #3740&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;変更前は以下のように &lt;code&gt;Configuring GHC ...&lt;/code&gt; で何も表示されていなかったようです。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack build --verbose
...

2017-12-27 00:30:23.869257: [debug] Run process: /home/gleb/.stack/programs/x86_64-linux/ghc-tinfo6-nopie-8.0.2.temp/ghc-8.0.2/configure --prefix=/home/gleb/.stack/programs/x86_64-linux/ghc-tinfo6-nopie-8.0.2/
@(System/Process/Log.hs:37:3)
Configuring GHC ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;変更後は、こんな感じのログが続いて表示されるようになったようです。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;...
018-01-03 10:49:29.280793: [debug] Run process within /home/kp/.stack/programs/x86_64-linux/ghc-7.10.3.temp/ghc-7.10.3/: /usr/bin/make install
@(subs/rio/src/RIO/Process.hs:191:3)
2018-01-03 10:49:29.304283: [info] /usr/bin/make -r --no-print-directory -f ghc.mk install BINDIST=YES NO_INCLUDE_DEPS=YES
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.737966: [info] &amp;quot;rm&amp;quot; -f utils/ghc-pkg/dist-install/build/Version.hs
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.739872: [info] echo &amp;quot;module Version where&amp;quot;                    &amp;gt;&amp;gt; utils/ghc-pkg/dist-install/build/Version.hs
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.741026: [info] echo &amp;quot;version, targetOS, targetARCH :: String&amp;quot; &amp;gt;&amp;gt; utils/ghc-pkg/dist-install/build/Version.hs
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.742170: [info] echo &amp;quot;version    = \&amp;quot;7.10.3\&amp;quot;&amp;quot;      &amp;gt;&amp;gt; utils/ghc-pkg/dist-install/build/Version.hs&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ファイルパスまたは git 参照から &lt;code&gt;extra-dep&lt;/code&gt; が見つからなかった時のエラーメッセージが改善されました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3806"&gt;Confusing error message when a cabal file for an extra-dep can’t be found #3806&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3808"&gt;When a cabal file can’t be found, warn that extra-deps could be the problem too #3808&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;こんな感じでエラーメッセージが改善されたようです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://user-images.githubusercontent.com/1274145/35401090-6f853812-01ad-11e8-8c02-622f9ea9c2da.png" target="_blank"&gt;&lt;img src="https://user-images.githubusercontent.com/1274145/35401090-6f853812-01ad-11e8-8c02-622f9ea9c2da.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Windows 環境では Nix インテグレーションがサポートされていないため、明示的にフラグを有効にした場合でも常に無効になるように変更しました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3600"&gt;Nix doesn’t work on Windows #3600&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3833"&gt;Disable nix on windows (#3600) #3833&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack build&lt;/code&gt; に &lt;code&gt;--keep-tmp-files&lt;/code&gt; フラグを追加しました。デバッグ目的のため一時的に作成したファイルやディレクトリを削除せずに残しておくことができます。このフラグは同等の機能を持つ ghc オプションと同時に使うと良いでしょう。例: &lt;code&gt;stack build --keep-tmp-files --ghc-options=-keep-tmp-files&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3857"&gt;How to keep temporary files on build failures? #3857&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3858"&gt;stack build: Add –keep-tmp-files flag. Fixes #3857 #3858&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;stack.yaml&lt;/code&gt; の &lt;code&gt;build&lt;/code&gt; セクションに指定することもできるようです。(デフォルト値は &lt;code&gt;False&lt;/code&gt;)&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="fu"&gt;build:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;library-profiling:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;executable-profiling:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;  &lt;span class="fu"&gt;copy-bins:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;  &lt;span class="fu"&gt;prefetch:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;  &lt;span class="fu"&gt;keep-going:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;  &lt;span class="fu"&gt;keep-tmp-files:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;スナップショットのパーズ例外時のエラーメッセージを改善しました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3879"&gt;Improved error messages for snapshot parse exceptions #3879&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack unpack&lt;/code&gt; コマンドに &lt;code&gt;--to /target/directory&lt;/code&gt; オプションが追加されました。パッケージの展開先を指定できるようになります。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3904"&gt;Possibility to specify a base path to unpack a package #3904&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3947"&gt;Add –to option to the unpack command to specify destination #3947&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack hoogle&lt;/code&gt; コマンドに &lt;code&gt;--server&lt;/code&gt; オプションが追加されました。ローカルのポート8080番で Hoogle サーバーが起動します。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/2310"&gt;Add &lt;code&gt;stack hoogle --server&lt;/code&gt; command #2310&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3941"&gt;Introduce Hoogle server command line option #3941&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;stack hoogle --server&lt;/code&gt; は &lt;code&gt;stack hoogle -- server --local --port 8080&lt;/code&gt; の省略形です。&lt;/p&gt;
&lt;h3 id="リリースノートに載ってない変更"&gt;リリースノートに載ってない変更&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extra-deps&lt;/code&gt; で &lt;code&gt;github&lt;/code&gt; という短縮形が使えるようになりました。&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3873"&gt;Allow github shorthand for extra-deps #3873&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3890"&gt;Allow ‘github’ shorthand for extra-deps (fixes #3873) #3890&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以下のように書くことができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;github:&lt;/span&gt;&lt;span class="at"&gt; commercialhaskell/rio&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;commit:&lt;/span&gt;&lt;span class="at"&gt; 09654f9fcbdcd96d0f5102796b32fdac5da7260e&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;commit&lt;/code&gt; は短縮して記述することもできます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;github:&lt;/span&gt;&lt;span class="at"&gt; commercialhaskell/rio&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;commit:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;09654&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/mitchellwrosen/stack/blob/9489cf7d12c54ea40ab043e199d7850d2502e140/src/test/Stack/Types/BuildPlanSpec.hs"&gt;BuildPlanSpec.hs&lt;/a&gt; にテストがいくつか載っていいるので、そこを見れば利用可能な形式がわかります。&lt;/p&gt;
&lt;h3 id="バグフィックス"&gt;バグフィックス&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;スクリプトインタプリタ形式で暗黙的に渡されるファイル引数を他の引数より先に処理するようにしました。この修正により、スクリプト実行時に – +RTS … -RTS を渡せるようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3658"&gt;Error when using RTS options with the Stack script interpreter #3658&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3668"&gt;Put file arguments first when stack is run as script interpreter #3658 #3668&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="./02-21-stack165.html"&gt;v.1.6.5&lt;/a&gt; の時に紹介したので、そちらをご確認ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stack 設定ファイルで year パラメータが設定できるようになりました。それに伴い、ドキュメントもわかりやすくしました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/2275"&gt;stack new – AesonException #2275&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3701"&gt;Fix use of and document year template parameter #3701&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="./02-21-stack165.html"&gt;v.1.6.5&lt;/a&gt; の時に紹介したので、そちらをご確認ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ベンチーマークが別のベンチマークやビルドステップと並行して実行されてしまう問題を修正しました。これは別のプロセスのCPU利用がベンチマークに悪影響を及ぼすと思われるので理想的ではありません。また、デフォルトでベンチマークの出力が表示されないようになっていた件も同様に修正しました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3663"&gt;Benchmarks are run in parallel #3663&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3666"&gt;Never run benchmarks concurrently, always output to console #3663 #3666&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="./02-21-stack165.html"&gt;v.1.6.5&lt;/a&gt; の時に紹介したので、そちらをご確認ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stack ghci で複数のパッケージで定義されている同名のモジュールを読み込めるようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3776"&gt;Add rio package as a dep of stack #3776&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3779"&gt;With ghci, allow multiple packages to use the same module #3776 #3779&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="./02-21-stack165.html"&gt;v.1.6.5&lt;/a&gt; の時に紹介したので、そちらをご確認ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stack ghci で base の依存関係を追加する必要が無くなりました。これはローカルターゲットが存在しない場合に自動的に追加されるためです。これにより、base を置き換えているコードも同様に読み込めるようになります。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3589"&gt;stack ghci at global level missing base #3589&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/commit/196bdbae986ddf887f92999b26129085a8ed0be5"&gt;196bdbae986ddf887f92999b26129085a8ed0be5&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/commit/99950cfae2e014f76abbebd51869e5cae5f00a6a"&gt;99950cfae2e014f76abbebd51869e5cae5f00a6a&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="./02-21-stack165.html"&gt;v.1.6.5&lt;/a&gt; の時に紹介したので、そちらをご確認ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack ghci&lt;/code&gt; コマンドで autogen ファイルのパスを適切に扱えるようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3791"&gt;Adjust &lt;code&gt;-i&lt;/code&gt; paths used by ghci to point to autogen / etc files generated by newer Cabal #3791&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3795"&gt;Use per-component build directories for ghci with Cabal&amp;gt;=2.0 #3791 #3795&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stack はサブディレクトリを含むパッケージを常に再コンパイルしていました。現在は修正され、サブディレクトリを再コンパイルする必要がある時だけ行うようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3899"&gt;hakyll dependency on nightly is not cached #3899&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3955"&gt;Don’t recompile in presence of sublibraries #3955&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;特に &lt;code&gt;Hakyll&lt;/code&gt; や &lt;code&gt;Pandoc&lt;/code&gt; (依存しているライブラリも同様に影響を受ける) を使う場合に踏み抜く可能性があるため、影響を受けている人はアップグレード推奨です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;get-stack.sh&lt;/code&gt; インストールスクリプトにおいて Debian/Fedora/CentOS の依存関係のインストールをドキュメントの手動で行う場合と一致するように修正しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/commit/9dfff2760b659c84605028002cd6500cdb52c823#diff-e705c8fadf1193ab59443a5e6c8cbe8b"&gt;9dfff2760b659c84605028002cd6500cdb52c823&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2"&gt;Manual Download&lt;/a&gt; の内容と同様の処理になりました。(&lt;code&gt;git&lt;/code&gt; と &lt;code&gt;gnupg&lt;/code&gt; が追加されました)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Nix を利用する場合に gmp で Cabal-simple をコンパイルするように修正しました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/2944"&gt;Nix: stack should compile setup-Simple-Cabal with libgmp #2944&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3971"&gt;#2944: Compile Cabal-simple with gmp when using Nix #3971&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack ghci&lt;/code&gt; コマンドの stack 処理は ghci で置き換えられました。これによりシグナルハンドリングの動作が改善されます。特に Ctrl-C のハンドリングが改善されます。そのため、生成されたファイルは終了後に残ります。このパスはファイルコンテンツのハッシュにより決まり、システムの一時的なディレクトリに保存されます。そのため、必要に応じて綺麗にしましょう。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3821"&gt;stack repl exits on ctrl+c with error &lt;stdin&gt;: hGetChar: hardware fault (Input/output error) #3821&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3869"&gt;Fix stack ghci ctrl c 3821 #3869&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;stack repl&lt;/code&gt; を実行すると、実際にはこんな感じでディレクトリとファイルが作られます。&lt;code&gt;ba125cb0&lt;/code&gt; や &lt;code&gt;e4ed4429&lt;/code&gt; というファイル名はファイルのコンテンツハッシュによって決まるそうです。(&lt;code&gt;tmp&lt;/code&gt; というディレクトリ名は環境によって異なります)&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;tree&lt;/span&gt; /tmp/haskell-stack-ghci/&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;&lt;span class="ex"&gt;/tmp/haskell-stack-ghci/&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;├── &lt;span class="ex"&gt;ba125cb0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;│   └── &lt;span class="ex"&gt;cabal_macros.h&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;└── &lt;span class="ex"&gt;e4ed4429&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;    └── &lt;span class="ex"&gt;ghci-script&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" data-line-number="8"&gt;&lt;span class="ex"&gt;2&lt;/span&gt; directories, 2 files&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="changelog-オリジナル"&gt;Changelog (オリジナル)&lt;/h2&gt;
&lt;h3 id="release-notes"&gt;Release notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;aarch64 (64-bit ARM) bindists are now available for the first time.&lt;/li&gt;
&lt;li&gt;Statically linked Linux bindists are no longer available, due to difficulty with GHC 8.2.2 on Alpine Linux.&lt;/li&gt;
&lt;li&gt;32-bit Linux GMP4 bindists for CentOS 6 are no longer available, since GHC 8.2.2 is no longer being built for that platform.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="major-changes"&gt;Major changes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Upgrade from Cabal 2.0 to Cabal 2.2&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="behavior-changes"&gt;Behavior changes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack setup&lt;/code&gt; no longer uses different GHC configure options on Linux distributions that use GCC with PIE enabled by default. GHC detects this itself since ghc-8.0.2, and Stack’s attempted workaround for older versions caused more problems than it solved.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack new&lt;/code&gt; no longer initializes a project if the project template contains a stack.yaml file.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="other-enhancements"&gt;Other enhancements&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A new sub command &lt;code&gt;ls&lt;/code&gt; has been introduced to stack to view local and remote snapshots present in the system. Use &lt;code&gt;stack ls snapshots --help&lt;/code&gt; to get more details about it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list-dependencies&lt;/code&gt; has been deprecated. The functionality has to accessed through the new &lt;code&gt;ls dependencies&lt;/code&gt; interface. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3669"&gt;#3669&lt;/a&gt; for details.&lt;/li&gt;
&lt;li&gt;Specify User-Agent HTTP request header on every HTTP request. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3628"&gt;#3628&lt;/a&gt; for details.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack setup&lt;/code&gt; looks for GHC bindists and installations by any OS key that is compatible (rather than only checking a single one). This is relevant on Linux where different distributions may have different combinations of libtinfo 5/6, ncurses 5/6, and gmp 4/5, and will allow simpifying the setup-info metadata YAML for future GHC releases.&lt;/li&gt;
&lt;li&gt;The build progress bar reports names of packages currently building.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack setup --verbose&lt;/code&gt; causes verbose output of GHC configure process. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3716"&gt;#3716&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Improve the error message when an &lt;code&gt;extra-dep&lt;/code&gt; from a path or git reference can’t be found See &lt;a href="https://github.com/commercialhaskell/stack/pull/3808"&gt;#3808&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Nix integration is now disabled on windows even if explicitly enabled, since it isn’t supported. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3600"&gt;#3600&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack build&lt;/code&gt; now supports a new flag &lt;code&gt;--keep-tmp-files&lt;/code&gt; to retain intermediate files and directories for the purpose of debugging. It is best used with ghc’s equivalent flag, i.e. &lt;code&gt;stack build --keep-tmp-files --ghc-options=-keep-tmp-files&lt;/code&gt;. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3857"&gt;#3857&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Improved error messages for snapshot parse exceptions&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack unpack&lt;/code&gt; now supports a &lt;code&gt;--to /target/directory&lt;/code&gt; option to specify where to unpack the package into&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack hoogle&lt;/code&gt; now supports a new flag &lt;code&gt;--server&lt;/code&gt; that launches local Hoogle server on port 8080. See &lt;a href="https://github.com/commercialhaskell/stack/issues/2310"&gt;#2310&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="bug-fixes"&gt;Bug fixes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The script interpreter’s implicit file arguments are now passed before other arguments. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3658"&gt;#3658&lt;/a&gt;. In particular, this makes it possible to pass &lt;code&gt;-- +RTS ... -RTS&lt;/code&gt; to specify RTS arguments used when running the script.&lt;/li&gt;
&lt;li&gt;Don’t ignore the template &lt;code&gt;year&lt;/code&gt; parameter in config files, and clarify the surrounding documentation. See &lt;a href="https://github.com/commercialhaskell/stack/issues/2275"&gt;#2275&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Benchmarks used to be run concurrently with other benchmarks and build steps. This is non-ideal because CPU usage of other processes may interfere with benchmarks. It also prevented benchmark output from being displayed by default. This is now fixed. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3663"&gt;#3663&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; now allows loading multiple packages with the same module name, as long as they have the same filepath. See &lt;a href="https://github.com/commercialhaskell/stack/pull/3776"&gt;#3776&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; no longer always adds a dependency on &lt;code&gt;base&lt;/code&gt;. It is now only added when there are no local targets. This allows it to be to load code that uses replacements for &lt;code&gt;base&lt;/code&gt;. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3589#issuecomment"&gt;#3589&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; now uses correct paths for autogen files with &lt;a href="https://github.com/commercialhaskell/stack/issues/3791"&gt;#3791&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;When a package contained sublibraries, stack was always recompiling the package. This has been fixed now, no recompilation is being done because of sublibraries. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3899"&gt;#3899&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;get-stack.sh&lt;/code&gt; install script now matches manual instructions when it comes to Debian/Fedora/CentOS install dependencies.&lt;/li&gt;
&lt;li&gt;Compile Cabal-simple with gmp when using Nix. See &lt;a href="https://github.com/commercialhaskell/stack/issues/2944"&gt;#2944&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; now replaces the stack process with ghci. This improves signal handling behavior. In particular, handling of Ctrl-C. To make this possible, the generated files are now left behind after exit. The paths are based on hashing file contents, and it’s stored in the system temporary directory, so this shouldn’t result in too much garbage. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3821"&gt;#3821&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><id>https://qiita.com/AndesM/items/41e24c68ff85e07f6232</id><title type="text">ループのベンチマーク(Python/Ruby/Perl/C/Go/Haskell)</title><updated>2018-05-02T19:22:10+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/AndesM/items/41e24c68ff85e07f6232"/></entry><entry><id>https://qiita.com/nwtgck/items/49373211cc14322ee59b</id><title type="text">HaskellでC言語コンパイラ動かしたり、関数化しやすくして再利用性を高めたりしてみたよ</title><updated>2018-05-02T14:44:48+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/nwtgck/items/49373211cc14322ee59b"/></entry><entry><id>http://kakkun61.hatenablog.com/entry/2018/04/27/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8_4_%E3%81%AB%E3%82%B5%E3%83%BC%E3%82%AF%E3%83%AB%E5%8F%82%E5%8A%A0%E3%81%97%E3%81%9F</id><title type="text">技術書典 4 にサークル参加した</title><updated>2018-04-30T09:55:47+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2018/04/27/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8_4_%E3%81%AB%E3%82%B5%E3%83%BC%E3%82%AF%E3%83%AB%E5%8F%82%E5%8A%A0%E3%81%97%E3%81%9F"/><summary type="html">4月22日に開催された『技術書典 4』にサークル参加してきました。 techbookfest.org 技術書典は1と2に個人で参加して3は会社として参加して今回の4は会社と個人と2サークルにかかわっていました。 超技術書典を抜くと皆勤です。 個人サークル 既刊として『遠回りして学ぶ Yesod 入門』を増刷し、新刊は『手続き Haskell』を持っていきました。 doujin.kakkun61.com doujin.kakkun61.com 数字 売り上げ部数は、どんぶり勘定ですが（特に Yesod 本のダウンロードカードが完全に記憶による）下記の通りとなりました。 Yesod 本 紙 + P…</summary></entry><entry><id>https://qiita.com/sky_y/items/6712c3609a8e690e0dd3</id><title type="text">Stack (Haskell): Could not find moduleと言われたときの対処 2018年春版</title><updated>2018-04-30T00:42:26+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/sky_y/items/6712c3609a8e690e0dd3"/></entry><entry><id>https://kurokawh.blogspot.com/2018/01/cygwin-cygwin.html</id><title type="text">[cygwin] cygwinセットアップ・環境構築手順メモ</title><updated>2018-04-27T13:16:22.723+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2018/01/cygwin-cygwin.html"/><summary type="text">

主に自分向けの防備録です。windows10上で確認。インストーラーはここからDLする。





&lt;&lt;設定&gt;&gt;

ssh-agentの重複起動を防ぐ


ユーザーのアカウント名、ホームディレクトリの変更



/etc/passwdを編集する（最新バージョンでは自動生成されない？）
Cygwinを移動したら/etc/passwdの再生成を
巨大ドメインに参加している PC での /etc/passwd, /etc/group ファイルのつくりかた 

ssh-agentのために秘密鍵セットアップ



~/.ssh/


※group/otherの権限を削除する必要がある

% chmod 700 ~/.ssh 


less, lv, manコマンド終了時に画面をクリアしない

[linux][cygwin] less, manの終了直前の画面をクリアしないで端末上に残す方法 
</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/01/21/175227</id><title type="text">ぼくのかんがえた最強の拡張可能レコード</title><updated>2018-04-27T11:57:55+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/01/21/175227"/><summary type="html">注意(2018/04) かなり古い記事なので、extensibleの最新のバージョンとはまったく互換性がない __ 動機 GHCに、OverloadedRecordFields(ORF)という拡張の導入が提案されている。 (Records/OverloadedRecordFields/Design – GHCより) Haskellのレコードの深刻な欠点は、フィールドをオーバーロードできないことだ。例えば、 data Person = Person { personId :: Int, name :: String } data Address = Address { personId :: I…</summary></entry><entry><id>https://qiita.com/ogata-k/items/a3c30c7edf549ac5299f</id><title type="text">Haskellでリストをシャッフル</title><updated>2018-04-25T20:48:02+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/ogata-k/items/a3c30c7edf549ac5299f"/></entry><entry><id>https://qiita.com/ki073/items/dd01b5d3849531caa805</id><title type="text">Haskellを使ってRubyのクラスメソッドを書く(その3) FFI+MessagePack編</title><updated>2018-04-24T23:57:56+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/ki073/items/dd01b5d3849531caa805"/></entry><entry><id>https://qiita.com/tkch_pe/items/58c3093916ae6734a4e3</id><title type="text">Haskellで図の描画(gnuplot)-解説編-</title><updated>2018-04-24T16:41:02+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/tkch_pe/items/58c3093916ae6734a4e3"/></entry><entry><id>https://qiita.com/HirotoShioi/items/6faaf8babb23bb2f3485</id><title type="text">モナド変換子 (その3: 課題の解答)</title><updated>2018-04-23T21:30:23+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/HirotoShioi/items/6faaf8babb23bb2f3485"/></entry><entry><id>https://qiita.com/nwtgck/items/36feb22bb194f0c01493</id><title type="text">Haskell Stackでエラー "openFile: inappropriate type (Is a directory) when using mirror " が出るときの対処法</title><updated>2018-04-21T17:50:15+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/nwtgck/items/36feb22bb194f0c01493"/></entry><entry><id>https://qiita.com/ki073/items/6350747cce51e45a5e9b</id><title type="text">Haskellを使ってRubyのクラスメソッドを書く(その1) FFI編</title><updated>2018-04-19T22:28:14+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/ki073/items/6350747cce51e45a5e9b"/></entry><entry><id>https://qiita.com/ki073/items/e6f2a4f80b6ce790b781</id><title type="text">Haskellを使ってRubyのクラスメソッドを書く(その2) FFI+JSON編</title><updated>2018-04-19T22:23:59+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/ki073/items/e6f2a4f80b6ce790b781"/></entry><entry><id>https://qiita.com/WooNoo/items/9ce410250720d8cfea34</id><title type="text">正格評価と遅延評価のイメージ</title><updated>2018-04-19T22:14:28+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/WooNoo/items/9ce410250720d8cfea34"/></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/04-18-hie.html</id><title type="text">HIE でコード整形時に改行が追加されてしまうバグが直りました</title><updated>2018-04-18T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/04-18-hie.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;vscode&lt;/strong&gt; + &lt;strong&gt;Haskell IDE Engine&lt;/strong&gt; の組み合わせで &lt;code&gt;Haskell&lt;/code&gt; を書き続けて半年ぐらいになります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hie&lt;/code&gt; が採用している整形ツールは &lt;a href="https://github.com/lspitzner/brittany"&gt;brittany&lt;/a&gt; なのですが、個人的には &lt;a href="https://github.com/commercialhaskell/hindent"&gt;hindent&lt;/a&gt; よりも気に入っています。(最近 &lt;a href="https://github.com/lspitzner/brittany/pull/124"&gt;Add import and module support #124&lt;/a&gt; が実装されたんですけど、この部分は正直気に入っていない・・・。&lt;code&gt;stylish-haskell&lt;/code&gt; の結果の方が好きです。)&lt;/p&gt;
&lt;p&gt;今回のバグはコード整形時にファイルの最後に空行が追加されてしまうというものでした・・・。(100回実行すると100行追加されます・・・)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/haskell/haskell-ide-engine/issues/289"&gt;Newline added on every save #289&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/haskell/haskell-ide-engine/issues/521"&gt;Formatting code adds newline at the end of the file #521&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記の &lt;code&gt;issue&lt;/code&gt; が &lt;a href="https://github.com/haskell/haskell-ide-engine/pull/525"&gt;Fix extra newline being added when formatting document #525&lt;/a&gt; で修正されました。&lt;/p&gt;
&lt;p&gt;手作業で毎回削除してて、絶対何かおかしいと思ってましたが、ちゃんと直りました！！！やったね！&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;
&lt;!--more--&gt;</summary></entry><entry><id>https://qiita.com/HirotoShioi/items/8a6107434337b30ce457</id><title type="text">モナド変換子(その１: 基本）</title><updated>2018-04-17T08:25:00+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/HirotoShioi/items/8a6107434337b30ce457"/></entry><entry><id>https://qiita.com/HirotoShioi/items/ac75b97aa52f9db9c472</id><title type="text">モナド変換子 (その２:課題を通じてライブラリに触れてみる)</title><updated>2018-04-15T22:15:44+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/HirotoShioi/items/ac75b97aa52f9db9c472"/></entry><entry><id>https://qiita.com/nwtgck/items/55fef4e66da1693bde83</id><title type="text">Haskellのassertで条件式をエラーメッセージに含める</title><updated>2018-04-15T16:24:10+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/nwtgck/items/55fef4e66da1693bde83"/></entry><entry><id>https://qiita.com/sgsh/items/8e575f560836b6bafcf7</id><title type="text">ABC094 in Haskell</title><updated>2018-04-15T01:16:31+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/sgsh/items/8e575f560836b6bafcf7"/></entry><entry><id>https://qiita.com/chupaaaaaaan/items/7954f30fc4262fe84c2d</id><title type="text">Haskellでニューラルネットを実装して、MNISTを学習してみた</title><updated>2018-04-14T18:11:00+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/chupaaaaaaan/items/7954f30fc4262fe84c2d"/></entry><entry><id>https://qiita.com/yunisef99/items/baef836e8e57db8d4e28</id><title type="text">Haskell : Basic Level</title><updated>2018-04-14T16:40:51+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/yunisef99/items/baef836e8e57db8d4e28"/></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/04-14-lh-unsorted-flag.html</id><title type="text">LiquidHaskell の --prune-unsorted フラグ</title><updated>2018-04-14T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/04-14-lh-unsorted-flag.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;LiquidHaskell&lt;/code&gt; では &lt;code&gt;measure&lt;/code&gt; という仕組みを使って &lt;code&gt;Haskell&lt;/code&gt; の関数を &lt;code&gt;LH&lt;/code&gt; の述語に持ち上げることができます。&lt;/p&gt;
&lt;p&gt;しかし、以下の &lt;code&gt;nLen&lt;/code&gt; 関数は &lt;code&gt;measure&lt;/code&gt; によって持ち上げることができません。&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="co"&gt;{-@ measure nLen @-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="ot"&gt;nLen ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;nLen [] &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;nLen (n&lt;span class="fu"&gt;:&lt;/span&gt;ns) &lt;span class="fu"&gt;=&lt;/span&gt; n &lt;span class="fu"&gt;+&lt;/span&gt; nLen ns&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;結論から言えば、これを解決するためには &lt;code&gt;--prune-unsorted&lt;/code&gt; フラグを利用します。&lt;/p&gt;
&lt;p&gt;以下は &lt;code&gt;measure&lt;/code&gt; の基本的な使い方等についての説明です。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="measure-の基本的な使い方"&gt;measure の基本的な使い方&lt;/h2&gt;
&lt;p&gt;例えばリストの長さを求める &lt;code&gt;lLen&lt;/code&gt; という関数を述語に持ち上げるにはこのようにします。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="co"&gt;{-@ measure lLen @-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="ot"&gt;lLen ::&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;lLen [] &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;lLen (_&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; lLen xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ liquid LH.hs
LiquidHaskell Version 0.8.2.4, Git revision 5b68dc72f628a4c16a77616fb32d8c685580ed2d (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.

**** DONE:  A-Normalization ****************************************************
**** DONE:  Extracted Core using GHC *******************************************
**** DONE:  Transformed Core ***************************************************
Working 150% [=================================================================]
**** DONE:  annotate ***********************************************************
**** RESULT: SAFE **************************************************************&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実際にはこんな感じで長さ付きリストのリファインメント型をつけます。先程から&lt;strong&gt;述語&lt;/strong&gt;と言っているのはリファインメント型 &lt;code&gt;{ | }&lt;/code&gt; の &lt;code&gt;|&lt;/code&gt; の右側のことです。&lt;code&gt;measure&lt;/code&gt; によってこの部分で &lt;code&gt;Haskell&lt;/code&gt; で定義した &lt;code&gt;lLen&lt;/code&gt; 関数が使えるようになります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="co"&gt;{-@ type ListN a N = {v:[a] | lLen v = N} @-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="co"&gt;{-@ goodList :: ListN Int 2 @-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;span class="ot"&gt;goodList ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;goodList &lt;span class="fu"&gt;=&lt;/span&gt; [&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然ですが、仕様を満たしていない場合は &lt;code&gt;UNSAFE&lt;/code&gt; になります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="co"&gt;{-@ badList :: ListN Int 1 @-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="ot"&gt;badList ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;badList &lt;span class="fu"&gt;=&lt;/span&gt; [&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="shell"&gt;&lt;code&gt;**** RESULT: UNSAFE ************************************************************
Error: Liquid Type Mismatch

 14 | badList = [1,2]
      ^^^^^^^
   Inferred type
     VV : {v : [Int] | Main.lLen v == 1 + Main.lLen ?d
                       &amp;amp;&amp;amp; len v == 1 + len ?d
                       &amp;amp;&amp;amp; tail v == ?d
                       &amp;amp;&amp;amp; head v == (1 : int)
                       &amp;amp;&amp;amp; len v &amp;gt;= 0}

   not a subtype of Required type
     VV : {VV : [Int] | Main.lLen VV == 1}

   In Context
     ?b : {?b : [Int] | Main.lLen ?b == 0
                        &amp;amp;&amp;amp; len ?b == 0
                        &amp;amp;&amp;amp; len ?b &amp;gt;= 0}

     ?d : {?d : [Int] | Main.lLen ?d == 1 + Main.lLen ?b
                        &amp;amp;&amp;amp; len ?d == 1 + len ?b
                        &amp;amp;&amp;amp; tail ?d == ?b
                        &amp;amp;&amp;amp; head ?d == (2 : int)
                        &amp;amp;&amp;amp; len ?d &amp;gt;= 0}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;エラーメッセージがつらいですが、とりあえずは以下の部分に着目すれば良いでしょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;not a subtype &lt;span class="kw"&gt;of&lt;/span&gt; &lt;span class="dt"&gt;Required&lt;/span&gt; &lt;span class="kw"&gt;type&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;     &lt;span class="dt"&gt;VV&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt; {&lt;span class="dt"&gt;VV&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="fu"&gt;|&lt;/span&gt; Main.lLen &lt;span class="dt"&gt;VV&lt;/span&gt; &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;lLen VV == 1&lt;/code&gt; の制約が満たされていない。つまり、&lt;code&gt;lLen&lt;/code&gt; の結果が &lt;code&gt;1&lt;/code&gt; になってないよ。ということです。&lt;/p&gt;
&lt;h2 id="measure-でエラーが出る場合"&gt;measure でエラーが出る場合&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;measure&lt;/code&gt; はどんな関数にも使えるわけではありません。&lt;/p&gt;
&lt;p&gt;例えば、以下のような数値のリストに対して、リストの値の合計を返す関数 &lt;code&gt;nLen&lt;/code&gt; を考えましょう。(&lt;code&gt;sum&lt;/code&gt; と同じですが &lt;code&gt;Preude&lt;/code&gt; とかぶるので名前を変更しています)&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="co"&gt;{-@ measure nLen @-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="ot"&gt;nLen ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;nLen [] &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;nLen (n&lt;span class="fu"&gt;:&lt;/span&gt;ns) &lt;span class="fu"&gt;=&lt;/span&gt; n &lt;span class="fu"&gt;+&lt;/span&gt; nLen ns&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;LiquidHaskell&lt;/code&gt; はこの定義に対してエラーを表示します。これは &lt;code&gt;nLen&lt;/code&gt; 関数がリストの型変数 &lt;code&gt;a&lt;/code&gt; を &lt;code&gt;Int&lt;/code&gt; に特殊化しているためです。(&lt;a href="https://github.com/ucsd-progsys/liquidhaskell#prune-unsorted-predicates"&gt;Prune Unsorted Predicates&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;こういう関数に対しては &lt;code&gt;--prune-unsorted&lt;/code&gt; フラグを用いれば良いです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="co"&gt;{-@ LIQUID &amp;quot;--prune-unsorted&amp;quot; @-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;&lt;span class="co"&gt;{-@ measure nLen @-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;span class="ot"&gt;nLen ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;nLen [] &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;nLen (n&lt;span class="fu"&gt;:&lt;/span&gt;ns) &lt;span class="fu"&gt;=&lt;/span&gt; n &lt;span class="fu"&gt;+&lt;/span&gt; nLen ns&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;nLen&lt;/code&gt; を使った型は、先ほどの &lt;code&gt;lLen&lt;/code&gt; とほとんど同じです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="co"&gt;{-@ type ListSum a N = {v:[a] | nLen v = N} @-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;span class="co"&gt;{-@ goodListSum :: ListSum Int 111 @-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;span class="ot"&gt;goodListSum ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;goodListSum &lt;span class="fu"&gt;=&lt;/span&gt; [&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;10&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;&lt;span class="co"&gt;{-@ badListSum :: ListSum Int 111 @-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;&lt;span class="ot"&gt;badListSum ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;badListSum &lt;span class="fu"&gt;=&lt;/span&gt; [&lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;型パラメータが特殊化された関数を &lt;code&gt;measure&lt;/code&gt; で述語に持ち上げる際には &lt;code&gt;--prune-unsorted&lt;/code&gt; を使う&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://qiita.com/sand/items/e0880651c384cdd92975</id><title type="text">関数定義におけるパターンマッチング - Haskell vs Elm vs Elixir</title><updated>2018-04-13T16:05:35+09:00</updated><author><name>Qiita</name></author><link href="https://qiita.com/sand/items/e0880651c384cdd92975"/></entry><entry><id>https://matsubara0507.github.io/posts/2018-04-13-try-rio-1.html</id><title type="text">rio ライブラリを試す その１</title><updated>2018-04-13T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-04-13-try-rio-1.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;rio ライブラリを試す その１&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-04-13" itemprop="datePublished"&gt;
        Apr 13, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/rio.html"&gt;rio&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;先日，alt. &lt;code&gt;Prelude&lt;/code&gt; を目指している &lt;a href="https://hackage.haskell.org/package/rio"&gt;&lt;code&gt;rio&lt;/code&gt;&lt;/a&gt; ライブラリの ver.0.1 がリリースされました． 自作している CLI ツールを試しに &lt;code&gt;rio&lt;/code&gt; で置き換えようかとしてまして，自分の整理のためにまとめてみようと思います．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;ただし，&lt;code&gt;rio&lt;/code&gt; 作者ではないし，全部をちゃんと追っていないので間違っているかも． 間違っている場合は&lt;a href="https://github.com/matsubara0507/source-gh-pages"&gt;このリポジトリに Issue&lt;/a&gt; するか &lt;a href="https://www.reddit.com/r/haskell_jp"&gt;Reddit&lt;/a&gt; でコメントでもしてください m(_ _ )m&lt;/p&gt;
&lt;h1 id="readme-でひとめぐり"&gt;README でひとめぐり&lt;/h1&gt;
&lt;p&gt;もともとはビルドツール Stack を作成するために考えたデザインパターンをまとめたものっぽい．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.fpcomplete.com/blog/2017/07/the-rio-monad"&gt;The RIO Monad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;rio&lt;/code&gt; ライブラリの README にはライブラリのゴール・目的の他に(彼らにとっての)ベストプラクティスが書いてある(&lt;code&gt;rio&lt;/code&gt; 自体がそれに則って作られてる)． ここには翻訳というより，README の各項目の要約を記述する．&lt;/p&gt;
&lt;h2 id="goal"&gt;Goal&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rio&lt;/code&gt; ライブラリのゴール(目的)は以下の3つ．&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;よく設計された信頼できるライブラリのコレクション&lt;/li&gt;
&lt;li&gt;より優れた Prelude の代替え&lt;/li&gt;
&lt;li&gt;高品質な Haskell コードを書くためのベストプラクティス&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(1)により &lt;code&gt;text&lt;/code&gt; や &lt;code&gt;bytesyring&lt;/code&gt; のような，ほとんど &lt;code&gt;base&lt;/code&gt; のようなパッケージを &lt;code&gt;dependencies&lt;/code&gt; に列挙する必要が無くなる． (3)は大域変数(&lt;code&gt;Reader&lt;/code&gt; モナド)やロガーのような実用モナド回りのベストプラクティスが目玉かな(他にもあるけど)．&lt;/p&gt;
&lt;h2 id="標準ライブラリ"&gt;標準ライブラリ&lt;/h2&gt;
&lt;p&gt;いくつかのパッケージを「標準」ライブラリとして再エクスポートしている． &lt;code&gt;rio&lt;/code&gt; の&lt;a href="https://github.com/commercialhaskell/rio/blob/311549f5a7c29abf6fc25e3ba7ec5ab6647e2d96/rio/package.yaml#L14"&gt;依存関係&lt;/a&gt;を見る限り，次のパッケージを再エクスポートしているようだ．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bytestring&lt;/li&gt;
&lt;li&gt;containers&lt;/li&gt;
&lt;li&gt;deepseq&lt;/li&gt;
&lt;li&gt;directory&lt;/li&gt;
&lt;li&gt;exceptions&lt;/li&gt;
&lt;li&gt;filepath&lt;/li&gt;
&lt;li&gt;hashable&lt;/li&gt;
&lt;li&gt;lens(microlens)&lt;/li&gt;
&lt;li&gt;process&lt;/li&gt;
&lt;li&gt;text&lt;/li&gt;
&lt;li&gt;time&lt;/li&gt;
&lt;li&gt;unliftio&lt;/li&gt;
&lt;li&gt;unordered-containers&lt;/li&gt;
&lt;li&gt;vector&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もちろん，元のパッケージの全ての関数や型を再エクスポートしているのではなく，取捨選択して再エクスポートしている． また，後述する &lt;code&gt;Prelude&lt;/code&gt; の代わりである &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html"&gt;&lt;code&gt;RIO&lt;/code&gt;&lt;/a&gt; モジュールに含まれるものもあれば，&lt;code&gt;RIO.XXX&lt;/code&gt; として別のモジュールとして提供されているものもある．&lt;/p&gt;
&lt;h3 id="lens"&gt;Lens&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;lens&lt;/code&gt; の場合，申し訳程度の関数しか再エクスポートされていない． 基本的に &lt;code&gt;set&lt;/code&gt;・&lt;code&gt;sets&lt;/code&gt;・&lt;code&gt;over&lt;/code&gt;・&lt;code&gt;to&lt;/code&gt; だけだ． 演算子は参照の &lt;code&gt;(.^)&lt;/code&gt; しかない． 今後どうなるか分からないが，現状 &lt;code&gt;(.~)&lt;/code&gt; や &lt;code&gt;(%~)&lt;/code&gt; は無いので替わりに関数を中置演算子にして使うしか無さそうだ．&lt;/p&gt;
&lt;h2 id="prelude-の代替え"&gt;&lt;code&gt;Prelude&lt;/code&gt; の代替え&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Prelude&lt;/code&gt; の代替えとして &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html"&gt;&lt;code&gt;RIO&lt;/code&gt;&lt;/a&gt; モジュールというのがある． README には部分関数や遅延 I/O のような，よく問題になるものを削除していると書いてある． また，&lt;code&gt;Data.Maybe&lt;/code&gt; や &lt;code&gt;Control.Arrow&lt;/code&gt; のような良く使う &lt;code&gt;base&lt;/code&gt; ライブラリのモジュールが再エクスポートされていたり，&lt;code&gt;mapLeft&lt;/code&gt; や &lt;code&gt;whenM&lt;/code&gt; のような良く使いそうなのに &lt;code&gt;base&lt;/code&gt; には無い関数が&lt;a href="https://github.com/commercialhaskell/rio/blob/e8c4cba69599aecd9f91c4398aea47ab4eadbb07/rio/src/RIO/Prelude/Extra.hs"&gt;定義されている&lt;/a&gt;． 正直，この辺りがすごい便利．&lt;/p&gt;
&lt;h2 id="ベストプラクティス"&gt;ベストプラクティス&lt;/h2&gt;
&lt;p&gt;ココからが長い + 意見の分かれるところ． 結構 &lt;code&gt;TODO&lt;/code&gt; と書いてあるところも多いので彼らの中でもまとまってないのかな？？&lt;/p&gt;
&lt;h3 id="インポートプラクティス"&gt;インポートプラクティス&lt;/h3&gt;
&lt;p&gt;以下をやってほしいらしい&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt; 言語拡張をオン&lt;/li&gt;
&lt;li&gt;全てのモジュールに &lt;code&gt;import RIO&lt;/code&gt; を追加 (すごいめんどい)&lt;/li&gt;
&lt;li&gt;必要に応じて &lt;code&gt;RIO.XXX&lt;/code&gt; モジュールを &lt;code&gt;qualified&lt;/code&gt; を使ってインポート
&lt;ul&gt;
&lt;li&gt;適切な &lt;code&gt;qualified&lt;/code&gt; の付け方は各モジュールの Haddock の冒頭に書いてある&lt;/li&gt;
&lt;li&gt;例えば &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO-ByteString.html"&gt;&lt;code&gt;import qualified RIO.ByteString as B&lt;/code&gt;&lt;/a&gt; とか&lt;/li&gt;
&lt;li&gt;ドキュメントに &lt;code&gt;qualified&lt;/code&gt; が書いてない場合は &lt;code&gt;qualified&lt;/code&gt; しなくていいのかな？？(例えば &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO-Directory.html"&gt;&lt;code&gt;RIO.Directory&lt;/code&gt;&lt;/a&gt; とか)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;中置演算子は &lt;code&gt;qualified&lt;/code&gt; しなくていい(他のモジュールと衝突しない限りは)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="言語拡張"&gt;言語拡張&lt;/h3&gt;
&lt;p&gt;「言語拡張を使わないプロジェクトなんて，最近じゃほとんどないよね」とか書いてある． 以下の観点を基にデフォルトで利用しても良さそうな言語拡張を選定したそうだ．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コミュニティで受け入れられている&lt;/li&gt;
&lt;li&gt;コードを壊すようなことが &lt;strong&gt;ほとんど&lt;/strong&gt; ない&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一般的に&lt;/strong&gt; 安全だと考えられている&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;割と断言していないのが面白い(笑) 推奨する言語拡張はこちら&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AutoDeriveTypeable
BangPatterns
BinaryLiterals
ConstraintKinds
DataKinds
DefaultSignatures
DeriveDataTypeable
DeriveFoldable
DeriveFunctor
DeriveGeneric
DeriveTraversable
DoAndIfThenElse
EmptyDataDecls
ExistentialQuantification
FlexibleContexts
FlexibleInstances
FunctionalDependencies
GADTs
GeneralizedNewtypeDeriving
InstanceSigs
KindSignatures
LambdaCase
MultiParamTypeClasses
MultiWayIf
NamedFieldPuns
NoImplicitPrelude
OverloadedStrings
PartialTypeSignatures
PatternGuards
PolyKinds
RankNTypes
RecordWildCards
ScopedTypeVariables
StandaloneDeriving
TupleSections
TypeFamilies
TypeSynonymInstances
ViewPatterns&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;RecordWildCards&lt;/code&gt; と &lt;code&gt;OverloadedStrings&lt;/code&gt; は議論の余地あり的なことが書いてある(詳しくはもとの README を見て)．&lt;/p&gt;
&lt;h3 id="ghcオプション"&gt;GHCオプション&lt;/h3&gt;
&lt;p&gt;以下を使いなさいとのコト．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-Wall
-Wcompat
-Wincomplete-record-updates
-Wincomplete-uni-patterns
-Wredundant-constraints&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;どういう形で指定してもいいけど，&lt;code&gt;package.yaml&lt;/code&gt; で書くと楽だし，後述するテンプレートにも書く予定だそうだ． あと，プロダクションコードなら &lt;code&gt;-Werror&lt;/code&gt; をオンにして，最後には確認した方が良いとも書いてある(CIとかでチェックしたいよね)．&lt;/p&gt;
&lt;h3 id="monads"&gt;Monads&lt;/h3&gt;
&lt;p&gt;まってました！ モナドです． 実用的なプロジェクトを考えるとき，必要になってくるのが大域変数・ロガー・例外・IO だと思うので，気になるのはこの辺りだよね．&lt;/p&gt;
&lt;p&gt;全体としての推奨事項は以下の通り．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IO&lt;/code&gt; を使いたいときは &lt;code&gt;RIO&lt;/code&gt; モナドを使いなさい．
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RIO&lt;/code&gt; モナドは &lt;code&gt;ReaderT env IO&lt;/code&gt; と同じだけど，&lt;code&gt;rio&lt;/code&gt; には &lt;code&gt;RIO&lt;/code&gt; モナドに対する補助関数が含まれるのでぜひ使って．&lt;br /&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RIO&lt;/code&gt; モナドで &lt;code&gt;env&lt;/code&gt; の参照関数を書くときは，具体的な型に対する参照関数を書かずに，型クラスを用いた多相的な関数を書くべき(詳しくは後述)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Has&lt;/code&gt; スタイルの型クラスを使えば lens を利用することが出来るよ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;いくつかの良い &lt;code&gt;mtl&lt;/code&gt; スタイルの型クラスも利用する必要は出てくるはず
&lt;ul&gt;
&lt;li&gt;ただし，推奨しているのは &lt;code&gt;MonadReader&lt;/code&gt; &lt;code&gt;MonadIO&lt;/code&gt; &lt;code&gt;MonadUnliftIO&lt;/code&gt; &lt;code&gt;PrimMonad&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MonadReader&lt;/code&gt; + &lt;code&gt;Has&lt;/code&gt; の方が &lt;code&gt;MonadLogger&lt;/code&gt; のように新しい型クラスを作るより優れていると思う&lt;/li&gt;
&lt;li&gt;特に &lt;code&gt;MonadBase&lt;/code&gt; &lt;code&gt;MonadBaseControl&lt;/code&gt; &lt;code&gt;MonadMask&lt;/code&gt; &lt;code&gt;MonadCatch&lt;/code&gt; は避けるべき&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="大域変数"&gt;大域変数&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;env&lt;/code&gt; 回りについて． &lt;code&gt;Has&lt;/code&gt; スタイル(パターン)というのがあって，それ自体はこの&lt;a href="https://hackernoon.com/the-has-type-class-pattern-ca12adab70ae"&gt;ページ&lt;/a&gt;が参考になるのかな？ &lt;code&gt;env&lt;/code&gt; から何らかの値を参照する場合には&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="ot"&gt;myFunction ::&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="dt"&gt;Foo&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;のような関数は &lt;strong&gt;やめて&lt;/strong&gt; ，次のように書くのを推奨している．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;HasConfig&lt;/span&gt; env &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  configL ::&lt;/span&gt; &lt;span class="dt"&gt;Lens&amp;#39;&lt;/span&gt; env &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="co"&gt;-- more on this in a moment&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;span class="ot"&gt;myFunction ::&lt;/span&gt; &lt;span class="dt"&gt;HasConfig&lt;/span&gt; env &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt; env &lt;span class="dt"&gt;Foo&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ここで，&lt;code&gt;env&lt;/code&gt; は次のようなレコードを想定しており&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; {&lt;span class="ot"&gt; envConfig ::&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;Config&lt;/span&gt; }&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こうすることで，&lt;code&gt;env&lt;/code&gt; に複数の大域変数を持たせても，うまく機能させることが出来る． また，次のように &lt;code&gt;Env&lt;/code&gt; と &lt;code&gt;Config&lt;/code&gt; それぞれでインスタンスを定義することで，それぞれで利用できる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasConfig&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;  configL &lt;span class="fu"&gt;=&lt;/span&gt; id&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasConfig&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;  configL &lt;span class="fu"&gt;=&lt;/span&gt; lens envConfig (\x y &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; x { envConfig &lt;span class="fu"&gt;=&lt;/span&gt; y })&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="ロガー"&gt;ロガー&lt;/h4&gt;
&lt;p&gt;ロガーも同様に &lt;code&gt;Has&lt;/code&gt; スタイルを推奨している． &lt;code&gt;env&lt;/code&gt; にログを出力するための関数(&lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#t:LogFunc"&gt;&lt;code&gt;LogFunc&lt;/code&gt;&lt;/a&gt; 型のもの)を持たせる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; {&lt;span class="ot"&gt; envLogFunc ::&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;LogFunc&lt;/span&gt;,&lt;span class="ot"&gt; envConfig ::&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;Config&lt;/span&gt; }&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これの &lt;code&gt;Has&lt;/code&gt; スタイル型クラスは &lt;code&gt;RIO&lt;/code&gt; モジュールに&lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#t:HasLogFunc"&gt;定義してある&lt;/a&gt;．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasLogFunc&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;  logFuncL &lt;span class="fu"&gt;=&lt;/span&gt; lens envLogFunc (\x y &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; x { envLogFunc &lt;span class="fu"&gt;=&lt;/span&gt; y })&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;LogFunc&lt;/code&gt; 型の値を渡すには &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#v:withLogFunc"&gt;&lt;code&gt;withLogFunc&lt;/code&gt;&lt;/a&gt; 関数を用いるようだ(&lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#v:mkLogFunc"&gt;&lt;code&gt;mkLogFunc&lt;/code&gt;&lt;/a&gt; 関数もあるがアドバンスドと書いてある．)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;  envConfig &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getConfig&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;  logOpts &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; logOptionsHandle stdout &lt;span class="dt"&gt;False&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;  withLogFunc logOpts &lt;span class="fu"&gt;$&lt;/span&gt; \envLogFunc &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; runRIO &lt;span class="dt"&gt;Env&lt;/span&gt;{&lt;span class="fu"&gt;..&lt;/span&gt;} action&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;&lt;span class="ot"&gt;action ::&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" data-line-number="8"&gt;action &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="例外"&gt;例外&lt;/h4&gt;
&lt;p&gt;例外をどのように表現すべきかは結構議論されており，今のところの基本的アイデアは以下の通り．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lookup&lt;/code&gt; のような単純に失敗する関数(部分関数になり得る？)の場合は &lt;code&gt;Maybe&lt;/code&gt; や &lt;code&gt;Either&lt;/code&gt; を返そう&lt;/li&gt;
&lt;li&gt;それらを使いたくない場合(大域脱出とか？)は例外を使って
&lt;ul&gt;
&lt;li&gt;純粋なコード(IOではなく)の場合は &lt;code&gt;MonadThrow&lt;/code&gt; 制約を使う&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO&lt;/code&gt; の場合は &lt;code&gt;thorowIO&lt;/code&gt; を介した実行時例外を使う(&lt;code&gt;RIO&lt;/code&gt; モナドも同じ)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「IOアクションがどのように失敗するかを正確に把握できないことにより，不安と不満を感じるかもしれない．しかし，その痛みを受け入れて共存し内在化して，&lt;code&gt;tryAny&lt;/code&gt; を用いて移動してください．これは非同期例外に対して支払う代償です．」
&lt;ul&gt;
&lt;li&gt;ちょっと何言ってるかよくわからない…&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;全てのリソース割り当ては &lt;code&gt;bracket&lt;/code&gt; や &lt;code&gt;finally&lt;/code&gt; のような関数で行う&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下のようにして，アプリ専用の例外を定義し使用することが推奨されている．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;AppExceptions&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;NetworkChangeError&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;FilePathError&lt;/span&gt; FilePath&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;ImpossibleError&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;  &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Exception&lt;/span&gt; &lt;span class="dt"&gt;AppExceptions&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt; &lt;span class="dt"&gt;AppExceptions&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" data-line-number="10"&gt;  show &lt;span class="fu"&gt;=&lt;/span&gt; \&lt;span class="kw"&gt;case&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" data-line-number="11"&gt;    &lt;span class="dt"&gt;NetworkChangeError&lt;/span&gt; err &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;network error: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; (unpack err)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" data-line-number="12"&gt;    &lt;span class="dt"&gt;FilePathError&lt;/span&gt; fp &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;error accessing filepath at: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; fp&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" data-line-number="13"&gt;    &lt;span class="dt"&gt;ImpossibleError&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;this codepath should never have been executed. Please report a bug.&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ちなみに，&lt;code&gt;Exception&lt;/code&gt; 型クラス(というか &lt;a href="https://hackage.haskell.org/package/base-4.11.0.0/docs/Control-Exception-Base.html#t:SomeException"&gt;&lt;code&gt;SomeException&lt;/code&gt;&lt;/a&gt; 型)は，いわゆる存在型を利用して具体型(&lt;code&gt;AppExceptions&lt;/code&gt; とか)を隠蔽している．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;疑問なところは，投げた例外を &lt;code&gt;catch&lt;/code&gt; してからディスパッチして良いのだろうか？ 実行時例外じゃなくて大域脱出をしたいだけなんだけどな． ちょっとイマイチ使い方が分からない．&lt;/p&gt;
&lt;h3 id="strict"&gt;Strict&lt;/h3&gt;
&lt;p&gt;特別な理由が無い限り，データフィールド(レコードのフィールド？？)は正格にすべき，とのこと． 割と重要そうなのに一文しかない．&lt;/p&gt;
&lt;h3 id="プロジェクトテンプレート"&gt;プロジェクトテンプレート&lt;/h3&gt;
&lt;p&gt;そのうち，新しい Stack テンプレートを作るそうだ． もちろん，&lt;code&gt;cabal&lt;/code&gt; ファイルは使わず &lt;code&gt;hpack&lt;/code&gt; を使用する．&lt;/p&gt;
&lt;h3 id="安全第一"&gt;安全第一&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rio&lt;/code&gt; は安全性を最優先しており，そのため部分関数と遅延 I/O を全力で避けている． もし，遅延 I/O を使いたい場合は &lt;code&gt;conduit&lt;/code&gt; のようなストリーミングライブラリを使いなさい，とのこと．&lt;/p&gt;
&lt;h3 id="一般化"&gt;一般化&lt;/h3&gt;
&lt;p&gt;Haskell のよくある疑問として，いつ一般化すべきか，というのがある(いつ？)． README にはいくつかの簡単なガイドラインが書いてある．&lt;/p&gt;
&lt;p&gt;パラメトリック多相の場合，わりと議論の余地が無く，多相的な方が有用． つまり，&lt;code&gt;reverse :: [a] -&amp;gt; [a]&lt;/code&gt; は &lt;code&gt;reverse :: [Int] -&amp;gt; [Int]&lt;/code&gt; より優れている．&lt;/p&gt;
&lt;p&gt;型クラスの場合は話が微妙になる． &lt;code&gt;Foldable&lt;/code&gt; や &lt;code&gt;Traversable&lt;/code&gt; のような &lt;code&gt;RIO&lt;/code&gt; で定義済みの型クラスには可能な限り一般化(インスタンスを定義)するのが良いだろう． しかし，本当の疑問は &lt;strong&gt;自身で型クラスを定義すべきかどうか&lt;/strong&gt; の場合． 原則としては可能な限りそれは避けるべきだ． もし，自身で型クラスを定義している場合は，&lt;strong&gt;自分が期待していなかった型がインスタンス化されてもバグが起きないよう&lt;/strong&gt; に気を付けること，とのこと．&lt;/p&gt;
&lt;h3 id="コーディングスタイル"&gt;コーディングスタイル&lt;/h3&gt;
&lt;p&gt;議論中だそうだ．&lt;/p&gt;
&lt;h3 id="モジュール階層"&gt;モジュール階層&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RIO.Prelude.XXX&lt;/code&gt; モジュールはドキュメントを Haddock で読みやすくするための階層で，個別にインポートすることを想定しているわけではない． と書いてあるが，結局 &lt;a href="https://github.com/commercialhaskell/rio/pull/72"&gt;ver.0.1 からは Haddock からも消えてしまった&lt;/a&gt;ので気にする必要はない．&lt;/p&gt;
&lt;h1 id="io-まわり"&gt;I/O まわり&lt;/h1&gt;
&lt;p&gt;(この話は README に書いてあるわけではないです)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RIO&lt;/code&gt; モジュールには文字列型(&lt;code&gt;String&lt;/code&gt;)の一般的な &lt;code&gt;putStr&lt;/code&gt; や &lt;code&gt;getLine&lt;/code&gt; のような I/O 関数は無い． 実用コードの場合，これらの関数を直接呼ぶことは稀だろうが，例えば CLI を作ったときに &lt;code&gt;--version&lt;/code&gt; オプションでバージョン情報を出力したい場合などがある．&lt;/p&gt;
&lt;p&gt;替わりとして次のような I/O 関数が提供されている．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Strict.ByteString&lt;/code&gt; 型の &lt;code&gt;putStr&lt;/code&gt; や &lt;code&gt;getLine&lt;/code&gt; であれば &lt;code&gt;RIO.ByteString&lt;/code&gt; モジュールで再定義されている&lt;/li&gt;
&lt;li&gt;ファイルの入出力であれば &lt;code&gt;RIO&lt;/code&gt; モジュールに &lt;code&gt;Strict.ByteString&lt;/code&gt; 版と &lt;code&gt;Text&lt;/code&gt; 版が提供されている&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Builder&lt;/code&gt; 型の標準出力 &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#v:hPutBuilder"&gt;&lt;code&gt;hPutBuilder&lt;/code&gt;&lt;/a&gt; 関数ならある&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コンソールに対する I/O はどれを使うべきかはまだ&lt;a href="https://github.com/commercialhaskell/rio/issues/5"&gt;議論中&lt;/a&gt;みたいだ．&lt;/p&gt;
&lt;h1 id="おしまい"&gt;おしまい&lt;/h1&gt;
&lt;p&gt;何となく&lt;a href="https://github.com/matsubara0507/scrapbook/tree/rio"&gt;置き換えはできた&lt;/a&gt;けど，例外や I/O 回りは良く分かってない… また試していこう．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://kurokawh.blogspot.com/2018/02/windows-windows10.html</id><title type="text">[windows] Windows10セットアップ・設定項目のメモ</title><updated>2018-04-12T13:07:28.167+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2018/02/windows-windows10.html"/><summary type="text">Windows10セットアップ時の設定項目、インストールアプリの備忘録。


スタートメニュー・タスクバーの設定

タスクバーの設定 

小さいタスクバーボタンを使う：オン 
[スタート]ボタンを右クリックするかWindowsキー＋Xキーを押したときに表示されるメニューで、コマンドプロンプトをWindows PowerShellに置き換える：オフ
タスクバーボタンを結合する

「タスクバーに入りきらない場合」を選択

タスクバーをすべての ディスプレイに表示する：オフ



 Quick Launcherを表示する

クイック起動を復活する 
Windows 10 タスクバーにクイック起動を表示する

スタートメニューにコントロールパネルを表示する

「Windows 10」のコントロールパネルを表示する方法について

スタートメニューにピン止めするアプリ：

Windowsシステム</summary></entry><entry><id>https://haskell.jp/blog/posts/2018/main-tester.html</id><title type="text">CLIアプリのE2Eテストを行うためのライブラリー main-testerをリリースしました</title><updated>2018-04-09T00:00:00Z</updated><author><name>Haskell-jp</name></author><link href="https://haskell.jp/blog/posts/2018/main-tester.html"/><summary type="html">&lt;article&gt;
    &lt;div class="container"&gt;
        &lt;div class="row"&gt;
            &lt;div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10"&gt;
                &lt;ul class="social-buttons"&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a href="https://twitter.com/share" class="twitter-share-button"&gt;Tweet&lt;/a&gt;
                        &lt;script&gt;!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;script type="text/javascript"&gt;
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        &lt;/script&gt;
                        &lt;script type="text/javascript" src="//www.redditstatic.com/button/button1.js"&gt;&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"&gt;&lt;/a&gt;
                        &lt;script type="text/javascript"&gt;!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"&gt;
              &lt;hr /&gt;
&lt;p&gt;こんにちは。みなさん、テストは書いてますか？&lt;br /&gt;
「&lt;a href="http://syocy.hatenablog.com/entry/haskell-library-2016#%E3%83%86%E3%82%B9%E3%83%88"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;ライブラリ所感&lt;span class="ascii"&gt;2016&lt;/span&gt;&lt;/a&gt;」という記事でも紹介されているとおり、&lt;span class="ascii"&gt;Haskell&lt;/span&gt;にも様々なテスト用ライブラリーがあります。&lt;br /&gt;
今回は、「&lt;span class="ascii"&gt;Haskell&lt;/span&gt;ライブラリ所感&lt;span class="ascii"&gt;2016&lt;/span&gt;」でも紹介されている&lt;a href="https://hackage.haskell.org/package/silently"&gt;&lt;span class="ascii"&gt;silently&lt;/span&gt;&lt;/a&gt;というパッケージにインスパイアされた、新しいテスト用ライブラリーを作りました。&lt;br /&gt;
タイトルにも書きましたが&lt;a href="https://hackage.haskell.org/package/main-tester"&gt;&lt;span class="ascii"&gt;main-tester&lt;/span&gt;&lt;/a&gt;といいます。&lt;/p&gt;
&lt;h1 id="main-testerができること"&gt;&lt;span class="ascii"&gt;main-tester&lt;/span&gt;ができること&lt;/h1&gt;
&lt;p&gt;&lt;span class="ascii"&gt;main-tester&lt;/span&gt;は名前の通り、&lt;code&gt;main&lt;/code&gt;関数のテストをサポートするライブラリーです。&lt;br /&gt;
&lt;span class="ascii"&gt;Haskell&lt;/span&gt;製のプログラムを起動すると最初に実行される、あの&lt;code&gt;main&lt;/code&gt;関数です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt;関数は&lt;code&gt;IO ()&lt;/code&gt;という型であるとおり、原則として必ず入出力を伴うので、自動テストがしにくい関数です。&lt;br /&gt;
一般的なベストプラクティスとしては、できるだけ&lt;code&gt;IO&lt;/code&gt;でない、純粋な関数を中心にテストを書いていくのが普通でしょう。&lt;br /&gt;
それでも敢えて&lt;code&gt;main&lt;/code&gt;関数の自動テストを書くのには、以下のメリットがあります。&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;関数をテストすると言うことは、作っているコマンドの、ユーザーの要求に最も近いレベルのテスト、&lt;span class="ascii"&gt;E2E&lt;/span&gt;テスト（&lt;span class="ascii"&gt;end-to-end&lt;/span&gt; テスト）をすることができる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;関数（や、その他の&lt;code&gt;IO&lt;/code&gt;を伴う関数）に対するテストは、データベースやファイルシステムなど、外部のソフトウェアとの「組み合わせ」で起こるバグを検出できる。
&lt;ul&gt;
&lt;li&gt;経験上、特に単純なアプリケーションでは、そうした外部のソフトウェアに対する「誤解」が原因となったバグが比較的多いように感じています。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;私の個人的な都合ですが、趣味では小さなアプリケーションを書くことが多いので、そうした&lt;span class="ascii"&gt;E2E&lt;/span&gt;テストの方が効果的だったりする。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;このように、&lt;code&gt;main&lt;/code&gt;関数をはじめとする、&lt;code&gt;IO&lt;/code&gt;な関数に対して敢えて自動テストを書くことには、様々なメリットがあります。&lt;br /&gt;
&lt;code&gt;main-tester&lt;/code&gt;はそうした&lt;code&gt;IO&lt;/code&gt;な関数をテストする際に伴う、&lt;span class="ascii"&gt;2&lt;/span&gt;つの問題を解決しました。&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;標準出力・標準エラー出力に出力した文字列がテストしにくい
&lt;ul&gt;
&lt;li&gt;➡️ &lt;code&gt;captureProcessResult&lt;/code&gt;という関数で、標準出力・標準エラー出力に出力した文字列をそれぞれ&lt;code&gt;ByteString&lt;/code&gt;として取得することができます。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;標準入力から文字列を読み出そうとすると、テストの実行が停止してしまう。
&lt;ul&gt;
&lt;li&gt;➡️ &lt;code&gt;withStdin&lt;/code&gt;という関数で、標準入力に与えたい文字列を&lt;code&gt;ByteString&lt;/code&gt;として与えることができます。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ここに書いたことは、ビルドした実行ファイルを子プロセスとして呼び出すことによってもできます。&lt;br /&gt;
入出力の順番など、標準出力や標準エラー出力のより細かい挙動をテストするにはその方がいいでしょう&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;。&lt;br /&gt;
しかし、テストのために&lt;code&gt;PATH&lt;/code&gt;を分離させる必要があったり、そのために&lt;a href="https://github.com/commercialhaskell/stack/issues/2885"&gt;&lt;code&gt;stack exec&lt;/code&gt;を使ったらめっちゃ遅い&lt;/a&gt;という問題があったり、そもそも子プロセス呼び出しはそれだけでオーバーヘッドがあったりと、様々な問題があります。&lt;br /&gt;
物事をよりシンプルにするには、&lt;code&gt;main&lt;/code&gt;関数を直接呼び出した方がよいでしょう。&lt;br /&gt;
&lt;span class="ascii"&gt;main-tester&lt;/span&gt;は、&lt;span class="ascii"&gt;CLI&lt;/span&gt;アプリケーションの&lt;span class="ascii"&gt;E2E&lt;/span&gt;テストにおける、そうした子プロセスの呼び出しの問題と、より大きな関数をテストしたいというニーズに応えるためのライブラリーなのです。&lt;/p&gt;
&lt;h1 id="ほかのライブラリーとの違い"&gt;ほかのライブラリーとの違い&lt;/h1&gt;
&lt;p&gt;「&lt;span class="ascii"&gt;silently&lt;/span&gt;というパッケージにインスパイアされた」と冒頭で申しましたとおり、前節で紹介した機能は、実はすでにほかのライブラリーに似たものがあります。&lt;br /&gt;
&lt;span class="ascii"&gt;silently&lt;/span&gt;に加え、&lt;a href="https://hackage.haskell.org/package/imperative-edsl-0.7.1/docs/System-IO-Fake.html"&gt;&lt;span class="ascii"&gt;imperative-edsl&lt;/span&gt;というパッケージに含まれる、&lt;code&gt;System.IO.Fake&lt;/code&gt;というモジュール&lt;/a&gt;です&lt;small&gt;（ほかにもあったらすみません！🙇🙇🙇）&lt;/small&gt;。&lt;br /&gt;
これらと&lt;span class="ascii"&gt;main-tester&lt;/span&gt;との違いは何でしょう？&lt;/p&gt;
&lt;p&gt;第一に、先ほども触れましたが、&lt;span class="ascii"&gt;main-tester&lt;/span&gt;の&lt;code&gt;captureProcessResult&lt;/code&gt;関数や&lt;code&gt;withStdin&lt;/code&gt;関数は、標準出力・標準エラー出力・標準入力でやりとりする文字列を&lt;span class="ascii"&gt;strict&lt;/span&gt;な&lt;code&gt;ByteString&lt;/code&gt;でやりとりします。&lt;br /&gt;
&lt;span class="ascii"&gt;silently&lt;/span&gt;や&lt;code&gt;System.IO.Fake&lt;/code&gt;は、&lt;code&gt;String&lt;/code&gt;なのです。&lt;br /&gt;
&lt;code&gt;ByteString&lt;/code&gt;は文字通り任意のバイト列を扱うことができるので、「&lt;span class="ascii"&gt;Unicode&lt;/span&gt;の文字のリスト」である&lt;code&gt;String&lt;/code&gt;よりも、多様なデータを扱うことができます。&lt;/p&gt;
&lt;p&gt;これは、特に複数の種類の文字コードを扱うとき、非常に重要な機能となります。&lt;br /&gt;
&lt;a href="https://haskell.jp/blog/posts/2017/windows-gotchas.html"&gt;以前の記事で取り上げた、&lt;code&gt;Invalid character&lt;/code&gt;というエラー&lt;/a&gt;を再現させる場合も、ないと大変やりづらいでしょう。&lt;/p&gt;
&lt;p&gt;第二に、&lt;span class="ascii"&gt;main-tester&lt;/span&gt;の&lt;code&gt;captureProcessResult&lt;/code&gt;関数は、&lt;code&gt;main&lt;/code&gt;関数の終了コードも&lt;a href="https://hackage.haskell.org/package/base-4.11.0.0/docs/System-Exit.html#t:ExitCode"&gt;&lt;code&gt;ExitCode&lt;/code&gt;型&lt;/a&gt;の値として取得できます。&lt;br /&gt;
&lt;code&gt;main&lt;/code&gt;関数の中で&lt;code&gt;exitFailure&lt;/code&gt;等の関数を呼び出すと、&lt;code&gt;ExitCode&lt;/code&gt;が例外として投げられます。&lt;br /&gt;
既存のライブラリーでこれを行うと、&lt;code&gt;ExitCode&lt;/code&gt;が例外として処理されるため、テストしたい&lt;code&gt;main&lt;/code&gt;関数の実行が終了してしまいます。&lt;br /&gt;
結果、&lt;code&gt;main&lt;/code&gt;関数が標準出力・標準エラー出力に書き込んだ文字列を取得することができないのです。&lt;br /&gt;
「○○というエラーメッセージを出力して異常終了する」といったことをテストしたい場合、これでは使いづらいでしょう。&lt;br /&gt;
&lt;strong&gt;「&lt;code&gt;main&lt;/code&gt;関数の&lt;span class="ascii"&gt;E2E&lt;/span&gt;テストを行うためのライブラリーである」&lt;/strong&gt;という観点から、必須の機能であると判断し、実装しました。 ちなみに、&lt;code&gt;ExitCode&lt;/code&gt;以外の例外についてはそのまま投げられます。仕様を単純にするために、これはユーザーのテストコードの中で処理することとしています。&lt;/p&gt;
&lt;h1 id="使い方バグ報告"&gt;使い方・バグ報告&lt;/h1&gt;
&lt;p&gt;機能は非常にシンプルなので、使い方については&lt;a href="https://hackage.haskell.org/package/main-tester-0.1.0.0/docs/Test-Main.html"&gt;ドキュメント&lt;/a&gt;のサンプルコードを読めば大体わかるかなぁと思いますが、簡単にサンプルを載せておきましょう。&lt;/p&gt;
&lt;p&gt;例えばこんなソース👇のプログラムがあった場合、&lt;/p&gt;
&lt;p&gt;&lt;span class="ascii"&gt;ExampleMain.hs:&lt;/span&gt;&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;ExampleMain&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.List&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;System.Exit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;  putStr &lt;span class="st"&gt;&amp;quot;What&amp;#39;s your name?: &amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;  name &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getLine&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;  &lt;span class="kw"&gt;if&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Yuji&amp;quot;&lt;/span&gt; &lt;span class="ot"&gt;`isInfixOf`&lt;/span&gt; name&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;    &lt;span class="kw"&gt;then&lt;/span&gt; putStrLn &lt;span class="st"&gt;&amp;quot;Nice name!&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;    &lt;span class="kw"&gt;else&lt;/span&gt; die &lt;span class="fu"&gt;$&lt;/span&gt; name &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;? Sorry I don&amp;#39;t know such a guy!&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="ascii"&gt;main-tester&lt;/span&gt;を使えば、次のように&lt;span class="ascii"&gt;Hspec&lt;/span&gt;でテストできます。&lt;/p&gt;
&lt;p&gt;&lt;span class="ascii"&gt;ExampleSpec.hs:&lt;/span&gt;&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;System.Exit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Test.Main&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Test.Hspec&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;ExampleMain&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Data.ByteString&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;B&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; hspec &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;  describe &lt;span class="st"&gt;&amp;quot;your-cool-command&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;    context &lt;span class="st"&gt;&amp;quot;Given &amp;#39;Yuji&amp;#39; to stdin&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;      it &lt;span class="st"&gt;&amp;quot;prints a string including &amp;#39;Nice name&amp;#39; without an error&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;        result &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; withStdin &lt;span class="st"&gt;&amp;quot;Yuji&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;$&lt;/span&gt; captureProcessResult ExampleMain.main&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-14" data-line-number="14"&gt;        prExitCode result &lt;span class="ot"&gt;`shouldBe`&lt;/span&gt; &lt;span class="dt"&gt;ExitSuccess&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-15" data-line-number="15"&gt;        prStderr result &lt;span class="ot"&gt;`shouldSatisfy`&lt;/span&gt; B.null&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-16" data-line-number="16"&gt;        prStdout result &lt;span class="ot"&gt;`shouldSatisfy`&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;Nice name&amp;quot;&lt;/span&gt; &lt;span class="ot"&gt;`B.isInfixOf`&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-17" data-line-number="17"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-18" data-line-number="18"&gt;    context &lt;span class="st"&gt;&amp;quot;Given other name to stdin&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-19" data-line-number="19"&gt;      it &lt;span class="st"&gt;&amp;quot;prints an error message&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-20" data-line-number="20"&gt;        result &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; withStdin &lt;span class="st"&gt;&amp;quot;other name&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; captureProcessResult ExampleMain.main&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-21" data-line-number="21"&gt;        prExitCode result &lt;span class="ot"&gt;`shouldBe`&lt;/span&gt; &lt;span class="dt"&gt;ExitFailure&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-22" data-line-number="22"&gt;        prStderr result &lt;span class="ot"&gt;`shouldSatisfy`&lt;/span&gt; (not &lt;span class="fu"&gt;.&lt;/span&gt; B.null)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;それぞれのファイルを同じディレクトリーに置いた上で、次のように実行すれば試せるはずです &lt;small&gt;（&lt;span class="ascii"&gt;cabal&lt;/span&gt;ユーザーの皆さんは適当に読み替えてください…）&lt;/small&gt;。&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="ex"&gt;stack&lt;/span&gt; build hspec main-tester&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="ex"&gt;stack&lt;/span&gt; exec runghc -- --ghc-arg=-i. ExampleSpec.hs&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;span class="ex"&gt;your-cool-command&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;  &lt;span class="ex"&gt;Given&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;Yuji&amp;#39;&lt;/span&gt; to stdin&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;    &lt;span class="ex"&gt;prints&lt;/span&gt; a string including &lt;span class="st"&gt;&amp;#39;Nice name&amp;#39;&lt;/span&gt; without an error&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;  &lt;span class="ex"&gt;Given&lt;/span&gt; other name to stdin&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;    &lt;span class="ex"&gt;prints&lt;/span&gt; an error message&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;&lt;span class="ex"&gt;Finished&lt;/span&gt; in 0.0130 seconds&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" data-line-number="11"&gt;&lt;span class="ex"&gt;2&lt;/span&gt; examples, 0 failures&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;バグを見つけたら&lt;a href="https://gitlab.com/igrep/main-tester/issues"&gt;こちらの&lt;span class="ascii"&gt;GitLab&lt;/span&gt;の&lt;span class="ascii"&gt;Issue&lt;/span&gt;&lt;/a&gt;に報告してください&lt;small&gt;（最近の個人的な判官贔屓により、敢えて&lt;span class="ascii"&gt;GitLab&lt;/span&gt;にしております 😏）&lt;/small&gt;。&lt;br /&gt;
それではこの春は&lt;span class="ascii"&gt;main-tester&lt;/span&gt;で&lt;span class="ascii"&gt;Happy Haskell Testing!!&lt;/span&gt; 💚💚💚&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;&lt;code&gt;main&lt;/code&gt;関数を子スレッドとして&lt;code&gt;forkIO&lt;/code&gt;することで同じことが恐らくできますが、テスト結果の報告に使うべき、標準出力・標準エラー出力を食い合うことになってしまうので、非常にやりづらいと思います。&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div id="post-navigation" class="row" style="margin-top: 20px;"&gt;
            &lt;div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4"&gt;
                
            &lt;/div&gt;
            &lt;div class="col-lg-2 col-md-2 col-xs-4 text-center"&gt;
                &lt;a href="/"&gt;トップに戻る&lt;/a&gt;
            &lt;/div&gt;
            &lt;div class="col-lg-3 col-md-4 col-xs-4"&gt;
                
                &lt;a href="/posts/2018/renew-haskell-antenna.html" style="margin-left: auto;"&gt;Haskell Antenna をリニューアルしました&lt;/a&gt;
                &lt;i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"&gt;&lt;/i&gt;
                
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/article&gt;

</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/04-08-quiz-8.html</id><title type="text">Haskell Quiz No.8 Conduit Part.4</title><updated>2018-04-08T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/04-08-quiz-8.html"/><summary type="html">&lt;h2 id="haskell-quiz-no.8"&gt;Haskell Quiz No.8&lt;/h2&gt;
&lt;p&gt;難易度: λλλ&lt;/p&gt;
&lt;p&gt;以下の &lt;code&gt;Conduit&lt;/code&gt; を使ったコードの実行結果を予想してみてください！&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.3&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; runConduitPure &lt;span class="fu"&gt;$&lt;/span&gt; return () &lt;span class="fu"&gt;.|&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;    mapM_ leftover [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;    sinkList&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;答えは次回。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href="./04-07-quiz-7.html"&gt;前回&lt;/a&gt;の問題と答えは以下の通りです。&lt;/p&gt;
&lt;h3 id="問題"&gt;問題&lt;/h3&gt;
&lt;p&gt;難易度: λλ&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.3&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="ot"&gt;myTakeWhileC ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (i &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitM&lt;/span&gt; i i m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;myTakeWhileC f &lt;span class="fu"&gt;=&lt;/span&gt; loop&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;    loop &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;      mx &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; await&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;      &lt;span class="kw"&gt;case&lt;/span&gt; mx &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;        &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; return ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;        &lt;span class="dt"&gt;Just&lt;/span&gt; x&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;          &lt;span class="fu"&gt;|&lt;/span&gt; f x       &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; yield x &lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; loop&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-14" data-line-number="14"&gt;          &lt;span class="fu"&gt;|&lt;/span&gt; otherwise &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; return ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-16" data-line-number="16"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-17" data-line-number="17"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; runConduitPure &lt;span class="fu"&gt;$&lt;/span&gt; yieldMany [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="fu"&gt;.|&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-18" data-line-number="18"&gt;  x &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; myTakeWhileC (&lt;span class="fu"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt;) &lt;span class="fu"&gt;.|&lt;/span&gt; sinkList&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-19" data-line-number="19"&gt;  y &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; sinkList&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-20" data-line-number="20"&gt;  return (x, y)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="こたえ"&gt;こたえ&lt;/h3&gt;
&lt;p&gt;実際に実行してみましょう！&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ ./Quiz7.hs
([1,2,3,4,5],[7,8,9,10])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6&lt;/strong&gt; が抜けていることに注意してくださいね！&lt;/p&gt;
&lt;h3 id="解説"&gt;解説&lt;/h3&gt;
&lt;p&gt;今回の問題は &lt;code&gt;[1,2,3,4,5],[7,8,9,10]&lt;/code&gt; ではなく &lt;code&gt;[1,2,3,4,5],[6,7,8,9,10]&lt;/code&gt; と思った人もいるのではないでしょうか？&lt;/p&gt;
&lt;p&gt;では何故このような動作になってしまうのか、それは &lt;code&gt;myTakeWhileC&lt;/code&gt; 関数に秘密があります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;myTakeWhileC ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (i &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitM&lt;/span&gt; i i m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;myTakeWhileC f &lt;span class="fu"&gt;=&lt;/span&gt; loop&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;    loop &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;      mx &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; await&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" data-line-number="6"&gt;      &lt;span class="kw"&gt;case&lt;/span&gt; mx &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-7" data-line-number="7"&gt;        &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; return ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-8" data-line-number="8"&gt;        &lt;span class="dt"&gt;Just&lt;/span&gt; x&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-9" data-line-number="9"&gt;          &lt;span class="fu"&gt;|&lt;/span&gt; f x       &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; yield x &lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; loop&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-10" data-line-number="10"&gt;          &lt;span class="fu"&gt;|&lt;/span&gt; otherwise &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; return ()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この関数を理解するためには、以下の2点を抑えておけば十分です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;await&lt;/code&gt; は上流のパイプに対して、値をチャンクサイズで1つ要求する関数です。(チャンクサイズは型によって違います。リストであれば要素1つですが、&lt;code&gt;ByteString&lt;/code&gt; であれば &lt;strong&gt;1byte&lt;/strong&gt; や &lt;strong&gt;1文字&lt;/strong&gt; ではなく！ &lt;strong&gt;32kbyte&lt;/strong&gt;になります。)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yield&lt;/code&gt; は下流のパイプに値を流す関数です&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;つまり、この関数は上流からデータを取得し、&lt;code&gt;f x&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; であれば下流にデータを流す準備を行い、同じ処理を繰り返します。(また、上流のデータが無くなれば &lt;code&gt;await&lt;/code&gt; の結果は &lt;code&gt;Nothing&lt;/code&gt; となるため、そこで処理が止まります)&lt;/p&gt;
&lt;p&gt;今回の &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;(&amp;lt;= 5)&lt;/code&gt; なので流れてくる値が &lt;code&gt;5&lt;/code&gt; 以下の間は、上流から流れてきた値をそのまま下流に流す準備をします。&lt;/p&gt;
&lt;p&gt;図で書くとこんな感じでしょうか。&lt;code&gt;yield&lt;/code&gt; の準備完了と &lt;code&gt;await&lt;/code&gt; の要求を青と赤の実線で表現しています。(破線はそうでない場合)&lt;/p&gt;
&lt;p&gt;下記の図は一番最初の &lt;code&gt;await&lt;/code&gt; です。&lt;code&gt;sinkList&lt;/code&gt; も &lt;code&gt;await&lt;/code&gt; していますが、先に &lt;code&gt;myTakeWhileC&lt;/code&gt; 関数によって消費されてしまうため、データは届きません。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;myTakeWhileC&lt;/code&gt; に適用した &lt;strong&gt;1&lt;/strong&gt; は条件を満たすため、さらに下流の &lt;code&gt;sinkList&lt;/code&gt; にデータを流す準備を行い、&lt;code&gt;sinkList&lt;/code&gt; が &lt;code&gt;await&lt;/code&gt; したタイミングでデータが流れます。&lt;/p&gt;
&lt;p&gt;&lt;img class="no-border" src="/images/2018/04-08/quiz8-1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 〜 5&lt;/strong&gt; の場合も同様に処理されます。そのため、&lt;code&gt;main&lt;/code&gt; 関数の &lt;code&gt;x &amp;lt;- myTakeWhileC (&amp;lt;= 5) .| sinkList&lt;/code&gt; の &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;[1,2,3,5,]&lt;/code&gt; という値になります。&lt;/p&gt;
&lt;p&gt;次に条件を満たさない &lt;strong&gt;6&lt;/strong&gt; の場合を考えましょう。&lt;/p&gt;
&lt;p&gt;この場合は &lt;code&gt;myTakeWhileC&lt;/code&gt; 関数は &lt;code&gt;return ()&lt;/code&gt; を返します。そのため下流の &lt;code&gt;sinkList&lt;/code&gt; にはデータを流しません。&lt;/p&gt;
&lt;p&gt;&lt;img class="no-border" src="/images/2018/04-08/quiz8-2.png"&gt;&lt;/p&gt;
&lt;p&gt;ここで &lt;strong&gt;6&lt;/strong&gt; のデータが消え去ります。通常、一度消費してしまった値については再利用できません。(ここでは解説しませんが、&lt;code&gt;Conduit&lt;/code&gt; では &lt;code&gt;leftover&lt;/code&gt; という関数を使って一度消費してしまった値を上流に返すための関数が定義されています)&lt;/p&gt;
&lt;p&gt;&lt;img class="no-border" src="/images/2018/04-08/quiz8-3.png"&gt;&lt;/p&gt;
&lt;p&gt;そのため、次は &lt;strong&gt;7&lt;/strong&gt; が2つ目の &lt;code&gt;sinkList&lt;/code&gt; に流れます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8 〜 10&lt;/strong&gt; についても同様に処理されるため、結果として &lt;code&gt;y &amp;lt;- sinkList&lt;/code&gt; の &lt;code&gt;y&lt;/code&gt; は &lt;code&gt;[7,8,9,10]&lt;/code&gt; となります。&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;パイプを流れるデータは&lt;strong&gt;チャンクサイズ&lt;/strong&gt;ということを意識する。&lt;/li&gt;
&lt;li&gt;消費してしまったデータは &lt;code&gt;leftover&lt;/code&gt; を使わない限り取り戻せない&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/04-07-quiz-7.html</id><title type="text">Haskell Quiz No.7 Conduit Part.3</title><updated>2018-04-07T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/04-07-quiz-7.html"/><summary type="html">&lt;h2 id="haskell-quiz-no.7"&gt;Haskell Quiz No.7&lt;/h2&gt;
&lt;p&gt;難易度: λλ&lt;/p&gt;
&lt;p&gt;以下の &lt;code&gt;Conduit&lt;/code&gt; を使ったコードの実行結果を予想してみてください！&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.3&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;span class="ot"&gt;myTakeWhileC ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (i &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitM&lt;/span&gt; i i m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;myTakeWhileC f &lt;span class="fu"&gt;=&lt;/span&gt; loop&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;    loop &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;      mx &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; await&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;      &lt;span class="kw"&gt;case&lt;/span&gt; mx &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;        &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; return ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;        &lt;span class="dt"&gt;Just&lt;/span&gt; x&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;          &lt;span class="fu"&gt;|&lt;/span&gt; f x       &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; yield x &lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; loop&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" data-line-number="14"&gt;          &lt;span class="fu"&gt;|&lt;/span&gt; otherwise &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; return ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" data-line-number="16"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-17" data-line-number="17"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; runConduitPure &lt;span class="fu"&gt;$&lt;/span&gt; yieldMany [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="fu"&gt;.|&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-18" data-line-number="18"&gt;  x &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; myTakeWhileC (&lt;span class="fu"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt;) &lt;span class="fu"&gt;.|&lt;/span&gt; sinkList&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-19" data-line-number="19"&gt;  y &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; sinkList&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-20" data-line-number="20"&gt;  return (x, y)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;答えは&lt;a href="04-08-quiz-8.html"&gt;次回&lt;/a&gt;。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href="./04-06-quiz-6.html"&gt;前回&lt;/a&gt;の問題と答えは以下の通りです。&lt;/p&gt;
&lt;h3 id="問題"&gt;問題&lt;/h3&gt;
&lt;p&gt;難易度: λλ&lt;/p&gt;
&lt;p&gt;以下の &lt;code&gt;Conduit&lt;/code&gt; を使ったコードの実行結果を予想してみてください！&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="ot"&gt;trans ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitM&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;trans &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;  takeC &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="fu"&gt;.|&lt;/span&gt; mapC (&lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;  mapC (&lt;span class="fu"&gt;*&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; runConduit &lt;span class="fu"&gt;$&lt;/span&gt; yieldMany [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="fu"&gt;.|&lt;/span&gt; trans &lt;span class="fu"&gt;.|&lt;/span&gt; mapM_C print&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="こたえ"&gt;こたえ&lt;/h3&gt;
&lt;p&gt;実際に実行してみましょう！&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ ./Quiz6.hs
2
3
4
5
6
12
14
16
18
20&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="haskell-quiz-no.6-の解説"&gt;Haskell Quiz No.6 の解説&lt;/h2&gt;
&lt;p&gt;この問題で重要なのは &lt;code&gt;trans&lt;/code&gt; 関数です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;trans ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitM&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;trans &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;  takeC &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="fu"&gt;.|&lt;/span&gt; mapC (&lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;  mapC (&lt;span class="fu"&gt;*&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;1つめのパイプ &lt;code&gt;takeC 5 .| mapC (+ 1)&lt;/code&gt; によって &lt;code&gt;[1..10]&lt;/code&gt; のうち &lt;code&gt;[1..5]&lt;/code&gt; が &lt;code&gt;mapC (+ 1)&lt;/code&gt; によって処理されます。&lt;/li&gt;
&lt;li&gt;2つめのパイプ &lt;code&gt;mapC (* 2)&lt;/code&gt; によって残りの &lt;code&gt;[6..10]&lt;/code&gt; が &lt;code&gt;mapC (* 2)&lt;/code&gt; によって処理されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そのため、結果として以下のような出力となりました。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="dv"&gt;2&lt;/span&gt;  &lt;span class="co"&gt;-- 1+1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="dv"&gt;3&lt;/span&gt;  &lt;span class="co"&gt;-- 2+1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;span class="dv"&gt;4&lt;/span&gt;  &lt;span class="co"&gt;-- 3+1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;&lt;span class="dv"&gt;5&lt;/span&gt;  &lt;span class="co"&gt;-- 4+1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;&lt;span class="dv"&gt;6&lt;/span&gt;  &lt;span class="co"&gt;-- 5+1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" data-line-number="6"&gt;&lt;span class="dv"&gt;12&lt;/span&gt; &lt;span class="co"&gt;-- 6*2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" data-line-number="7"&gt;&lt;span class="dv"&gt;14&lt;/span&gt; &lt;span class="co"&gt;-- 7*2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-8" data-line-number="8"&gt;&lt;span class="dv"&gt;16&lt;/span&gt; &lt;span class="co"&gt;-- 8*2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-9" data-line-number="9"&gt;&lt;span class="dv"&gt;18&lt;/span&gt; &lt;span class="co"&gt;-- 9*2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-10" data-line-number="10"&gt;&lt;span class="dv"&gt;20&lt;/span&gt; &lt;span class="co"&gt;-- 10*2&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大前提として、このパイプにデータが流れるのは &lt;code&gt;mapM_C print&lt;/code&gt; によって上流のデータが無くなるまでデータを要求するという操作があるためです。&lt;/p&gt;
&lt;p&gt;そのため、 &lt;code&gt;mapM_C print&lt;/code&gt; を &lt;code&gt;sinkNull&lt;/code&gt; にすると何も表示されなくなります。&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Conduit&lt;/code&gt; は何も知らずにいつも通りの感覚で利用すると、直感と違う動きをすることがあるので、簡単な例を通して慣れていくと良いと思います。&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/04-06-quiz-6.html</id><title type="text">Haskell Quiz No.6 Conduit Part.2</title><updated>2018-04-06T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/04-06-quiz-6.html"/><summary type="html">&lt;h2 id="haskell-quiz-no.6"&gt;Haskell Quiz No.6&lt;/h2&gt;
&lt;p&gt;難易度: λλ&lt;/p&gt;
&lt;p&gt;以下の &lt;code&gt;Conduit&lt;/code&gt; を使ったコードの実行結果を予想してみてください！&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;span class="ot"&gt;trans ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitM&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;trans &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;  takeC &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="fu"&gt;.|&lt;/span&gt; mapC (&lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;  mapC (&lt;span class="fu"&gt;*&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; runConduit &lt;span class="fu"&gt;$&lt;/span&gt; yieldMany [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="fu"&gt;.|&lt;/span&gt; trans &lt;span class="fu"&gt;.|&lt;/span&gt; mapM_C print&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;答えは&lt;a href="04-07-quiz-7.html"&gt;次回&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;最近は &lt;code&gt;Conduit&lt;/code&gt; にはまっているので、クイズも &lt;code&gt;Conduit&lt;/code&gt; が続きます。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href="./03-31-quiz-5.html"&gt;前回&lt;/a&gt;の問題と答えは以下の通りです。&lt;/p&gt;
&lt;h3 id="問題"&gt;問題&lt;/h3&gt;
&lt;p&gt;難易度: λλ&lt;/p&gt;
&lt;p&gt;以下の &lt;code&gt;Conduit&lt;/code&gt; を使ったコードの実行結果を予想してみてください！&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="ot"&gt;sink ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitM&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; o m (&lt;span class="dt"&gt;String&lt;/span&gt;, &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;sink &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;  x &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; takeC &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="fu"&gt;.|&lt;/span&gt; mapC show &lt;span class="fu"&gt;.|&lt;/span&gt; foldC&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;  y &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; sumC&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;  return (x, y)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; res &lt;span class="fu"&gt;=&lt;/span&gt; runConduitPure &lt;span class="fu"&gt;$&lt;/span&gt; yieldMany [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="fu"&gt;.|&lt;/span&gt; sink&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-14" data-line-number="14"&gt;  print res&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="こたえ"&gt;こたえ&lt;/h3&gt;
&lt;p&gt;実際に実行してみましょう！&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ ./Quiz5.hs
(&amp;quot;12345&amp;quot;,40)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;どうですか？予想通りでしたか？？&lt;/p&gt;
&lt;h2 id="haskell-quiz-no.5-の解説"&gt;Haskell Quiz No.5 の解説&lt;/h2&gt;
&lt;p&gt;この問題を解くためには &lt;a href="https://www.stackage.org/lts-11.3/package/conduit-1.3.0.2"&gt;conduit&lt;/a&gt; というストリーム処理ライブラリの知識が必要になります。&lt;/p&gt;
&lt;h3 id="conduit-を使うモチベーション"&gt;Conduit を使うモチベーション&lt;/h3&gt;
&lt;p&gt;具体例として指定したディレクトリ以下の&lt;strong&gt;ファイル数&lt;/strong&gt;と&lt;strong&gt;容量の合計&lt;/strong&gt;を出力するようなプログラムを作ってみましょう。&lt;/p&gt;
&lt;p&gt;ディレクトリ操作については &lt;a href="https://www.stackage.org/lts-11.3/package/directory-1.3.0.2"&gt;directory&lt;/a&gt; パッケージに便利な関数が色々と定義されているので、このパッケージを利用します。&lt;/p&gt;
&lt;p&gt;必要な操作と、対応する関数は以下の通りです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ファイルの列挙: &lt;a href="https://www.stackage.org/haddock/lts-11.3/directory-1.3.0.2/System-Directory.html#v:listDirectory"&gt;listDirectory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ファイルサイズの取得: &lt;a href="https://www.stackage.org/haddock/lts-11.3/directory-1.3.0.2/System-Directory.html#v:getFileSize"&gt;getFileSize&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ファイル・ディレクトリの判定: &lt;a href="https://www.stackage.org/haddock/lts-11.3/directory-1.3.0.2/System-Directory.html#v:doesFileExist"&gt;doesFileExist&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらの関数を使って、こんな感じでプログラムを作ることができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;span class="co"&gt;{-&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="co"&gt;stack script --resolver lts-11.3&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;span class="co"&gt;  --package extra&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;&lt;span class="co"&gt;  --package filepath&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" data-line-number="6"&gt;&lt;span class="co"&gt;  --package directory&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-7" data-line-number="7"&gt;&lt;span class="co"&gt;-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-9" data-line-number="9"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;System.Environment&lt;/span&gt; (getArgs)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-10" data-line-number="10"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;System.Directory&lt;/span&gt; (listDirectory, doesFileExist, getFileSize)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-11" data-line-number="11"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;System.FilePath&lt;/span&gt; ((&amp;lt;/&amp;gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-12" data-line-number="12"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Control.Monad.Extra&lt;/span&gt; (partitionM, ifM)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-13" data-line-number="13"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Control.Monad&lt;/span&gt; (when)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-14" data-line-number="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-15" data-line-number="15"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-16" data-line-number="16"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-17" data-line-number="17"&gt;  arg &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getArgs&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-18" data-line-number="18"&gt;  when (length arg &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-19" data-line-number="19"&gt;    (cnt, size) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; recListDir &lt;span class="fu"&gt;$&lt;/span&gt; head arg&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-20" data-line-number="20"&gt;    putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;総ファイル数: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show cnt&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-21" data-line-number="21"&gt;    putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;総ファイルサイズ: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show size&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-22" data-line-number="22"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-23" data-line-number="23"&gt;&lt;span class="ot"&gt;recListDir ::&lt;/span&gt; FilePath &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;Int&lt;/span&gt;, &lt;span class="dt"&gt;Integer&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-24" data-line-number="24"&gt;recListDir fp &lt;span class="fu"&gt;=&lt;/span&gt; loop (&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;) [fp]&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-25" data-line-number="25"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-26" data-line-number="26"&gt;    loop summary [] &lt;span class="fu"&gt;=&lt;/span&gt; return summary&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-27" data-line-number="27"&gt;    loop (accCnt, accSize) (fp&lt;span class="fu"&gt;:&lt;/span&gt;fps) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-28" data-line-number="28"&gt;      dirs &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; listDirectory fp&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-29" data-line-number="29"&gt;      (files, childDirs) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; partitionM doesFileExist &lt;span class="fu"&gt;$&lt;/span&gt; map (fp &lt;span class="fu"&gt;&amp;lt;/&amp;gt;&lt;/span&gt;) dirs&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-30" data-line-number="30"&gt;      size &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; sum &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; mapM getFileSize files&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-31" data-line-number="31"&gt;      &lt;span class="kw"&gt;let&lt;/span&gt; summary &lt;span class="fu"&gt;=&lt;/span&gt; (accCnt &lt;span class="fu"&gt;+&lt;/span&gt; length files, accSize &lt;span class="fu"&gt;+&lt;/span&gt; size)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-32" data-line-number="32"&gt;      loop summary &lt;span class="fu"&gt;$&lt;/span&gt; fps &lt;span class="fu"&gt;++&lt;/span&gt; childDirs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実際に、プロファイリングを取得しつつ動かしてみます。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack ghc Ex &amp;amp;&amp;amp; sudo ./Ex /home/bm12/Desktop/ +RTS -s
総ファイル数: 338866
総ファイルサイズ: 37870090712&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;とりあえず、上手く動いているような気がします。&lt;/p&gt;
&lt;p&gt;しかし、メモリ使用量は・・・&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;  13,440,124,048 bytes allocated in the heap
   8,760,418,592 bytes copied during GC
   1,225,650,008 bytes maximum residency (23 sample(s))
      19,423,400 bytes maximum slop
            2599 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      9869 colls,     0 par    7.821s   9.831s     0.0010s    1.1223s
  Gen  1        23 colls,     0 par    0.011s   0.013s     0.0006s    0.0009s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    5.255s  (  6.347s elapsed)
  GC      time    7.832s  (  9.845s elapsed)
  EXIT    time    0.032s  (  0.123s elapsed)
  Total   time   13.118s  ( 16.315s elapsed)

  %GC     time      59.7%  (60.3% elapsed)

  Alloc rate    2,557,607,298 bytes per MUT second

  Productivity  40.3% of total user, 39.7% of total elapsed&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2599 MB total memory in use&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%GC time 59.7% (60.3% elapsed)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ということで、非常にやばいですね。&lt;/p&gt;
&lt;h3 id="conduit-で書き直そう"&gt;Conduit で書き直そう！&lt;/h3&gt;
&lt;p&gt;先程作ったプログラムは、どうやらスペースリークしているようです。指定したディレクトリ以下のファイルの数とファイルサイズの合計を取得するだけなのに、メモリを使いすぎですね。&lt;/p&gt;
&lt;p&gt;解決方法は色々ありますが、今回はストリームライブラリの &lt;code&gt;Conduit&lt;/code&gt; を使って解決していきましょう。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Conduit&lt;/code&gt; には &lt;a href="https://www.stackage.org/haddock/lts-11.3/conduit-1.3.0.2/Conduit.html#v:sourceDirectoryDeep"&gt;sourceDirectoryDeep&lt;/a&gt; という、関数が用意されています。&lt;/p&gt;
&lt;p&gt;だいたいこんな感じで書き直すことができます。先程の定義と比べると &lt;strong&gt;sourceDirectoryDeep&lt;/strong&gt; 関数のおかげでスッキリした印象です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;&lt;span class="co"&gt;{-&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;&lt;span class="co"&gt;stack script --resolver lts-11.3&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;&lt;span class="co"&gt;  --package conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;&lt;span class="co"&gt;  --package extra&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" data-line-number="6"&gt;&lt;span class="co"&gt;  --package directory&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-7" data-line-number="7"&gt;&lt;span class="co"&gt;-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-9" data-line-number="9"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-11" data-line-number="11"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;System.Environment&lt;/span&gt; (getArgs)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-12" data-line-number="12"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;System.Directory&lt;/span&gt; (doesFileExist, getFileSize)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-13" data-line-number="13"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Control.Monad.Extra&lt;/span&gt; (whenM)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-14" data-line-number="14"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Control.Monad&lt;/span&gt; (when)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-16" data-line-number="16"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-17" data-line-number="17"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-18" data-line-number="18"&gt;  arg &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getArgs&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-19" data-line-number="19"&gt;  when (length arg &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-20" data-line-number="20"&gt;    (cnt, size) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-21" data-line-number="21"&gt;      runConduitRes &lt;span class="fu"&gt;$&lt;/span&gt; sourceDirectoryDeep &lt;span class="dt"&gt;True&lt;/span&gt; (head arg)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-22" data-line-number="22"&gt;                   &lt;span class="fu"&gt;.|&lt;/span&gt; awaitForever getInfo&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-23" data-line-number="23"&gt;                   &lt;span class="fu"&gt;.|&lt;/span&gt; getZipSink ((,) &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ZipSink&lt;/span&gt; lengthC &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ZipSink&lt;/span&gt; sumC)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-24" data-line-number="24"&gt;    putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;総ファイル数: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show cnt&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-25" data-line-number="25"&gt;    putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;総ファイルサイズ: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show size&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-26" data-line-number="26"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-27" data-line-number="27"&gt;&lt;span class="ot"&gt;getInfo ::&lt;/span&gt; &lt;span class="dt"&gt;MonadResource&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; FilePath &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitM&lt;/span&gt; FilePath &lt;span class="dt"&gt;Integer&lt;/span&gt; m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-28" data-line-number="28"&gt;getInfo path &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-29" data-line-number="29"&gt;  whenM (liftIO &lt;span class="fu"&gt;$&lt;/span&gt; doesFileExist path) &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-30" data-line-number="30"&gt;    size &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; liftIO &lt;span class="fu"&gt;$&lt;/span&gt; getFileSize path&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-31" data-line-number="31"&gt;    yield size&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;では、同様にプロファイルを取得しつつ、実行してみましょう。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack ghc Ex2 &amp;amp;&amp;amp; sudo ./Ex2 /home/bm12/Desktop/ +RTS -s
総ファイル数: 338866
総ファイルサイズ: 37870092264&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;肝心のメモリ使用量はと言うと・・・&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;  10,742,224,392 bytes allocated in the heap
      86,720,088 bytes copied during GC
          87,576 bytes maximum residency (19 sample(s))
          33,320 bytes maximum slop
               3 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0     10347 colls,     0 par    0.146s   0.198s     0.0000s    0.0008s
  Gen  1        19 colls,     0 par    0.000s   0.001s     0.0000s    0.0001s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    5.252s  (  7.444s elapsed)
  GC      time    0.146s  (  0.198s elapsed)
  EXIT    time    0.000s  (  0.000s elapsed)
  Total   time    5.398s  (  7.642s elapsed)

  %GC     time       2.7%  (2.6% elapsed)

  Alloc rate    2,045,428,118 bytes per MUT second

  Productivity  97.3% of total user, 97.4% of total elapsed&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;3 MB total memory in use&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%GC time 2.7% (2.6% elapsed)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;どうですか？ストリーム処理って凄いですよね。&lt;/p&gt;
&lt;h3 id="解説"&gt;解説&lt;/h3&gt;
&lt;p&gt;この問題の重要なポイントは、実行すると &lt;code&gt;(&amp;quot;12345&amp;quot;, 6+7+8+9+10)&lt;/code&gt; という結果のように、&lt;code&gt;[1..10]&lt;/code&gt; のリストの前半と後半で異なる処理になっているという点です。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ ./Quiz5.hs
(&amp;quot;12345&amp;quot;,40)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここで理解しておきたい知識は以下の3点です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;データは&lt;strong&gt;パイプ&lt;/strong&gt; (ストリーム) を流れて処理されます&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yieldMany&lt;/code&gt; 関数は受け取ったデータをパイプに流す&lt;strong&gt;準備&lt;/strong&gt;をします (&lt;code&gt;yieldMany&lt;/code&gt; は自分から積極的にデータを流すことはしません。準備だけしておき &lt;code&gt;await&lt;/code&gt; 関数などで、実際に必要になった際にだけデータを流します)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.|&lt;/code&gt; はパイプを&lt;strong&gt;合成&lt;/strong&gt;します&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; res &lt;span class="fu"&gt;=&lt;/span&gt; runConduitPure &lt;span class="fu"&gt;$&lt;/span&gt; yieldMany [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="fu"&gt;.|&lt;/span&gt; sink&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;  print res&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;sink&lt;/code&gt; 関数は &lt;code&gt;takeC 5 .| mapC show .| foldC&lt;/code&gt; というパイプと &lt;code&gt;sumC&lt;/code&gt; というパイプからなる、大きなパイプです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;takeC 5 .| mapC show .| foldC&lt;/code&gt; 関数は &lt;code&gt;takeC 5&lt;/code&gt; の部分でデータを &lt;strong&gt;5つだけ&lt;/strong&gt; 上流のパイプに要求します。そのため、残りの5つのデータは次の &lt;code&gt;sumC&lt;/code&gt; に流れることになります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="ot"&gt;sink ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitM&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; o m (&lt;span class="dt"&gt;String&lt;/span&gt;, &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;sink &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;  x &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; takeC &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="fu"&gt;.|&lt;/span&gt; mapC show &lt;span class="fu"&gt;.|&lt;/span&gt; foldC &lt;span class="co"&gt;-- 1,2,3,4,5  のデータが処理される&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;  y &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; sumC                          &lt;span class="co"&gt;-- 6,7,8,9,10 のデータが処理される&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" data-line-number="5"&gt;  return (x, y)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;そのため、最終的には &lt;code&gt;(&amp;quot;12345&amp;quot;,40)&lt;/code&gt; となりました。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;12345&amp;quot;&lt;/code&gt; はそれぞれの &lt;strong&gt;Int&lt;/strong&gt; 型が &lt;code&gt;mapC show&lt;/code&gt; によって &lt;strong&gt;String&lt;/strong&gt; 型に変換され、&lt;code&gt;foldC&lt;/code&gt; の &lt;code&gt;mappend&lt;/code&gt; による畳込みによって文字列連結されます。&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;p&gt;実用的なアプリケーションを作ろうと考えている方は &lt;code&gt;Conduit&lt;/code&gt; などのストリームライブラリを理解していると、色々と面倒なことを考えなくて済むのでとても良いですよ。&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-04-02-ml-day-1.html</id><title type="text">ML Day ＃1 に行ってきた</title><updated>2018-04-02T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-04-02-ml-day-1.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;ML Day ＃1 に行ってきた&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-04-02" itemprop="datePublished"&gt;
        Apr 2, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/event.html"&gt;event&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;&lt;a href="https://ml-lang.connpass.com/event/78199/"&gt;ML Day #1&lt;/a&gt; というイベントに参加してきたので，そのメモ？まとめ？みたいな感じの記事です．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;ML Day は毎年やってるML勉強会というML系の発表会形式の勉強会のこと． (なぜか)名前を変えたらしい． ちなみに，今後は半年に一回ペースでやりたいらしい．&lt;/p&gt;
&lt;h2 id="ぼくのはなし"&gt;ぼくのはなし&lt;/h2&gt;
&lt;p&gt;新設された LT 枠で発表してきた．&lt;/p&gt;
&lt;p&gt;スライドはこれ&lt;/p&gt;
&lt;iframe src="//www.slideshare.net/slideshow/embed_code/key/o84VhGTUREO4No" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen&gt;
&lt;/iframe&gt;
&lt;p&gt;さすがに Haskell の話をするのはアレだったので，Haskell の新しいモジュールシステム Backpack のベースになった MixML の話をした． この日までに(Haskellで)実装完了してドヤ顔する予定だったのだが全然終わらなかった orz (Alt braif*ck じゃなくて)ちゃんとした規模の処理系を実装するのって，大変なんですね…&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;ちなみに，&lt;a href="https://github.com/rossberg/mixml"&gt;SML/NJ で実装されたもの&lt;/a&gt;があり，実質これを参考に Haskell で書き直すだけの作業． だけど SML -&amp;gt; Haskell に直すのって大変，非純粋なものを純粋な世界にするって大変(そりゃそう)． 気軽に状態を持ちやがって…&lt;/p&gt;
&lt;h2 id="自分的ハイライト"&gt;自分的ハイライト&lt;/h2&gt;
&lt;p&gt;濃い目の話が多かったのでざっくりと．&lt;/p&gt;
&lt;p&gt;資料は既に&lt;a href="https://ml-lang.connpass.com/event/78199/presentation/"&gt;ほとんど上がっている&lt;/a&gt;．&lt;/p&gt;
&lt;h3 id="ml型付の基礎の基礎"&gt;ML型付の基礎の基礎&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者は &lt;a href="https://twitter.com/haochenxie"&gt;Haochen&lt;/a&gt; くん
&lt;ul&gt;
&lt;li&gt;名〇屋で &lt;a href="https://sicss.connpass.com/event/71199/"&gt;TaPL の読書会&lt;/a&gt;を主催してるひと&lt;/li&gt;
&lt;li&gt;こんど&lt;a href="https://nupsc.sicss.org/"&gt;名古屋でプロコン&lt;/a&gt;やるんだって&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://haochenxie.name/dl/the_introduction_of_foundation_of_ml_type_checking.pdf"&gt;資料はコレ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;基礎 (foundation) の 基礎 (introduction) の話
&lt;ol type="1"&gt;
&lt;li&gt;型は素晴らしい&lt;/li&gt;
&lt;li&gt;でも型を書きたくない
&lt;ul&gt;
&lt;li&gt;プログラマは怠惰を美徳にしている生き物だもんね&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;再構築すればいいじゃない！
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;型検査無しにもどるなんてのは論外&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;素晴らしい本(TaPL)と素晴らしい先生(ピアース先生)
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;ML Day 出る以上読め&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;おまけとして let 多相の話もしてた&lt;/li&gt;
&lt;li&gt;&lt;a href="https://sicss.connpass.com/event/83801/"&gt;5/6に論理プログラミング言語の第一人者の講演&lt;/a&gt;を企画しているらしい
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://readcoqart.connpass.com/event/83722/"&gt;Coq 勉強会&lt;/a&gt;と被ってるのがなぁぁぁぁ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="tba"&gt;TBA&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;発表者は&lt;a href="https://twitter.com/pi8027"&gt;坂口和彦&lt;/a&gt;さん
&lt;ul&gt;
&lt;li&gt;PPL2018 のポスター賞の人でその話を&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;発表スライドは上がってないけど &lt;a href="http://logic.cs.tsukuba.ac.jp/~sakaguchi/posters/ppl2018.pdf"&gt;PPL2018 のポスター&lt;/a&gt;はあった&lt;/li&gt;
&lt;li&gt;Coq でリストの置換(permutation)の自動証明(だったかな)
&lt;ul&gt;
&lt;li&gt;証明の過程をいろいろ話してくれた&lt;/li&gt;
&lt;li&gt;(がぼくはよくわかってない)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.sqlab.jp/FLOPS2018/"&gt;FLOPS’18&lt;/a&gt; に通ったので発表するらしい&lt;/li&gt;
&lt;li&gt;質問: 項書き換えでできないの？
&lt;ul&gt;
&lt;li&gt;中野先生に聞かれた(PPLで？？)&lt;/li&gt;
&lt;li&gt;出来たら教えてといって何もないのでできないんじゃない？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="型つき組版処理システムsatysfi"&gt;型つき組版処理システムSATySFi&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;発表者は &lt;a href="https://twitter.com/bd_gfngfn"&gt;bd_gfngfn&lt;/a&gt; 氏&lt;/li&gt;
&lt;li&gt;資料は&lt;a href="https://drive.google.com/file/d/1BB7ZAiwPO3hVtq7PGImPtMs1-kOd7SzW/view"&gt;コレ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;彼の有名な &lt;a href="https://github.com/gfngfn/SATySFi"&gt;型つき組版処理システムSATySFi&lt;/a&gt; の話
&lt;ul&gt;
&lt;li&gt;目標: L〇TeX を倒す&lt;/li&gt;
&lt;li&gt;目標: エラーの可読性向上(大事)&lt;/li&gt;
&lt;li&gt;ML系に似た組版用型システムが載っている
&lt;ul&gt;
&lt;li&gt;let 多相もレコード多相もある&lt;/li&gt;
&lt;li&gt;しかし GADT や Functor はまだ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「いきなり PDF がでまして」をよく言っていた(笑)&lt;br /&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;質問: 構文にポリシーはあるの？
&lt;ul&gt;
&lt;li&gt;ML系の文法にしたい(けど LaTeX に寄せたほうが…)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="mlでつくる拡張可能インタプリタ"&gt;MLでつくる拡張可能インタプリタ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;発表者は &lt;a href="https://twitter.com/linerlock"&gt;linerlock&lt;/a&gt; 氏
&lt;ul&gt;
&lt;li&gt;今日までつくば大生
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;これのせいで二番煎じに&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;資料は&lt;a href="https://speakerdeck.com/takahisa/extensible-interpreter-in-ml"&gt;コレ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;言語開発 &lt;strong&gt;も&lt;/strong&gt; モジュラーにしたいので拡張可能なインタプリタを作ればいいじゃない
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/takahisa/kennel"&gt;コレ&lt;/a&gt;のことかな？&lt;/li&gt;
&lt;li&gt;例えば超簡易的な自作言語に新しくリスト追加してと言われても簡単にできるように&lt;/li&gt;
&lt;li&gt;評価器は楽しいので(拡張可能な評価器の)研究が多い&lt;/li&gt;
&lt;li&gt;構文解析は無い…なのでここをサイボウズラボユースでやった(？)
&lt;ul&gt;
&lt;li&gt;構文解析の無い言語なんてないのにね&lt;/li&gt;
&lt;li&gt;作ったの&lt;a href="https://github.com/takahisa/finale"&gt;コレ&lt;/a&gt;かな？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「(BNFに新しい構文を)上に足すか下に足すか、花火じゃないけど」
&lt;ul&gt;
&lt;li&gt;上に足すか下に足すかで意味が変わることが…&lt;/li&gt;
&lt;li&gt;そこで最長一致法 : 全部試して一番長いのをとる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;型とか最適化とかできてない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="lt"&gt;LT&lt;/h3&gt;
&lt;p&gt;は割愛(つかれた)． ラインナップは&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自作言語を OCaml で作り直したら ML みたいなコア言語になってしまったという話&lt;/li&gt;
&lt;li&gt;Elm の紹介&lt;/li&gt;
&lt;li&gt;OCaml の祖先 CAML の解説&lt;/li&gt;
&lt;li&gt;自作したパーサージェネレーターの紹介&lt;/li&gt;
&lt;li&gt;Verifastの辛い話(&lt;del&gt;古いOCamlを使うのつらいという愚痴&lt;/del&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LT の資料は全部 connpass にあがっている．&lt;/p&gt;
&lt;h3 id="コンパイラバックエンド"&gt;コンパイラバックエンド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者は&lt;a href=""&gt;インターネットの闇&lt;/a&gt;さん
&lt;ul&gt;
&lt;li&gt;この会の主催者(？)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OCaml のソースコードを皆で読もうの会
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;バックエンドはコンパイラのコト&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;not Webバックエンド&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ガリグ先生しか読めない化け物(type系)&lt;/li&gt;
&lt;li&gt;OCaml のバックは副作用ガンガン使う、FPとは？GC付きのC&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="bucklescriptでノベルゲームdslを作る"&gt;BuckleScriptでノベルゲームDSLを作る&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者は[pocketberserker]氏
&lt;ul&gt;
&lt;li&gt;普段は F# の人&lt;/li&gt;
&lt;li&gt;F# ネタが切れた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;資料は&lt;a href="https://github.com/pocketberserker/ml_day_1"&gt;ココ&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;資料もこの DSL で書かれたもの(？？)&lt;/li&gt;
&lt;li&gt;ノベルゲーなのでバックができない(笑)&lt;/li&gt;
&lt;li&gt;発表者はデバッグモードで戻ってた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ノベルゲーDSLを作りたい遺伝子を持ってしまったので作るという話
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/cowlick/cowlick"&gt;つくったやつ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;自分が今書いてるのはS式なのか？？？？S式が分からなくなる&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;strong&gt;Reason を ML ユーザーが触るべきではない！&lt;/strong&gt;&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="感想"&gt;感想&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;濃い(誉め言葉)&lt;/li&gt;
&lt;li&gt;後半は疲れてしまった(ごめん)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;質問時間を含めて発表時間(律儀に終わる必要はない)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;MixML 完成させてリベンジ発表したい&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/03-31-quiz-5.html</id><title type="text">Haskell Quiz No.5 Conduit Part.1</title><updated>2018-03-31T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/03-31-quiz-5.html"/><summary type="html">&lt;h2 id="haskell-quiz-no.5"&gt;Haskell Quiz No.5&lt;/h2&gt;
&lt;p&gt;難易度: λλ&lt;/p&gt;
&lt;p&gt;以下の &lt;code&gt;Conduit&lt;/code&gt; を使ったコードの実行結果を予想してみてください！&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;span class="ot"&gt;sink ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitM&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; o m (&lt;span class="dt"&gt;String&lt;/span&gt;, &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;sink &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;  x &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; takeC &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="fu"&gt;.|&lt;/span&gt; mapC show &lt;span class="fu"&gt;.|&lt;/span&gt; foldC&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;  y &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; sumC&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;  return (x, y)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; res &lt;span class="fu"&gt;=&lt;/span&gt; runConduitPure &lt;span class="fu"&gt;$&lt;/span&gt; yieldMany [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="fu"&gt;.|&lt;/span&gt; sink&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" data-line-number="14"&gt;  print res&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;答えは&lt;a href="04-06-quiz-6.html"&gt;次回&lt;/a&gt;。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href="./03-28-quiz-4.html"&gt;前回&lt;/a&gt;の問題と答えは以下の通りです。&lt;/p&gt;
&lt;h3 id="問題"&gt;問題&lt;/h3&gt;
&lt;p&gt;難易度: λ&lt;/p&gt;
&lt;p&gt;今回は、与えられた値がリストのリストに含まれているかどうかを判定する問題です。&lt;/p&gt;
&lt;p&gt;幅優先で探索する関数 &lt;code&gt;bfs&lt;/code&gt; と深さ優先で探索する関数 &lt;code&gt;dfs&lt;/code&gt; をそれぞれ定義してみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;bfs ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [[&lt;span class="dt"&gt;Int&lt;/span&gt;]] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;bfs &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;span class="ot"&gt;dfs ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [[&lt;span class="dt"&gt;Int&lt;/span&gt;]] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;dfs &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実行結果はだいたいこんな感じです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;stack&lt;/span&gt; repl -- Quiz4.hs&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="ex"&gt;*Quiz4&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; xs = [[10..],[4,5,6],[7,8,9]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="ex"&gt;*Quiz4&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; bfs 9 xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;span class="ex"&gt;True&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;&lt;span class="ex"&gt;*Quiz4&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; dfs 9 xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;&lt;span class="ex"&gt;.....&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="こたえ"&gt;こたえ&lt;/h3&gt;
&lt;p&gt;素晴らしい回答が &lt;strong&gt;Haskeller&lt;/strong&gt; から届きました。(一部修正)&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;dfs x &lt;span class="fu"&gt;=&lt;/span&gt; elem x &lt;span class="fu"&gt;.&lt;/span&gt; concat&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;bfs x &lt;span class="fu"&gt;=&lt;/span&gt; elem x &lt;span class="fu"&gt;.&lt;/span&gt; concat &lt;span class="fu"&gt;.&lt;/span&gt; transpose&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;まさに &lt;code&gt;Haskell&lt;/code&gt; ！！！って感じのコードですよね。&lt;/p&gt;
&lt;h2 id="haskell-quiz-no.4-の解説"&gt;Haskell Quiz No.4 の解説&lt;/h2&gt;
&lt;p&gt;完全なコードはこちら&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Quiz4&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.List&lt;/span&gt; (transpose)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;&lt;span class="ot"&gt;dfs ::&lt;/span&gt; &lt;span class="dt"&gt;Eq&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [[a]] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" data-line-number="6"&gt;dfs x &lt;span class="fu"&gt;=&lt;/span&gt; elem x &lt;span class="fu"&gt;.&lt;/span&gt; concat&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-8" data-line-number="8"&gt;&lt;span class="ot"&gt;bfs ::&lt;/span&gt; &lt;span class="dt"&gt;Eq&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [[a]] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-9" data-line-number="9"&gt;bfs x &lt;span class="fu"&gt;=&lt;/span&gt; elem x &lt;span class="fu"&gt;.&lt;/span&gt; concat &lt;span class="fu"&gt;.&lt;/span&gt; transpose&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dfs&lt;/strong&gt; は &lt;code&gt;depth farst search&lt;/code&gt; なので、&lt;strong&gt;深さ優先探索&lt;/strong&gt;を行うように実装しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bfs&lt;/strong&gt; は &lt;code&gt;breadth first search&lt;/code&gt; なので、&lt;strong&gt;幅優先探索&lt;/strong&gt;を行うように実装しています。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="data.list-モジュール"&gt;Data.List モジュール&lt;/h3&gt;
&lt;p&gt;リスト操作系の関数は基本的に &lt;a href="http://hackage.haskell.org/package/base-4.11.0.0/docs/Data-List.html"&gt;Data.List&lt;/a&gt; を探せば見つかります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Prelude&lt;/code&gt; に含まれている関数と重複するものもありますが、それ以外にも有用な関数がいくつも定義されているため、 &lt;code&gt;Data.List&lt;/code&gt; モジュールにどんな関数があるか把握しておくと良いと思います。&lt;/p&gt;
&lt;p&gt;ここで定義されている関数の命名規則は別のパッケージでも慣習的に利用されていることが多いため、関数がどんな操作なのか&lt;strong&gt;理解&lt;/strong&gt; (暗記ではない) しておくと、全く知らないパッケージでも何となく読める時があります。&lt;/p&gt;
&lt;p&gt;例えば今回の &lt;code&gt;transpose&lt;/code&gt; 関数は &lt;code&gt;Data.List&lt;/code&gt; 以外にも色々なモジュールで同様に定義されています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Char8.html#v:transpose"&gt;ByteString&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hackage.haskell.org/package/text-1.2.3.0/docs/Data-Text-Lazy.html#v:transpose"&gt;Text&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;つまり、データ構造はリストとは違うけども、操作としては同じと言うことです。&lt;/p&gt;
&lt;h3 id="transpose"&gt;transpose&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://hackage.haskell.org/package/base-4.11.0.0/docs/Data-List.html#v:transpose"&gt;transpose&lt;/a&gt; は &lt;code&gt;base&lt;/code&gt; パッケージの &lt;code&gt;Data.List&lt;/code&gt; で定義されています。&lt;code&gt;Prelude&lt;/code&gt; には含まれていないため、明示的に &lt;code&gt;import&lt;/code&gt; する必要があります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;haddock&lt;/code&gt; の説明通り、リストを転置させる関数です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; transpose [[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;],[&lt;span class="dv"&gt;4&lt;/span&gt;,&lt;span class="dv"&gt;5&lt;/span&gt;,&lt;span class="dv"&gt;6&lt;/span&gt;]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;[[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;],[&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;5&lt;/span&gt;],[&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;6&lt;/span&gt;]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; transpose [[&lt;span class="dv"&gt;10&lt;/span&gt;,&lt;span class="dv"&gt;11&lt;/span&gt;],[&lt;span class="dv"&gt;20&lt;/span&gt;],[],[&lt;span class="dv"&gt;30&lt;/span&gt;,&lt;span class="dv"&gt;31&lt;/span&gt;,&lt;span class="dv"&gt;32&lt;/span&gt;]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;[[&lt;span class="dv"&gt;10&lt;/span&gt;,&lt;span class="dv"&gt;20&lt;/span&gt;,&lt;span class="dv"&gt;30&lt;/span&gt;],[&lt;span class="dv"&gt;11&lt;/span&gt;,&lt;span class="dv"&gt;31&lt;/span&gt;],[&lt;span class="dv"&gt;32&lt;/span&gt;]]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;その際、空リストは取り除かれるようですね。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;transpose&lt;/code&gt; 関数の実装は &lt;a href="http://hackage.haskell.org/package/base-4.11.0.0/docs/src/Data.OldList.html#transpose"&gt;Data.OldList&lt;/a&gt; で以下のように定義されています。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="ot"&gt;transpose ::&lt;/span&gt; [[a]] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [[a]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;transpose []           &lt;span class="fu"&gt;=&lt;/span&gt; []&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;transpose ([]&lt;span class="fu"&gt;:&lt;/span&gt;xss)     &lt;span class="fu"&gt;=&lt;/span&gt; transpose xss&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;transpose ((x&lt;span class="fu"&gt;:&lt;/span&gt;xs)&lt;span class="fu"&gt;:&lt;/span&gt;xss) &lt;span class="fu"&gt;=&lt;/span&gt; (x &lt;span class="fu"&gt;:&lt;/span&gt; [h &lt;span class="fu"&gt;|&lt;/span&gt; (h&lt;span class="fu"&gt;:&lt;/span&gt;_) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; xss]) &lt;span class="fu"&gt;:&lt;/span&gt; transpose (xs &lt;span class="fu"&gt;:&lt;/span&gt; [ t &lt;span class="fu"&gt;|&lt;/span&gt; (_&lt;span class="fu"&gt;:&lt;/span&gt;t) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; xss])&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;たしかに2つ目の等式で空白が除去されていることがわかりますね。&lt;/p&gt;
&lt;p&gt;3つ目の等式は少し複雑ですが、面白いので見てみましょう。&lt;/p&gt;
&lt;p&gt;それぞれのリストの &lt;code&gt;head&lt;/code&gt; を取りたいので &lt;code&gt;map head xss&lt;/code&gt; がすぐに思いつきそうですが &lt;code&gt;[h | (h:_) &amp;lt;- xss]&lt;/code&gt; となっています。うまいやりかたですね。&lt;/p&gt;
&lt;p&gt;普通に &lt;code&gt;head&lt;/code&gt; をかけてしまうと空リストで実行時エラーとなってしまいます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz4&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; xss &lt;span class="fu"&gt;=&lt;/span&gt; [[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;],[],[&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz4&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; map head xss&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="fu"&gt;***&lt;/span&gt; &lt;span class="dt"&gt;Exception&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; Prelude.head&lt;span class="fu"&gt;:&lt;/span&gt; empty list&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;しかし &lt;code&gt;[h | (h:_) &amp;lt;- xss]&lt;/code&gt; ではどうでしょうか？&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz4&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; xss &lt;span class="fu"&gt;=&lt;/span&gt; [[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;],[],[&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz4&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; [h &lt;span class="fu"&gt;|&lt;/span&gt; (h&lt;span class="fu"&gt;:&lt;/span&gt;_) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; xss]&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;はい。空リストを含んでいたとしてもエラーにならずに、良い感じに先頭の要素から成るリストが生成できました。&lt;/p&gt;
&lt;p&gt;では、なぜこのような動作になるのでしょうか？&lt;/p&gt;
&lt;p&gt;それを理解するためには &lt;strong&gt;Haskell 2010 Language Report&lt;/strong&gt; の &lt;a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11"&gt;3.11 List Comprehensions&lt;/a&gt; を参照する必要があります。&lt;/p&gt;
&lt;p&gt;ここにリスト内包表記がどのように変換されるか、変換規則が載っています。(ここでは一部のみ掲載)&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="co"&gt;-- ルール1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;[ e &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;True&lt;/span&gt; ] &lt;span class="fu"&gt;=&lt;/span&gt; [e]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;span class="co"&gt;-- ルール2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;[ e &lt;span class="fu"&gt;|&lt;/span&gt; q ] &lt;span class="fu"&gt;=&lt;/span&gt; [ e &lt;span class="fu"&gt;|&lt;/span&gt; q, &lt;span class="dt"&gt;True&lt;/span&gt; ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;&lt;span class="co"&gt;-- ルール3&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;[ e &lt;span class="fu"&gt;|&lt;/span&gt; p &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; l, &lt;span class="dt"&gt;Q&lt;/span&gt; ] &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;let&lt;/span&gt; ok p &lt;span class="fu"&gt;=&lt;/span&gt; [ e &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Q&lt;/span&gt; ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;                        ok _ &lt;span class="fu"&gt;=&lt;/span&gt; []&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" data-line-number="10"&gt;                    &lt;span class="kw"&gt;in&lt;/span&gt; concatMap ok l&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記の規則により、先程の &lt;code&gt;[h | (h:_) &amp;lt;- xss]&lt;/code&gt; は以下のように変換できます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;[ h &lt;span class="fu"&gt;|&lt;/span&gt; (h&lt;span class="fu"&gt;:&lt;/span&gt;_) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; xss ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; { ルール2 より }&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;[ h &lt;span class="fu"&gt;|&lt;/span&gt; (h&lt;span class="fu"&gt;:&lt;/span&gt;_) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; xss, &lt;span class="dt"&gt;True&lt;/span&gt; ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; { ルール3 より }&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;&lt;span class="kw"&gt;let&lt;/span&gt; ok (h&lt;span class="fu"&gt;:&lt;/span&gt;_) &lt;span class="fu"&gt;=&lt;/span&gt; [ h &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;True&lt;/span&gt; ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" data-line-number="6"&gt;    ok _ &lt;span class="fu"&gt;=&lt;/span&gt; []&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-7" data-line-number="7"&gt;&lt;span class="kw"&gt;in&lt;/span&gt; concatMap ok xss&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-8" data-line-number="8"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; { ルール1 より }&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-9" data-line-number="9"&gt;&lt;span class="kw"&gt;let&lt;/span&gt; ok (h&lt;span class="fu"&gt;:&lt;/span&gt;_) &lt;span class="fu"&gt;=&lt;/span&gt; [h]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-10" data-line-number="10"&gt;    ok _ &lt;span class="fu"&gt;=&lt;/span&gt; []&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-11" data-line-number="11"&gt;&lt;span class="kw"&gt;in&lt;/span&gt; concatMap ok xss&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最終的には &lt;code&gt;f = [h | (h:_) &amp;lt;- xss]&lt;/code&gt; とすると&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;f &lt;span class="fu"&gt;=&lt;/span&gt; concatMap ok xss&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;    ok (h&lt;span class="fu"&gt;:&lt;/span&gt;_) &lt;span class="fu"&gt;=&lt;/span&gt; [h]&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;    ok _     &lt;span class="fu"&gt;=&lt;/span&gt; []&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;になります。&lt;/p&gt;
&lt;p&gt;パターンマッチに失敗した場合は &lt;code&gt;ok _ = []&lt;/code&gt; ということで自動的に空リストになるという部分が実行時エラーにならない秘密のようですね。&lt;/p&gt;
&lt;p&gt;最終的に &lt;code&gt;concatMap&lt;/code&gt; によって、空リストが自然に除去されていることがわかります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz4&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; concatMap ok [[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;], [], [&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ということで、もとの式に戻ると &lt;code&gt;transpose&lt;/code&gt; 関数の主張はこういうことです。&lt;/p&gt;
&lt;figure&gt;
&lt;img src="/images/2018/03-31/transpose.png" alt="transpose 関数の処理" /&gt;&lt;figcaption&gt;transpose 関数の処理&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;transpose []           &lt;span class="fu"&gt;=&lt;/span&gt; []&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;transpose ([]&lt;span class="fu"&gt;:&lt;/span&gt;xss)     &lt;span class="fu"&gt;=&lt;/span&gt; transpose xss&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;transpose ((x&lt;span class="fu"&gt;:&lt;/span&gt;xs)&lt;span class="fu"&gt;:&lt;/span&gt;xss) &lt;span class="fu"&gt;=&lt;/span&gt; (x &lt;span class="fu"&gt;:&lt;/span&gt; [h &lt;span class="fu"&gt;|&lt;/span&gt; (h&lt;span class="fu"&gt;:&lt;/span&gt;_) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; xss]) &lt;span class="fu"&gt;:&lt;/span&gt; transpose (xs &lt;span class="fu"&gt;:&lt;/span&gt; [ t &lt;span class="fu"&gt;|&lt;/span&gt; (_&lt;span class="fu"&gt;:&lt;/span&gt;t) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; xss])&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="幅優先探索と深さ優先探索"&gt;幅優先探索と深さ優先探索&lt;/h3&gt;
&lt;p&gt;アルゴリズムの本などを読むと、必ずこの &lt;strong&gt;幅優先探索&lt;/strong&gt; と &lt;strong&gt;深さ優先探索&lt;/strong&gt; というキーワードを目にすると思います。(また、同時に説明に利用されるのは木構造のデータでしょう)&lt;/p&gt;
&lt;p&gt;幅優先探索と深さ優先探索の概念を理解するために木構造に触れる必要は無く、リストだけで十分です。&lt;/p&gt;
&lt;p&gt;本質は以下のように凄く簡単なことです。&lt;/p&gt;
&lt;figure&gt;
&lt;img src="/images/2018/03-31/search.png" alt="リストを使った幅優先探索と深さ優先探索" /&gt;&lt;figcaption&gt;リストを使った幅優先探索と深さ優先探索&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;そのため &lt;code&gt;[10..]&lt;/code&gt; のような無限リストが与えられた場合に &lt;strong&gt;深さ優先探索&lt;/strong&gt; では結果を返すことができないのです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;stack&lt;/span&gt; repl -- Quiz4.hs&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;&lt;span class="ex"&gt;*Quiz4&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; xs = [[10..],[4,5,6],[7,8,9]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;&lt;span class="ex"&gt;*Quiz4&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; bfs 9 xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;&lt;span class="ex"&gt;True&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;&lt;span class="ex"&gt;*Quiz4&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; dfs 9 xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;&lt;span class="ex"&gt;.....&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="コードの解説"&gt;コードの解説&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;dfs&lt;/code&gt; は &lt;code&gt;concat&lt;/code&gt; によってリストのリストを直列につないだ結果に対して &lt;code&gt;elem x&lt;/code&gt; で要素を検索すれば良いということになります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="ot"&gt;dfs ::&lt;/span&gt; &lt;span class="dt"&gt;Eq&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [[a]] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;dfs x &lt;span class="fu"&gt;=&lt;/span&gt; elem x &lt;span class="fu"&gt;.&lt;/span&gt; concat&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;それに対して &lt;code&gt;bfs&lt;/code&gt; は各リストの先頭要素だけを先に処理していく必要があります。自分でその辺りの処理を書いても良いのですが &lt;code&gt;transpose&lt;/code&gt; で一発です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" data-line-number="1"&gt;&lt;span class="ot"&gt;bfs ::&lt;/span&gt; &lt;span class="dt"&gt;Eq&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [[a]] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-2" data-line-number="2"&gt;bfs x &lt;span class="fu"&gt;=&lt;/span&gt; elem x &lt;span class="fu"&gt;.&lt;/span&gt; concat &lt;span class="fu"&gt;.&lt;/span&gt; transpose&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;bfs&lt;/code&gt; はこのように書くこともできます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb18-1" data-line-number="1"&gt;&lt;span class="ot"&gt;bfs ::&lt;/span&gt; &lt;span class="dt"&gt;Eq&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [[a]] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-2" data-line-number="2"&gt;bfs x &lt;span class="fu"&gt;=&lt;/span&gt; dfs x &lt;span class="fu"&gt;.&lt;/span&gt; transpose&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;つまり、リストのリストのようなデータ構造に対して幅優先探索を行うということは、リストを転置した結果に対して深さ優先探索を行うことと等しいということです。&lt;/p&gt;
&lt;figure&gt;
&lt;img src="/images/2018/03-31/bfs.png" alt="bfs と dfs の関係" /&gt;&lt;figcaption&gt;bfs と dfs の関係&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;p&gt;Haskell 2010 Language Report ってどういう時に利用するんだろう？って思っている人もいるとは思いますが、こういう場合に参照すると便利です。&lt;/p&gt;
&lt;p&gt;今回は幅優先探索と深さ優先探索を &lt;strong&gt;リストのリスト&lt;/strong&gt; で説明しましたが、一般的に説明される木構造では、これが少し複雑になっただけです。&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/03-30-prettyprinter.html</id><title type="text">prettyprinter パッケージ</title><updated>2018-03-30T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/03-30-prettyprinter.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;今回は &lt;a href="https://www.stackage.org/package/prettyprinter"&gt;prettyprinter&lt;/a&gt; を使ってみました。&lt;/p&gt;
&lt;p&gt;使おうと思ったモチベーションとしては、以下のようなデータ型をデバッグ表示させる際に &lt;code&gt;prettyprinter&lt;/code&gt; 系パッケージを使って良い感じに表示してみようかな？という感じです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表示をカスタマイズするために &lt;code&gt;Show&lt;/code&gt; クラスのインスタンスを書き換えることは、経験上嫌なことしか起きないです・・。&lt;/p&gt;
&lt;p&gt;自分でそれっぽい型クラスを作っても良いのですが、普通は素直に &lt;code&gt;prettyprinter&lt;/code&gt; 系のパッケージを使った方が良いと思います！&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;stack&lt;/span&gt; repl --package text&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="ex"&gt;Prelude&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; import Data.Text&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="ex"&gt;Prelude&lt;/span&gt; Data.Text&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; data Person = Person Text String deriving Show&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;span class="ex"&gt;Prelude&lt;/span&gt; Data.Text&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; :set -XOverloadedStrings&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="ex"&gt;Prelude&lt;/span&gt; Data.Text&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; Person &lt;span class="st"&gt;&amp;quot;はすける&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;らむだ&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;&lt;span class="ex"&gt;Person&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\12399\12377\12369\12427&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\12425\12416\12384&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;!--more--&gt;
&lt;h2 id="パッケージの選定理由"&gt;パッケージの選定理由&lt;/h2&gt;
&lt;p&gt;ぐぐって一番始めに出てきたのは &lt;a href="https://github.com/haskell/pretty"&gt;pretty&lt;/a&gt; というパッケージだったんですが &lt;code&gt;String&lt;/code&gt; にしか対応してない感じだったので見送りました。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;prettyprinter&lt;/code&gt; は &lt;strong&gt;A modern, easy to use, well-documented, extensible prettyprinter.&lt;/strong&gt; というコメント通り、とても使いやすいです。&lt;/p&gt;
&lt;h2 id="使ってみました"&gt;使ってみました&lt;/h2&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack --resolver lts-11.2 script&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Main&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Text.Prettyprint.Doc&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Text.Prettyprint.Doc.Render.Text&lt;/span&gt; (putDoc)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Text&lt;/span&gt; (&lt;span class="dt"&gt;Text&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" data-line-number="11"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;A&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;A&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-12" data-line-number="12"&gt;  &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-14" data-line-number="14"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;B&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;B&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-16" data-line-number="16"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Pretty&lt;/span&gt; &lt;span class="dt"&gt;B&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-17" data-line-number="17"&gt;  pretty (&lt;span class="dt"&gt;B&lt;/span&gt; l r) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;B&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;+&amp;gt;&lt;/span&gt; pretty l &lt;span class="fu"&gt;&amp;lt;+&amp;gt;&lt;/span&gt; pretty r&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-18" data-line-number="18"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-19" data-line-number="19"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-20" data-line-number="20"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-21" data-line-number="21"&gt;  print &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;A&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;あ&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-22" data-line-number="22"&gt;  putDoc &lt;span class="fu"&gt;$&lt;/span&gt; pretty &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;B&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;あ&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-23" data-line-number="23"&gt;  putStrLn &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;$ &lt;span class="fu"&gt;chmod&lt;/span&gt; u+x Pretty.hs&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;$ &lt;span class="ex"&gt;./Pretty.hs&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="ex"&gt;A&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\12354&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;span class="ex"&gt;B&lt;/span&gt; あ a&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#t:Pretty"&gt;Pretty&lt;/a&gt; 型クラスのインスタンスを普通に定義するだけです。&lt;/p&gt;
&lt;p&gt;適当に改行したい場合は &lt;a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#v:line"&gt;line&lt;/a&gt; を追加するだけです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Pretty&lt;/span&gt; &lt;span class="dt"&gt;B&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;  pretty (&lt;span class="dt"&gt;B&lt;/span&gt; l r) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;B&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; line&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;                &lt;span class="fu"&gt;&amp;lt;+&amp;gt;&lt;/span&gt; pretty l &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; line&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;                &lt;span class="fu"&gt;&amp;lt;+&amp;gt;&lt;/span&gt; pretty r&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;./test.hs&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="ex"&gt;A&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\12354&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;span class="ex"&gt;B&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt; あ&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt; &lt;span class="ex"&gt;a&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;区切りの空白が不要な場合は &lt;a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#v:-60--43--62-"&gt;&amp;lt;+&amp;gt;&lt;/a&gt; を &lt;a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#v:-60--62-"&gt;&amp;lt;&amp;gt;&lt;/a&gt; にするだけです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Pretty&lt;/span&gt; &lt;span class="dt"&gt;B&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;  pretty (&lt;span class="dt"&gt;B&lt;/span&gt; l r) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;B&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; line&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;                &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; pretty l &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; line&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;                &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; pretty r&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;./test.hs&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="ex"&gt;A&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\12354&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;&lt;span class="ex"&gt;B&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;あ&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;&lt;span class="ex"&gt;a&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;適当にネストさせたい場合も簡単です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Pretty&lt;/span&gt; &lt;span class="dt"&gt;B&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;  pretty (&lt;span class="dt"&gt;B&lt;/span&gt; l r) &lt;span class="fu"&gt;=&lt;/span&gt; nest &lt;span class="dv"&gt;4&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;B&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; line&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;                &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; pretty l &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; line&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;                &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; pretty r)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;./test.hs&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;span class="ex"&gt;A&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\12354&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;span class="ex"&gt;B&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;    あ&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;    &lt;span class="ex"&gt;a&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;p&gt;めちゃめちゃ簡単だったので、使ってみると楽しいですよー。ドキュメントが充実しているのが良いですね。&lt;/p&gt;
&lt;p&gt;今回は短めでした。&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/03-28-quiz-4.html</id><title type="text">Haskell Quiz No.4 幅優先探索と深さ優先探索</title><updated>2018-03-28T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/03-28-quiz-4.html"/><summary type="html">&lt;h2 id="haskell-quiz-no.4"&gt;Haskell Quiz No.4&lt;/h2&gt;
&lt;p&gt;難易度: λ&lt;/p&gt;
&lt;p&gt;今回は、与えられた値がリストのリストに含まれているかどうかを判定する問題です。&lt;/p&gt;
&lt;p&gt;幅優先で探索する関数 &lt;code&gt;bfs&lt;/code&gt; と深さ優先で探索する関数 &lt;code&gt;dfs&lt;/code&gt; をそれぞれ定義してみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;bfs ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [[&lt;span class="dt"&gt;Int&lt;/span&gt;]] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;bfs &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;span class="ot"&gt;dfs ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [[&lt;span class="dt"&gt;Int&lt;/span&gt;]] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;dfs &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実行結果はだいたいこんな感じです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;stack&lt;/span&gt; repl -- Quiz4.hs&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="ex"&gt;*Quiz4&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; xs = [[10..],[4,5,6],[7,8,9]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="ex"&gt;*Quiz4&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; bfs 9 xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;span class="ex"&gt;True&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="ex"&gt;*Quiz4&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; dfs 9 xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;&lt;span class="ex"&gt;.....&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;答えは&lt;a href="03-31-quiz-5.html"&gt;次回&lt;/a&gt;。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href="./03-27-quiz-3.html"&gt;前回&lt;/a&gt;の問題と答えは以下の通りです。&lt;/p&gt;
&lt;h3 id="問題"&gt;問題&lt;/h3&gt;
&lt;p&gt;難易度: λ&lt;/p&gt;
&lt;p&gt;&lt;code&gt;propIsDigit&lt;/code&gt; テストをパスするように &lt;code&gt;Digit&lt;/code&gt; 型の &lt;code&gt;Arbitrary&lt;/code&gt; インスタンスを定義してみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Quiz3&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Test.QuickCheck&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Char&lt;/span&gt; (isDigit)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Digit&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Digit&lt;/span&gt; &lt;span class="dt"&gt;Char&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;  &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;&lt;span class="ot"&gt;propIsDigit ::&lt;/span&gt; &lt;span class="dt"&gt;Digit&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;propIsDigit (&lt;span class="dt"&gt;Digit&lt;/span&gt; c) &lt;span class="fu"&gt;=&lt;/span&gt; isDigit c&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-12" data-line-number="12"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Arbitrary&lt;/span&gt; &lt;span class="dt"&gt;Digit&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-13" data-line-number="13"&gt;  arbitrary &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;テストは以下のように実行します。&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;stack&lt;/span&gt; repl --package QuickCheck -- Quiz3.hs&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;span class="ex"&gt;*Quiz3&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; quickCheck propIsDigit&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="ex"&gt;+++&lt;/span&gt; OK, passed 100 tests.&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="こたえ"&gt;こたえ&lt;/h3&gt;
&lt;p&gt;実装方法はいくつかあるのですが、例えば &lt;a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#v:elements"&gt;elements&lt;/a&gt; を使う方法だとこんな感じです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Arbitrary&lt;/span&gt; &lt;span class="dt"&gt;Digit&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;  arbitrary &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Digit&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; elements &lt;span class="st"&gt;&amp;quot;1234567890&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ちょっと反則っぽいですが &lt;a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#v:suchThat"&gt;suchThat&lt;/a&gt; を使う方法もありそうですね。&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Arbitrary&lt;/span&gt; &lt;span class="dt"&gt;Digit&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;  arbitrary &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Digit&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; arbitrary &lt;span class="ot"&gt;`suchThat`&lt;/span&gt; isDigit&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こんな方法もあるよーと言う方は教えてください！&lt;/p&gt;
&lt;h2 id="haskell-quiz-no.3-の解説"&gt;Haskell Quiz No.3 の解説&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;QuickCheck&lt;/code&gt; を使っている人にとっては簡単な問題だったと思います。&lt;/p&gt;
&lt;p&gt;逆に全く使ったこと無い人にとっては、結構難しかったのではないでしょうか。&lt;/p&gt;
&lt;h3 id="arbitrary-型クラス"&gt;Arbitrary 型クラス&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#t:Arbitrary"&gt;Arbitrary&lt;/a&gt; 型クラスは &lt;a href="https://www.stackage.org/lts-11.2/package/QuickCheck-2.10.1"&gt;QuickCheck&lt;/a&gt; パッケージの &lt;a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck-Arbitrary.html#t:Arbitrary"&gt;Test.QuickCheck.Arbitrary&lt;/a&gt; で定義されています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Minimal complete definition&lt;/code&gt; は &lt;code&gt;arbitrary&lt;/code&gt; メソッド (関数) です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Minimal complete definition&lt;/code&gt; とは、型クラスのインスタンスを全て実装しなくても &lt;code&gt;Minimal complete definition&lt;/code&gt; だけ実装すれば全てのメソッドが (デフォルト実装で) 利用できるというものです。効率が悪い場合もあるので、その場合は自分で定義を上書きします。&lt;/p&gt;
&lt;p&gt;つまり、今回の場合だと &lt;code&gt;arbitrary&lt;/code&gt; メソッドさえ定義してしまえば &lt;a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck-Arbitrary.html#v:shrink"&gt;shrink&lt;/a&gt; メソッドも同様に利用可能になるということです。&lt;/p&gt;
&lt;p&gt;実際の定義は以下の通りです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Arbitrary&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  arbitrary ::&lt;/span&gt; &lt;span class="dt"&gt;Gen&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;&lt;span class="ot"&gt;  shrink ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;  shrink _ &lt;span class="fu"&gt;=&lt;/span&gt; []&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="arbitrary-メソッド"&gt;arbitrary メソッド&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;arbitrary&lt;/code&gt; の型は &lt;code&gt;Arbitrary a =&amp;gt; Gen a&lt;/code&gt; なので、最初はどうやって定義して良いのか困惑してしまうかもしれません。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gen a&lt;/code&gt; はランダムな値を生成するジェネレータを意味する型です。&lt;/p&gt;
&lt;p&gt;定義の方法は本当に色々ありますが、まずは基本のユーティリティ関数を抑えておきましょう。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#g:6"&gt;Generator combinators&lt;/a&gt; に列挙されている関数の一部をご紹介します。&lt;/p&gt;
&lt;h4 id="elements"&gt;elements&lt;/h4&gt;
&lt;p&gt;与えられたリストの値を元に &lt;code&gt;Gen a&lt;/code&gt; を作ります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t elements&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="ot"&gt;elements ::&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Gen&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; sample&amp;#39; &lt;span class="fu"&gt;$&lt;/span&gt; elements &lt;span class="st"&gt;&amp;quot;1234567890&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;&lt;span class="st"&gt;&amp;quot;55316502254&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;今回の問題もこれを使って &lt;code&gt;isDigit&lt;/code&gt; に通る値のみをリストに含めてあげたら良いのです。&lt;/p&gt;
&lt;h4 id="choose"&gt;choose&lt;/h4&gt;
&lt;p&gt;タプルで指定した範囲で値を生成します。その際 &lt;code&gt;Random&lt;/code&gt; 型クラスのクラス制約が発生することに注意してください。&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t choose&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;&lt;span class="ot"&gt;choose ::&lt;/span&gt; random&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;1.1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;&lt;span class="dt"&gt;System.Random.Random&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (a, a) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Gen&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; sample&amp;#39; &lt;span class="fu"&gt;$&lt;/span&gt; choose (&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;10&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;[&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;7&lt;/span&gt;,&lt;span class="dv"&gt;5&lt;/span&gt;,&lt;span class="dv"&gt;9&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;,&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="oneof"&gt;oneof&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;oneof&lt;/code&gt; は &lt;code&gt;[Gen a]&lt;/code&gt; からランダムに1つ &lt;code&gt;Gen a&lt;/code&gt; を選びます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t oneof&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;span class="ot"&gt;oneof ::&lt;/span&gt; [&lt;span class="dt"&gt;Gen&lt;/span&gt; a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Gen&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; sample&amp;#39; &lt;span class="fu"&gt;$&lt;/span&gt; oneof [choose (&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;)]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;[&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; sample&amp;#39; &lt;span class="fu"&gt;$&lt;/span&gt; oneof [choose (&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;), choose (&lt;span class="dv"&gt;10&lt;/span&gt;,&lt;span class="dv"&gt;30&lt;/span&gt;)]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;[&lt;span class="dv"&gt;18&lt;/span&gt;,&lt;span class="dv"&gt;26&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;17&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;25&lt;/span&gt;,&lt;span class="dv"&gt;13&lt;/span&gt;,&lt;span class="dv"&gt;25&lt;/span&gt;,&lt;span class="dv"&gt;16&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="frequency"&gt;frequency&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;oneof&lt;/code&gt; と似ていますが、完全にランダムではなく頻出度合いを制御することができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t frequency&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;&lt;span class="ot"&gt;frequency ::&lt;/span&gt; [(&lt;span class="dt"&gt;Int&lt;/span&gt;, &lt;span class="dt"&gt;Gen&lt;/span&gt; a)] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Gen&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; sample&amp;#39; &lt;span class="fu"&gt;$&lt;/span&gt; frequency  [(&lt;span class="dv"&gt;1&lt;/span&gt;,choose (&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;)), (&lt;span class="dv"&gt;100&lt;/span&gt;,choose (&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;))]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-7" data-line-number="7"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; sample&amp;#39; &lt;span class="fu"&gt;$&lt;/span&gt; frequency  [(&lt;span class="dv"&gt;30&lt;/span&gt;,choose (&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;)), (&lt;span class="dv"&gt;70&lt;/span&gt;,choose (&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;))]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-8" data-line-number="8"&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="suchthat"&gt;suchThat&lt;/h4&gt;
&lt;p&gt;第二引数の述語を満たす値だけで &lt;code&gt;Gen a&lt;/code&gt; を作ります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t suchThat&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;&lt;span class="ot"&gt;suchThat ::&lt;/span&gt; &lt;span class="dt"&gt;Gen&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Gen&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; sample&amp;#39; &lt;span class="fu"&gt;$&lt;/span&gt; suchThat arbitrary even&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" data-line-number="5"&gt;[&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;8&lt;/span&gt;,&lt;span class="dv"&gt;10&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;22&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" data-line-number="7"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; sample&amp;#39; &lt;span class="fu"&gt;$&lt;/span&gt; suchThat arbitrary odd&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-8" data-line-number="8"&gt;[&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;5&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;5&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;11&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;9&lt;/span&gt;,&lt;span class="dv"&gt;7&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;11&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;13&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="vectorof"&gt;vectorOf&lt;/h4&gt;
&lt;p&gt;与えられた長さの &lt;code&gt;[Gen a]&lt;/code&gt; を作ります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t vectorOf&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;&lt;span class="ot"&gt;vectorOf ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Gen&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Gen&lt;/span&gt; [a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Quiz3&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; sample&amp;#39; &lt;span class="fu"&gt;$&lt;/span&gt; vectorOf &lt;span class="dv"&gt;2&lt;/span&gt; (&lt;span class="ot"&gt;arbitrary ::&lt;/span&gt; &lt;span class="dt"&gt;Gen&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;[[&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;],[&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt;],[&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;],[&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt;],[&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;5&lt;/span&gt;],[&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;8&lt;/span&gt;],[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;],[&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;12&lt;/span&gt;,&lt;span class="dv"&gt;9&lt;/span&gt;],[&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;5&lt;/span&gt;],[&lt;span class="dv"&gt;13&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;],[&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;8&lt;/span&gt;,&lt;span class="dv"&gt;12&lt;/span&gt;]]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="shrink-メソッド"&gt;shrink メソッド&lt;/h3&gt;
&lt;p&gt;参考: &lt;a href="https://stackoverflow.com/questions/16968549/what-is-a-shrink-with-regard-to-haskells-quickcheck/16970029"&gt;What is a shrink, with regard to Haskell’s QuickCheck?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shrink&lt;/code&gt; はテストに失敗した際にできるだけ小さな反例を返すために利用されるようです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#v:verboseCheck"&gt;verboseCheck&lt;/a&gt; 関数を使えば、実際に生成されたテストケースと結果を全てみることができます。&lt;/p&gt;
&lt;p&gt;例として &lt;code&gt;5&lt;/code&gt; を含まないリストという &lt;code&gt;prop&lt;/code&gt; でチェックしてみましょう。(結果は少し見やすいように整形してあります)&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="ex"&gt;prop&lt;/span&gt; l = all (/= 5) &lt;span class="ex"&gt;l&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="ex"&gt;verboseCheck&lt;/span&gt; prop&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" data-line-number="4"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-5" data-line-number="5"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[1,2]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-6" data-line-number="6"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[2,2]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-7" data-line-number="7"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[-1,1,2]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-8" data-line-number="8"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[3,-1]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-9" data-line-number="9"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[-4,-4,-5,3,-4]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-10" data-line-number="10"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[-6,1,4,-6,-5]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-11" data-line-number="11"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[4]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-12" data-line-number="12"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[2,-2]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-13" data-line-number="13"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[2,8,7]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-14" data-line-number="14"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[-7,-8,7,6,9,-10,1]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-15" data-line-number="15"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[-10,11,2]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-16" data-line-number="16"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[12,0,3,-12,7,-13,-6,9,-8,7,-10,9]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-17" data-line-number="17"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[4,4,-11,3,-7]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-18" data-line-number="18"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[2,1,-9]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-19" data-line-number="19"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[16,3,-8,14,-7,-7,9,-3,-15,3,-10,-14,9,-8,-3]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-20" data-line-number="20"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[-2,0,-6,0,4,8,17,13]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-21" data-line-number="21"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[1,15,17]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-22" data-line-number="22"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[9,-17,-15,-16,-18,16,-19,15]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-23" data-line-number="23"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[0,10,6,8,0,4,-9,-12,20,0,3,1,-2,14,13,-11]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-24" data-line-number="24"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[16,-5,-21,2,2,-6,6]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-25" data-line-number="25"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[-22,14,10,-18,-22,-10,8,8,-14,12,-22]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-26" data-line-number="26"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[-18,18,0,-1,-16,-4,13,0,11,-20,10,11,0,-9]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-27" data-line-number="27"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[-9,22,-2,-18,-9,-4,21,-7,0,9,-11]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-28" data-line-number="28"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[9,21,11,-17,8,-10,0,6,16,17,6,-16,10,24,-7,9,-1,11,-14,-22,-1,-5,2,11,12]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-29" data-line-number="29"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[-9,-21,25,-11,9,-11,-14,16,-9,-17,-8,9,4,-10,-6,-6,-17,-21,-26,-12]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-30" data-line-number="30"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[-8,-11,-21,3,4,13,27,-24,-13,-12,-21,-13,-25,10]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-31" data-line-number="31"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-32" data-line-number="32"&gt;&lt;span class="ex"&gt;Failed&lt;/span&gt;:[25,10,-17,27,8,17,5,14,-1,22,-13,13,-9,-23,26,16,0,10]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成されるリストがどんどん大きくなり、やっとリストに &lt;code&gt;5&lt;/code&gt; を含む反例 &lt;code&gt;[25,10,-17,27,8,17,5,14,-1,22,-13,13,-9,-23,26,16,0,10]&lt;/code&gt; を見つけました。この反例をそのまま返しても良いのですが、もしかしたらもっと小さな反例が見つかるかもしれません。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;verboseCheck&lt;/code&gt; は実際にさきほどの反例を、今度は逆に減らしてテストしていきます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="ex"&gt;***&lt;/span&gt; Failed!&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[22,-13,13,-9,-23,26,16,0,10]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;&lt;span class="ex"&gt;Failed&lt;/span&gt;:[25,10,-17,27,8,17,5,14,-1]   -- より小さい反例が見つかった&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;&lt;span class="ex"&gt;Failed&lt;/span&gt;:[8,17,5,14,-1]                -- より小さい反例が見つかった&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;&lt;span class="ex"&gt;Failed&lt;/span&gt;:[5,14,-1]                     -- より小さい反例が見つかった&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-10" data-line-number="10"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[14,-1]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-11" data-line-number="11"&gt;&lt;span class="ex"&gt;Failed&lt;/span&gt;:[5,-1]                        -- より小さい反例が見つかった&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-12" data-line-number="12"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-13" data-line-number="13"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[-1]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-14" data-line-number="14"&gt;&lt;span class="ex"&gt;Failed&lt;/span&gt;:[5]                           -- 最小の反例が見つかった&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-15" data-line-number="15"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-16" data-line-number="16"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[0]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-17" data-line-number="17"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[3]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-18" data-line-number="18"&gt;&lt;span class="ex"&gt;Passed&lt;/span&gt;:[4]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-19" data-line-number="19"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-20" data-line-number="20"&gt;&lt;span class="ex"&gt;Falsifiable&lt;/span&gt; (after 29 tests and 5 shrinks)&lt;span class="bu"&gt;:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-21" data-line-number="21"&gt;[&lt;span class="ex"&gt;5&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ということで &lt;code&gt;Falsifiable (after 29 tests and 5 shrinks): [5]&lt;/code&gt; は &lt;strong&gt;テストの29回目に反例が見つかりました。さらにその反例を5回小さくしたよ&lt;/strong&gt; という意味になります。&lt;/p&gt;
&lt;p&gt;デフォルト実装では &lt;code&gt;shrink _ = []&lt;/code&gt; となっていたので、見つかった反例をそのまま返すようですね。(&lt;a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#v:shrink"&gt;haddock&lt;/a&gt; を見るともっと詳しく書いてあるので、気になる方はそちらをご参照ください)&lt;/p&gt;
&lt;h2 id="quickcheck-instances-パッケージ"&gt;quickcheck-instances パッケージ&lt;/h2&gt;
&lt;p&gt;ここまでで &lt;code&gt;QuickCheck&lt;/code&gt; がどんなものか何となくわかってもらえたと思います。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;base&lt;/code&gt; パッケージで提供されている型については、ほとんどデフォルトで &lt;code&gt;Arbitrary&lt;/code&gt; のインスタンス定義があります。&lt;/p&gt;
&lt;p&gt;しかしながら、&lt;a href="https://www.stackage.org/lts-11.2/package/time-1.8.0.2"&gt;time&lt;/a&gt; パッケージの &lt;a href="https://www.stackage.org/haddock/lts-11.2/time-1.8.0.2/Data-Time-Clock.html#t:UTCTime"&gt;UTCTime&lt;/a&gt; 型や &lt;a href="https://www.stackage.org/lts-11.2/package/text-1.2.3.0"&gt;text&lt;/a&gt; パッケージの &lt;a href="https://www.stackage.org/haddock/lts-11.2/text-1.2.3.0/Data-Text.html#t:Text"&gt;Text&lt;/a&gt; 型などのインスタンス定義は別途自分で書かなくてはなりません。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/package/quickcheck-instances"&gt;quickcheck-instances&lt;/a&gt; パッケージはそういった、よく使うパッケージのインスタンス定義をまとめたものです。&lt;/p&gt;
&lt;p&gt;このパッケージの定義で満足いかない場合は自分でカスタマイズするというようにすれば、効率的に開発が進むと思いますよ！&lt;/p&gt;
&lt;h2 id="haskell-の入門書を読み終えたあとは"&gt;Haskell の入門書を読み終えたあとは・・・？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Haskell&lt;/code&gt; の入門書を読み終わった後のオススメの勉強法は以下の2つです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アカデミックコース: 論文を読む&lt;/li&gt;
&lt;li&gt;エンジニアコース: ライブラリとアプリケーションのソースコードを読む&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;論文の知識が無いと読めないライブラリもありますし、実装力がないと深い理解が得られない論文もあると思いますが、続けていると不思議とわかるようになります。&lt;/p&gt;
&lt;p&gt;また、驚くべきことに &lt;code&gt;Haskell&lt;/code&gt; 界隈ではカジュアルにドキュメントのリンクが論文だったりしますが、時間が経てばわかりやすい解説がいくつも出てくるものなので、その時はわからなくてもそのうちわかるようになるかもしれません。&lt;/p&gt;
&lt;p&gt;ちなみに &lt;code&gt;QuickCheck&lt;/code&gt; に関連する論文も (いくつか) ありますよ。&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;shrink&lt;/code&gt; なんて使ったことなかったので、今まで良くわかんない関数でしたが、今後機会があれば定義してみようと思います。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QuickCheck&lt;/code&gt; はランダムテストだと思えば、すぐに理解できますよ！性質テストって言われると難しい感じがしてしまいます・・・。(僕だけかも)&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/03-27-quiz-3.html</id><title type="text">Haskell Quiz No.3 QuickCheck の Arbitrary 型クラス</title><updated>2018-03-27T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/03-27-quiz-3.html"/><summary type="html">&lt;h2 id="haskell-quiz-no.3"&gt;Haskell Quiz No.3&lt;/h2&gt;
&lt;p&gt;難易度: λ&lt;/p&gt;
&lt;p&gt;&lt;code&gt;propIsDigit&lt;/code&gt; テストをパスするように &lt;code&gt;Digit&lt;/code&gt; 型の &lt;code&gt;Arbitrary&lt;/code&gt; インスタンスを定義してみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Quiz3&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Test.QuickCheck&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Char&lt;/span&gt; (isDigit)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Digit&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Digit&lt;/span&gt; &lt;span class="dt"&gt;Char&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;  &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;&lt;span class="ot"&gt;propIsDigit ::&lt;/span&gt; &lt;span class="dt"&gt;Digit&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;propIsDigit (&lt;span class="dt"&gt;Digit&lt;/span&gt; c) &lt;span class="fu"&gt;=&lt;/span&gt; isDigit c&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Arbitrary&lt;/span&gt; &lt;span class="dt"&gt;Digit&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;  arbitrary &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;テストは以下のように実行します。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;stack&lt;/span&gt; repl --package QuickCheck -- Quiz3.hs&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="ex"&gt;*Quiz3&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; quickCheck propIsDigit&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="ex"&gt;+++&lt;/span&gt; OK, passed 100 tests.&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記のように &lt;code&gt;OK&lt;/code&gt; になれば (たぶん) 正解です！&lt;/p&gt;
&lt;p&gt;ヒント: 生成される値をデバッグしたい場合は &lt;code&gt;sample'&lt;/code&gt; 関数が便利です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="ex"&gt;*Quiz3&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; sample&lt;span class="st"&gt;&amp;#39; (arbitrary :: Gen Digit)&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;答えは&lt;a href="03-28-quiz-4.html"&gt;次回&lt;/a&gt;。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href="./03-25-quiz-2.html"&gt;前回&lt;/a&gt;の問題と答えは以下の通りです。&lt;/p&gt;
&lt;h3 id="問題"&gt;問題&lt;/h3&gt;
&lt;p&gt;難易度: λλ&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;foldr (&lt;span class="fu"&gt;&amp;amp;&amp;amp;&lt;/span&gt;) &lt;span class="dt"&gt;True&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; cycle [&lt;span class="dt"&gt;True&lt;/span&gt;, &lt;span class="dt"&gt;False&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;foldl (&lt;span class="fu"&gt;&amp;amp;&amp;amp;&lt;/span&gt;) &lt;span class="dt"&gt;True&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; cycle [&lt;span class="dt"&gt;True&lt;/span&gt;, &lt;span class="dt"&gt;False&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記の2つの式の挙動の違いを説明してください。&lt;/p&gt;
&lt;p&gt;また、なぜそうなるのか考えてみましょう！&lt;/p&gt;
&lt;h3 id="こたえ"&gt;こたえ&lt;/h3&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; foldr (&lt;span class="fu"&gt;&amp;amp;&amp;amp;&lt;/span&gt;) &lt;span class="dt"&gt;True&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; cycle [&lt;span class="dt"&gt;True&lt;/span&gt;, &lt;span class="dt"&gt;False&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="dt"&gt;False&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; foldl (&lt;span class="fu"&gt;&amp;amp;&amp;amp;&lt;/span&gt;) &lt;span class="dt"&gt;True&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; cycle [&lt;span class="dt"&gt;True&lt;/span&gt;, &lt;span class="dt"&gt;False&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;&lt;span class="fu"&gt;^&lt;/span&gt;&lt;span class="dt"&gt;CInterrupted&lt;/span&gt;&lt;span class="fu"&gt;.&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ということで &lt;code&gt;foldr&lt;/code&gt; は無限リストに対しても停止して値を返しますが、&lt;code&gt;foldl&lt;/code&gt; は停止せず、値を返さない。&lt;/p&gt;
&lt;p&gt;でした。&lt;/p&gt;
&lt;h2 id="haskell-quiz-no.2-の解説"&gt;Haskell Quiz No.2 の解説&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Haskell&lt;/code&gt; は遅延評価なので &lt;code&gt;foldr&lt;/code&gt; が無限リストを扱えるということは、知っておいて欲しいです。&lt;/p&gt;
&lt;p&gt;また実際のアプリケーションではスペースリークの問題があるため &lt;code&gt;foldr&lt;/code&gt; &amp;lt; &lt;code&gt;foldl&lt;/code&gt; &amp;lt; &lt;code&gt;foldl'&lt;/code&gt; の順で好まれるかもしません。(最適化されるから気にしなくても良いという話も聞いたことありますが、詳しくないので良くわかんないです。)&lt;/p&gt;
&lt;h3 id="cycle"&gt;cycle&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-List.html#cycle"&gt;cycle&lt;/a&gt; 関数は &lt;code&gt;base&lt;/code&gt; パッケージの &lt;a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-List.html#cycle"&gt;GHC.List&lt;/a&gt; で定義されています。また &lt;a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/Prelude.html#v:cycle"&gt;Prelude&lt;/a&gt; モジュールにも含まれています。&lt;/p&gt;
&lt;p&gt;以下は実際の定義です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;cycle&lt;span class="ot"&gt; ::&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;cycle [] &lt;span class="fu"&gt;=&lt;/span&gt; errorEmptyList &lt;span class="st"&gt;&amp;quot;cycle&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;cycle xs &lt;span class="fu"&gt;=&lt;/span&gt; xs&amp;#39;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt; xs&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; xs &lt;span class="fu"&gt;++&lt;/span&gt; xs&amp;#39;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この定義を見ればわかるように &lt;code&gt;cycle&lt;/code&gt; 関数は空リストを与えると実行時エラーになります。&lt;/p&gt;
&lt;p&gt;それ以外の場合では与えられたリストを繰り返して無限リストを作ります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="ex"&gt;cycle&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Haskell&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;&lt;span class="st"&gt;&amp;quot;HaskellHaskellHaskell...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="prelude-モジュールについて"&gt;Prelude モジュールについて&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Prelude&lt;/code&gt; モジュールは良く使う基本的な関数や型の集まりです。とても良く使うので自動的に &lt;code&gt;import&lt;/code&gt; されています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Prelude&lt;/code&gt; で定義されている関数の &lt;code&gt;型&lt;/code&gt;・&lt;code&gt;定義&lt;/code&gt;・&lt;code&gt;動作&lt;/code&gt; は全部わかるようにしておきましょう。&lt;/p&gt;
&lt;p&gt;これは本当に基礎知識です。(Haskell が苦手だなーと思う人はまずは &lt;code&gt;Prelude&lt;/code&gt; で定義されている関数に慣れてください。それだけでも十分楽しめます。)&lt;/p&gt;
&lt;p&gt;また、暗記して覚えることは非常に無駄なのでやめましょう。&lt;/p&gt;
&lt;p&gt;何年か &lt;code&gt;Haskell&lt;/code&gt; を使っていれば自然に覚えますし、感覚的には覚えている関数を書き下すのではなく、&lt;code&gt;関数名&lt;/code&gt; と &lt;code&gt;型&lt;/code&gt; または &lt;code&gt;関数の動作&lt;/code&gt; から実装を導いている感じです。&lt;/p&gt;
&lt;h3 id="foldable"&gt;Foldable&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/Data-Foldable.html#line-117"&gt;Foldable&lt;/a&gt; 型クラスは &lt;code&gt;base&lt;/code&gt; パッケージの &lt;a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/Data-Foldable.html"&gt;Data.Foldable&lt;/a&gt; で定義されています。また &lt;a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/Prelude.html#t:Foldable"&gt;Prelude&lt;/a&gt; モジュールにも含まれています。&lt;/p&gt;
&lt;p&gt;昔の &lt;code&gt;foldr&lt;/code&gt; はリストに対してのみ適用可能な関数でしたが、比較的最近 &lt;code&gt;Foldable&lt;/code&gt; クラスのメソッドになりました。そのため、リスト以外でも利用できます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Foldable&lt;/code&gt; のクラス定義とリストのインスタンス定義はこんな感じです。(実際にはもっと多くのメソッドがあります)&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Foldable&lt;/span&gt; t &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  foldr ::&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; t a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;  foldr f z t &lt;span class="fu"&gt;=&lt;/span&gt; appEndo (foldMap (&lt;span class="dt"&gt;Endo&lt;/span&gt; &lt;span class="fu"&gt;#.&lt;/span&gt; f) t) z&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Foldable&lt;/span&gt; [] &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;  foldr &lt;span class="fu"&gt;=&lt;/span&gt; List.foldr&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初学者に優しくない世界になりましたね・・・。なかなか定義にたどり着きません。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; 宣言のあたりを見ると &lt;code&gt;import qualified GHC.List as List&lt;/code&gt; とあるので &lt;code&gt;List.foldr&lt;/code&gt; は &lt;code&gt;GHC.List.foldr&lt;/code&gt; だとわかります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GHC.List&lt;/code&gt; を &lt;code&gt;base&lt;/code&gt; パッケージの&lt;a href="https://www.stackage.org/lts-11.2/package/base-4.10.1.0"&gt;一覧&lt;/a&gt;から探しても見つかりません。これはわざと利用者に見えないようにしているためです。&lt;/p&gt;
&lt;p&gt;実際に &lt;a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-List.html"&gt;GHC.List&lt;/a&gt; は存在しますが &lt;code&gt;{-# OPTIONS_HADDOCK hide #-}&lt;/code&gt; プラグマによって隠されているのです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GHC.List&lt;/code&gt; を探してもリストの &lt;code&gt;foldr&lt;/code&gt; の定義は見つかりません。どうやら &lt;a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-Base.html"&gt;GHC.Base&lt;/a&gt; で定義しているようです。&lt;/p&gt;
&lt;h3 id="foldr"&gt;foldr&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-Base.html#line-850"&gt;foldr&lt;/a&gt; の実際の定義は以下の通りです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;foldr&lt;span class="ot"&gt; ::&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;foldr k z &lt;span class="fu"&gt;=&lt;/span&gt; go&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;    go [] &lt;span class="fu"&gt;=&lt;/span&gt; z&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;    go (y&lt;span class="fu"&gt;:&lt;/span&gt;ys) &lt;span class="fu"&gt;=&lt;/span&gt; y &lt;span class="ot"&gt;`k`&lt;/span&gt; go ys&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これではわかりずらいので少し変形してみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;foldr&lt;span class="ot"&gt; ::&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;foldr k z []     &lt;span class="fu"&gt;=&lt;/span&gt; z&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;foldr k z (y&lt;span class="fu"&gt;:&lt;/span&gt;ys) &lt;span class="fu"&gt;=&lt;/span&gt; y &lt;span class="ot"&gt;`k`&lt;/span&gt; foldr k z ys&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;変数名もいつもの感じに変えちゃいましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;foldr&lt;span class="ot"&gt; ::&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;foldr _  e []     &lt;span class="fu"&gt;=&lt;/span&gt; e&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;foldr f  e (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="ot"&gt;`f`&lt;/span&gt; foldr f e xs &lt;span class="co"&gt;-- f x (foldr f e xs) と同じ&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;だいぶ見慣れた形に近づいてきました。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;foldr&lt;/code&gt; (&lt;code&gt;foldl&lt;/code&gt;) はほどよく抽象化されているので、色々な理解があると思いますので、僕がいつも使っている説明をいくつかご紹介します。&lt;/p&gt;
&lt;p&gt;ここからの &lt;code&gt;foldr&lt;/code&gt;, &lt;code&gt;foldl&lt;/code&gt; は全てリストについての話です。&lt;/p&gt;
&lt;h4 id="直感的な説明"&gt;直感的な説明&lt;/h4&gt;
&lt;p&gt;例えば &lt;code&gt;foldr (+) 0 [1,2,3,4,5]&lt;/code&gt; は以下のように考えることができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;[&lt;span class="dv"&gt;1&lt;/span&gt; , &lt;span class="dv"&gt;2&lt;/span&gt; , &lt;span class="dv"&gt;3&lt;/span&gt; , &lt;span class="dv"&gt;4&lt;/span&gt; , &lt;span class="dv"&gt;5&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- リストの括弧 (`[`, `]`) を外します&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;&lt;span class="dv"&gt;1&lt;/span&gt; , &lt;span class="dv"&gt;2&lt;/span&gt; , &lt;span class="dv"&gt;3&lt;/span&gt; , &lt;span class="dv"&gt;4&lt;/span&gt; , &lt;span class="dv"&gt;5&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;&lt;span class="co"&gt;-- foldr(ight) なのでに 0 を追加します&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" data-line-number="5"&gt;&lt;span class="dv"&gt;1&lt;/span&gt; , &lt;span class="dv"&gt;2&lt;/span&gt; , &lt;span class="dv"&gt;3&lt;/span&gt; , &lt;span class="dv"&gt;4&lt;/span&gt; , &lt;span class="dv"&gt;5&lt;/span&gt; , &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" data-line-number="6"&gt;&lt;span class="co"&gt;-- , を (+) に置き換えます&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" data-line-number="7"&gt;&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;4&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-8" data-line-number="8"&gt;&lt;span class="co"&gt;-- foldr(ight) なので右結合で括弧をつけていきます&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-9" data-line-number="9"&gt;&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; (&lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; (&lt;span class="dv"&gt;3&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; (&lt;span class="dv"&gt;4&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; (&lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;))))&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-11" data-line-number="11"&gt;&lt;span class="co"&gt;-- 一般化すると&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-12" data-line-number="12"&gt;x1 &lt;span class="ot"&gt;`f`&lt;/span&gt; (x2 &lt;span class="ot"&gt;`f`&lt;/span&gt; (x3 &lt;span class="ot"&gt;`f`&lt;/span&gt; (x4 &lt;span class="ot"&gt;`f`&lt;/span&gt; (x5 &lt;span class="ot"&gt;`f`&lt;/span&gt; e))))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;簡単ですね！この考え方をすれば &lt;code&gt;foldr&lt;/code&gt; の型を暗記する必要はありません。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;foldr f e xs&lt;/code&gt; の型はこのように考えれば良いのです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f :: a -&amp;gt; b -&amp;gt; ?&lt;/code&gt;。この時 &lt;code&gt;?&lt;/code&gt; が &lt;code&gt;a&lt;/code&gt; か &lt;code&gt;b&lt;/code&gt; か迷いそうですが、上の図で考えれば &lt;code&gt;x5 `f` e&lt;/code&gt; の結果は &lt;code&gt;x4 `f`&lt;/code&gt; の第二引数に再び適用されます。そのため &lt;code&gt;f :: a -&amp;gt; b -&amp;gt; b&lt;/code&gt; でなければ型が合いません。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; の型がわかれば &lt;code&gt;e&lt;/code&gt; の型は自然に &lt;code&gt;b&lt;/code&gt; しか有りえません。&lt;/li&gt;
&lt;li&gt;当然 &lt;code&gt;xs&lt;/code&gt; は &lt;code&gt;x1, x2, x3, ・・・&lt;/code&gt; とリストの形式なので &lt;code&gt;[a]&lt;/code&gt; しかありえません。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;foldr&lt;/code&gt; の結果の型は最終的に &lt;code&gt;x1 `f` ...&lt;/code&gt; となるので &lt;code&gt;f :: a -&amp;gt; b -&amp;gt; b&lt;/code&gt; から &lt;code&gt;b&lt;/code&gt; です。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上により &lt;code&gt;foldr :: (a -&amp;gt; b -&amp;gt; b) -&amp;gt; b -&amp;gt; [a] -&amp;gt; b&lt;/code&gt; が導かれました。&lt;/p&gt;
&lt;h4 id="universal-property-を使った説明"&gt;universal property を使った説明&lt;/h4&gt;
&lt;p&gt;普遍性 (&lt;code&gt;universal property&lt;/code&gt;) の詳しいことは有識者の方に任せるとして&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;myFunc []     &lt;span class="fu"&gt;=&lt;/span&gt; e&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;myFunc (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt; f x (myFunc xs)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記のような再帰パターンの関数は全て &lt;code&gt;foldr f e&lt;/code&gt; として書けるという性質です。この説明はどちらかと言うと、ベタに再帰で書いた関数を &lt;code&gt;foldr&lt;/code&gt; を使った形式に書き直す際の理解の手助けとして有用かと思います。&lt;/p&gt;
&lt;p&gt;具体例を見ればすぐにわかります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;sum [] &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;sum (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="fu"&gt;+&lt;/span&gt; sum xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;sum&lt;/code&gt; 関数は &lt;code&gt;foldr (+) 0&lt;/code&gt; と同じです。(この時の &lt;code&gt;e&lt;/code&gt; は &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;(+)&lt;/code&gt; に対応します)&lt;/p&gt;
&lt;p&gt;では先程の &lt;code&gt;cycle&lt;/code&gt; は普遍性を使って &lt;code&gt;foldr&lt;/code&gt; で書けるの？という疑問になりますよね。&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;cycle [] &lt;span class="fu"&gt;=&lt;/span&gt; errorEmptyList &lt;span class="st"&gt;&amp;quot;cycle&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;cycle xs &lt;span class="fu"&gt;=&lt;/span&gt; xs&amp;#39;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt; xs&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; xs &lt;span class="fu"&gt;++&lt;/span&gt; xs&amp;#39;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先程のパターンと微妙に違うので合わせてみましょう。&lt;/p&gt;
&lt;p&gt;また &lt;code&gt;xs' = cycle xs&lt;/code&gt; なので以下のように変形できます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;cycle [] &lt;span class="fu"&gt;=&lt;/span&gt; errorEmptyList &lt;span class="st"&gt;&amp;quot;cycle&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;cycle xs &lt;span class="fu"&gt;=&lt;/span&gt; xs &lt;span class="fu"&gt;++&lt;/span&gt; cycle xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;さらに変形します。&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" data-line-number="1"&gt;cycle []     &lt;span class="fu"&gt;=&lt;/span&gt; errorEmptyList &lt;span class="st"&gt;&amp;quot;cycle&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-2" data-line-number="2"&gt;cycle (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt; (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;++&lt;/span&gt; cycle (x&lt;span class="fu"&gt;:&lt;/span&gt;xs)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ここで、最初のパターンと比較しやすいように &lt;code&gt;cycle&lt;/code&gt; を &lt;code&gt;myFunc&lt;/code&gt; という名前に変更します。&lt;/p&gt;
&lt;p&gt;ついでに &lt;code&gt;++&lt;/code&gt; の位置も変更しておきます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb18-1" data-line-number="1"&gt;&lt;span class="co"&gt;-- cycle&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-2" data-line-number="2"&gt;myFunc []     &lt;span class="fu"&gt;=&lt;/span&gt; errorEmptyList &lt;span class="st"&gt;&amp;quot;cycle&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-3" data-line-number="3"&gt;myFunc (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt; (&lt;span class="fu"&gt;++&lt;/span&gt;) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) (myFunc (x&lt;span class="fu"&gt;:&lt;/span&gt;xs))&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-5" data-line-number="5"&gt;&lt;span class="co"&gt;-- foldr として書き直すことが出来る再帰パターン&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-6" data-line-number="6"&gt;myFunc []     &lt;span class="fu"&gt;=&lt;/span&gt; e&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-7" data-line-number="7"&gt;myFunc (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt; f x (myFunc xs)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;どうですか、微妙に違いますよね。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;xs&lt;/code&gt; に分解しなければいけないのにどちらも &lt;code&gt;(x:xs)&lt;/code&gt; になってしまっています。&lt;/p&gt;
&lt;p&gt;ということで &lt;code&gt;foldr&lt;/code&gt; を使った &lt;code&gt;cycle&lt;/code&gt; の定義を普遍性を使って導出することはできません。&lt;/p&gt;
&lt;h3 id="cycle-関数を-foldr-を使って定義する"&gt;cycle 関数を foldr を使って定義する&lt;/h3&gt;
&lt;p&gt;普遍性を使った方法では &lt;code&gt;cycle&lt;/code&gt; を導出することができませんでした。&lt;/p&gt;
&lt;p&gt;けど、本当に &lt;code&gt;foldr&lt;/code&gt; を使って定義することはできないのでしょうか？ (参考: &lt;a href="https://mail.haskell.org/pipermail/beginners/2009-March/001184.html"&gt;[Haskell-beginners] folds again – myCycle&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;僕はいつもこのような感じで &lt;code&gt;foldr&lt;/code&gt; の定義を考えます。&lt;code&gt;acc&lt;/code&gt; は蓄積変数 (&lt;code&gt;accumulate variable&lt;/code&gt;) の略です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;go&lt;/code&gt; の第二引数は常に &lt;code&gt;foldr&lt;/code&gt; で畳み込んだ結果として考えることができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb19-1" data-line-number="1"&gt;cycle&lt;span class="ot"&gt; ::&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-2" data-line-number="2"&gt;cycle xs &lt;span class="fu"&gt;=&lt;/span&gt; foldr go e undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-4" data-line-number="4"&gt;    e        &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-5" data-line-number="5"&gt;    go x acc &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;少し考えると &lt;code&gt;xs&lt;/code&gt; を &lt;code&gt;xs ++ xs ++ xs ...&lt;/code&gt; という形式にできれば良さそうです。&lt;/p&gt;
&lt;p&gt;無限リストになるため初期値 &lt;code&gt;e&lt;/code&gt; は絶対に評価されません。そのため &lt;code&gt;[]&lt;/code&gt; でも &lt;code&gt;xs&lt;/code&gt; でも &lt;code&gt;undefined&lt;/code&gt; でも好きな値が使えそうです。ここでは何となく &lt;code&gt;xs&lt;/code&gt; にしておきます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb20-1" data-line-number="1"&gt;cycle&lt;span class="ot"&gt; ::&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-2" data-line-number="2"&gt;cycle xs &lt;span class="fu"&gt;=&lt;/span&gt; foldr go e undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-4" data-line-number="4"&gt;    e        &lt;span class="fu"&gt;=&lt;/span&gt; xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-5" data-line-number="5"&gt;    go x acc &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;次に &lt;code&gt;go&lt;/code&gt; 関数ですが &lt;code&gt;xs ++ (xs ++ (xs ++ (...)))&lt;/code&gt; となれば良いので、 &lt;code&gt;go x acc = xs ++ acc&lt;/code&gt; です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;go&lt;/code&gt; が &lt;code&gt;cycle&lt;/code&gt; の引数 &lt;code&gt;xs&lt;/code&gt; を参照している点が通常の使い方と異なる点です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb21-1" data-line-number="1"&gt;cycle&lt;span class="ot"&gt; ::&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-2" data-line-number="2"&gt;cycle xs &lt;span class="fu"&gt;=&lt;/span&gt; foldr go e undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-4" data-line-number="4"&gt;    e        &lt;span class="fu"&gt;=&lt;/span&gt; xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-5" data-line-number="5"&gt;    go _ acc &lt;span class="fu"&gt;=&lt;/span&gt; xs &lt;span class="fu"&gt;++&lt;/span&gt; acc&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ここが一番のポイントですが &lt;code&gt;foldr&lt;/code&gt; に与えるリストは &lt;code&gt;xs&lt;/code&gt; ではありません。&lt;/p&gt;
&lt;p&gt;無限リストを生成するために適当な無限リストを与えます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb22"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb22-1" data-line-number="1"&gt;cycle&lt;span class="ot"&gt; ::&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-2" data-line-number="2"&gt;cycle xs &lt;span class="fu"&gt;=&lt;/span&gt; foldr go e [&lt;span class="dv"&gt;0&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-4" data-line-number="4"&gt;    e        &lt;span class="fu"&gt;=&lt;/span&gt; xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-5" data-line-number="5"&gt;    go _ acc &lt;span class="fu"&gt;=&lt;/span&gt; xs &lt;span class="fu"&gt;++&lt;/span&gt; acc&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;つまりこのような感じです。&lt;/p&gt;
&lt;pre class="text"&gt;&lt;code&gt;0 `go` (1 `go` (2 `go` (3 `go` ...)))
xs ++ (1 `go` (2 `go` (3 `go` ...)))
xs ++ (xs ++ (2 `go` (3 `go` ...)))
xs ++ (xs ++ (xs ++ (3 `go` ...)))
xs ++ (xs ++ (xs ++ (xs ++ ...)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これは完全に &lt;code&gt;cycle&lt;/code&gt; ですね！&lt;/p&gt;
&lt;p&gt;こんな感じで頑張れば &lt;code&gt;foldr&lt;/code&gt; を使って &lt;code&gt;cycle&lt;/code&gt; を定義することができます。&lt;/p&gt;
&lt;p&gt;ただ、本質的には &lt;code&gt;unfoldr&lt;/code&gt; を使うべき問題だと思います！(そのうちクイズにします)&lt;/p&gt;
&lt;h3 id="遅延評価を追ってみよう"&gt;遅延評価を追ってみよう！&lt;/h3&gt;
&lt;p&gt;やっと問題の本題です・・・。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;foldr&lt;/code&gt;, &lt;code&gt;cycle&lt;/code&gt;, &lt;a href="https://www.stackage.org/haddock/lts-11.2/ghc-prim-0.5.1.1/src/GHC-Classes.html#%26%26"&gt;(&amp;amp;&amp;amp;)&lt;/a&gt; の定義は以下を使います。&lt;/p&gt;
&lt;div class="sourceCode" id="cb24"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb24-1" data-line-number="1"&gt;foldr&lt;span class="ot"&gt; ::&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-2" data-line-number="2"&gt;foldr _  e []     &lt;span class="fu"&gt;=&lt;/span&gt; e&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-3" data-line-number="3"&gt;foldr f  e (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="ot"&gt;`f`&lt;/span&gt; foldr f e xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-5" data-line-number="5"&gt;cycle&lt;span class="ot"&gt; ::&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-6" data-line-number="6"&gt;cycle xs &lt;span class="fu"&gt;=&lt;/span&gt; xs &lt;span class="fu"&gt;++&lt;/span&gt; cycle xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-8" data-line-number="8"&gt;&lt;span class="ot"&gt;(&amp;amp;&amp;amp;) ::&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-9" data-line-number="9"&gt;&lt;span class="dt"&gt;True&lt;/span&gt;  &lt;span class="fu"&gt;&amp;amp;&amp;amp;&lt;/span&gt; x  &lt;span class="fu"&gt;=&lt;/span&gt;  x&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-10" data-line-number="10"&gt;&lt;span class="dt"&gt;False&lt;/span&gt; &lt;span class="fu"&gt;&amp;amp;&amp;amp;&lt;/span&gt; _ &lt;span class="fu"&gt;=&lt;/span&gt;  &lt;span class="dt"&gt;False&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;それでは実際に遅延評価で簡約していきましょう。&lt;/p&gt;
&lt;pre class="text"&gt;&lt;code&gt;foldr (&amp;amp;&amp;amp;) True (cycle [True, False])
  = { cycle を適用 }
foldr (&amp;amp;&amp;amp;) True ([True, False] ++ cycle [True, False])
  = { foldr を適用 }
True &amp;amp;&amp;amp; foldr (&amp;amp;&amp;amp;) True ([False] ++ cycle [True, False])
  = { (&amp;amp;&amp;amp;) を適用 }
foldr (&amp;amp;&amp;amp;) True ([False] ++ cycle [True, False])
  = { fodlr を適用 }
False &amp;amp;&amp;amp; foldr (&amp;amp;&amp;amp;) True (cycle [True, False])
  = { (&amp;amp;&amp;amp;) を適用 }
False&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;つまり、&lt;code&gt;(&amp;amp;&amp;amp;)&lt;/code&gt; の定義に秘密があったのです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(&amp;amp;&amp;amp;)&lt;/code&gt; 第一引数が &lt;code&gt;False&lt;/code&gt; であれば第二引数を評価することなく &lt;code&gt;False&lt;/code&gt; を返します。そのため &lt;code&gt;False &amp;amp;&amp;amp; _ =  False&lt;/code&gt; のような定義になっています。(このような関数を非正格関数 (&lt;code&gt;non-strict function&lt;/code&gt;) と言います。定義は &lt;code&gt;f undefined = undefined&lt;/code&gt; であれば正格関数 (&lt;code&gt;strict function&lt;/code&gt;) です。&lt;code&gt;(&amp;amp;&amp;amp;)&lt;/code&gt; は第一引数に関しては正格ですが、第二引数に関しては非正格です)&lt;/p&gt;
&lt;p&gt;これが &lt;code&gt;foldr&lt;/code&gt; の場合に計算が停止する理由です。&lt;/p&gt;
&lt;p&gt;ではなぜ &lt;code&gt;foldl&lt;/code&gt; の場合は停止しないのでしょうか？&lt;/p&gt;
&lt;div class="sourceCode" id="cb26"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb26-1" data-line-number="1"&gt;foldl&lt;span class="ot"&gt; ::&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [b] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-2" data-line-number="2"&gt;foldl _ acc []     &lt;span class="fu"&gt;=&lt;/span&gt; acc&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-3" data-line-number="3"&gt;foldl f acc (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt; foldl f (acc &lt;span class="ot"&gt;`f`&lt;/span&gt; x) xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;foldl&lt;/code&gt; の場合も同様に簡約してみましょう。&lt;/p&gt;
&lt;pre class="text"&gt;&lt;code&gt;foldl (&amp;amp;&amp;amp;) True (cycle [True, False])
  = { cycle を適用 }
foldl (&amp;amp;&amp;amp;) True ([True, False] ++ cycle [True, False])
  = { foldl を適用 }
foldl (&amp;amp;&amp;amp;) (True &amp;amp;&amp;amp; True) ([False] ++ cycle [True, False])
  = { foldl を適用 }
foldl (&amp;amp;&amp;amp;) ((True &amp;amp;&amp;amp; True) &amp;amp;&amp;amp; False) (cycle [True, False])
  = ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ということで &lt;code&gt;foldl&lt;/code&gt; はリストの最後にたどり着くまで値を返せないのです。&lt;/p&gt;
&lt;p&gt;そのため、無限リストを処理しようとすると停止しなくなります。&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;p&gt;いつも解説が長くなってしまいます・・・。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fold&lt;/code&gt; の融合則とかめちゃめちゃ好きなのでいつかまとめたいですね。&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;fold&lt;/code&gt; が好きな人には &lt;a href="https://www.stackage.org/package/foldl"&gt;foldl&lt;/a&gt; パッケージがオススメです。&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-03-24-poly-variant-with-haskell.html</id><title type="text">多相バリアントを使いこなそう with Haskell</title><updated>2018-03-24T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-03-24-poly-variant-with-haskell.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;多相バリアントを使いこなそう with Haskell&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-03-24" itemprop="datePublished"&gt;
        Mar 24, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/extensible-package.html"&gt;extensible-package&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;&lt;a href="https://sampou.connpass.com/event/80492/"&gt;この前の「『Haskellによる関数プログラミングの思考法』読書会」&lt;/a&gt;の後の懇親会(？)で &lt;strong&gt;多相バリアント&lt;/strong&gt; の話になりまして，その時に以下の記事が話題にあがった．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://osiire.hatenablog.com/entry/20090510/1241957550"&gt;多相バリアントを使いこなそう(1) - osiire’s blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://osiire.hatenablog.com/entry/20090512/1242055541"&gt;多相バリアントを使いこなそう(2) - osiire’s blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://osiire.hatenablog.com/entry/20090514/1242235108"&gt;多相バリアントを使いこなそう(3) - osiire’s blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://osiire.hatenablog.com/entry/20090516/1242456737"&gt;多相バリアントを使いこなそう(4) - osiire’s blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらの記事は OCaml で多相バリアントの紹介をしています． ということで，同様の議論を Haskell でもしてみた！というのが，この記事の内容です．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;(2018.04.13 追記アリ)&lt;/p&gt;
&lt;h3 id="haskell-と多相バリアント"&gt;Haskell と多相バリアント&lt;/h3&gt;
&lt;p&gt;悲しいことに，Haskell には組み込みで多相バリアントは無い(バリアントとは Haskell の代数的データ型における直和型と概ね一緒)． なので，多相バリアントを Haskell で模倣するために，毎度おなじみ &lt;a href="https://hackage.haskell.org/package/extensible"&gt;&lt;code&gt;extensible&lt;/code&gt;&lt;/a&gt; パッケージを用いる．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;ネタバレをすると Haskell で同じことをするのは難しかった． なので，本質的な議論は osiire’s blog の方を読んだ方がいいと思うよ． 結局，本記事は osiire’s blog のと同様のことを Haskell もとい，&lt;code&gt;extensible&lt;/code&gt; パッケージでどのように行うか，という記事って感じになった．&lt;/p&gt;
&lt;h2 id="多相バリアントの基本"&gt;多相バリアントの基本&lt;/h2&gt;
&lt;p&gt;多相バリアントとは，名前の通り，多相的なバリアントである． バリアントは前述したとおり，直和型と基本的に同じ．&lt;/p&gt;
&lt;p&gt;例えば，普通の直和型として次のようなものがあったとする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Joker&lt;/span&gt; &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Number&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;InData&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Str&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Number&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;「最初の型はジョーカーと数字札があるトランプの型，次の型は何かファイルからデータを読み込む時に文字列と数字のデータを統一的に扱うための型」だそうです(&lt;a href="http://osiire.hatenablog.com/entry/20090510/1241957550"&gt;多相バリアントを使いこなそう(1)&lt;/a&gt; より)． どちらの型にも &lt;code&gt;Number Int&lt;/code&gt; という部分があるので次のような関数を両方に適用できそうな気がする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;getNumber (&lt;span class="dt"&gt;Number&lt;/span&gt; n) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Just&lt;/span&gt; n&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;getNumber _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Nothing&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;もちろん，そんなことはできない(そもそも，Haskell の値コンストラクタは名前空間を共有してしまうので同時に利用はできないのだが…)． そこで多相バリアントを用いれば，このような関数を実装することが出来るようになる．&lt;/p&gt;
&lt;h3 id="多相バリアントを定義"&gt;多相バリアントを定義&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;extensible&lt;/code&gt; パッケージを使って多相バリアント(拡張可能バリアント)を定義すると次のようになる(&lt;code&gt;DataKinds&lt;/code&gt; と &lt;code&gt;TypeOperators&lt;/code&gt; 言語拡張が必要)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;joker&amp;quot; &amp;gt;: (), &amp;quot;number&amp;quot; &amp;gt;: Int ]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;InData&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;str&amp;quot; &amp;gt;: String, &amp;quot;number&amp;quot; &amp;gt;: Int ]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;とくに細かい説明はしないが，なんとなく意味が読み取れるだろう． &lt;code&gt;getNumber&lt;/code&gt; 関数の実装は難しいので後回しにするとして，&lt;code&gt;getNumber&lt;/code&gt; 関数の型は &lt;code&gt;extensible&lt;/code&gt; パッケージの &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Inclusion.html#t:-8838-"&gt;&lt;code&gt;⊆&lt;/code&gt;&lt;/a&gt; 型クラスを用いて次のように書ける(意味は見た通り)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE FlexibleContexts #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="ot"&gt;getNumber ::&lt;/span&gt; (&lt;span class="ch"&gt;&amp;#39;[&amp;quot;number&amp;quot; &amp;gt;: Int] ⊆ xs) =&amp;gt; Variant xs -&amp;gt; Maybe Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;getNumber &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GHCi で試してみる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t getNumber (undefined&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;getNumber (undefined&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt;)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t getNumber (undefined&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;InData&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;getNumber (undefined&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;InData&lt;/span&gt;)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;確かに動作する．&lt;/p&gt;
&lt;h2 id="包含関係"&gt;包含関係&lt;/h2&gt;
&lt;p&gt;さて，&lt;code&gt;getNumber&lt;/code&gt; 関数をどのように実装するかだが，その前に多相バリアントの包含関係を議論しておく(この議論は&lt;a href="http://osiire.hatenablog.com/entry/20090514/1242235108"&gt;多相バリアントを使いこなそう(3)&lt;/a&gt;に対応する)．&lt;/p&gt;
&lt;p&gt;次のような簡単なバリアント型を考える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;HogeFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;HogeFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;hoge&amp;quot; &amp;gt;: ()&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;fuga&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このバリアント型に対し，&lt;code&gt;⊆&lt;/code&gt; を用いて多相的な関数は2種類考えれる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="ot"&gt;toInt1 ::&lt;/span&gt; (&lt;span class="dt"&gt;HogeFields&lt;/span&gt; ⊆ xs) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;toInt1 &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;&lt;span class="ot"&gt;toInt2 ::&lt;/span&gt; (xs ⊆ &lt;span class="dt"&gt;HogeFields&lt;/span&gt;) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;toInt2 &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;toInt1&lt;/code&gt; は &lt;code&gt;&amp;quot;hoge&amp;quot; &amp;gt;: ()&lt;/code&gt; と &lt;code&gt;&amp;quot;fuga&amp;quot; &amp;gt;: ()&lt;/code&gt; を要素に持つバリアント型全てが利用できる関数である(さっきの &lt;code&gt;getNumber&lt;/code&gt; と同じ)． &lt;code&gt;toInt2&lt;/code&gt; は &lt;code&gt;&amp;quot;hoge&amp;quot; &amp;gt;: ()&lt;/code&gt; か &lt;code&gt;&amp;quot;fuga&amp;quot; &amp;gt;: ()&lt;/code&gt; のどれかを要素に持つ(それ以外は持ってはいけない)バリアント型全てに利用できる関数である． 試しに，次の3つのバリアント型の値を定義し，GHCi で試してみよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="ot"&gt;hoge1 ::&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;hoge1 &lt;span class="fu"&gt;=&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge &lt;span class="fu"&gt;@=&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;&lt;span class="ot"&gt;hoge2 ::&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;piyo&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; () &lt;span class="ch"&gt;&amp;#39;: HogeFields)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;hoge2 &lt;span class="fu"&gt;=&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;piyo &lt;span class="fu"&gt;@=&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;&lt;span class="ot"&gt;hoge3 ::&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[&amp;quot;hoge&amp;quot; &amp;gt;: ()]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;hoge3 &lt;span class="fu"&gt;=&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge &lt;span class="fu"&gt;@=&lt;/span&gt; ()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;見てわかるように(？)，&lt;code&gt;hoge3 ⊆ hoge1 ⊆ hoge2&lt;/code&gt; である(厳密にはバリアントの要素の集合で成り立つ関係だが)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt1 hoge1&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;toInt1&lt;span class="ot"&gt; hoge1 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt1 hoge2&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;toInt1&lt;span class="ot"&gt; hoge2 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt1 hoge3&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;&lt;span class="fu"&gt;&amp;lt;&lt;/span&gt;interactive&lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; error&lt;span class="fu"&gt;:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" data-line-number="8"&gt;    &lt;span class="fu"&gt;?&lt;/span&gt; &lt;span class="dt"&gt;Couldn&amp;#39;t&lt;/span&gt; match &lt;span class="kw"&gt;type&lt;/span&gt; ‘&lt;span class="ch"&gt;&amp;#39;Missing (&amp;quot;fuga&amp;quot; &amp;#39;&lt;/span&gt;&lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; ())’&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-9" data-line-number="9"&gt;                     with ‘&lt;span class="ch"&gt;&amp;#39;Expecting pos0’&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-10" data-line-number="10"&gt;        arising from a use &lt;span class="kw"&gt;of&lt;/span&gt; ‘toInt1’&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-11" data-line-number="11"&gt;    &lt;span class="fu"&gt;?&lt;/span&gt; &lt;span class="dt"&gt;In&lt;/span&gt; the expression&lt;span class="fu"&gt;:&lt;/span&gt; toInt1 hoge3&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-12" data-line-number="12"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt2 hoge1&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-13" data-line-number="13"&gt;toInt2&lt;span class="ot"&gt; hoge1 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-14" data-line-number="14"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt2 hoge2&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-16" data-line-number="16"&gt;&lt;span class="fu"&gt;&amp;lt;&lt;/span&gt;interactive&lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; error&lt;span class="fu"&gt;:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-17" data-line-number="17"&gt;    &lt;span class="fu"&gt;?&lt;/span&gt; &lt;span class="dt"&gt;Couldn&amp;#39;t&lt;/span&gt; match &lt;span class="kw"&gt;type&lt;/span&gt; ‘&lt;span class="ch"&gt;&amp;#39;Missing (&amp;quot;piyo&amp;quot; &amp;#39;&lt;/span&gt;&lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; ())’&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-18" data-line-number="18"&gt;                     with ‘&lt;span class="ch"&gt;&amp;#39;Expecting pos0’&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-19" data-line-number="19"&gt;        arising from a use &lt;span class="kw"&gt;of&lt;/span&gt; ‘toInt2’&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-20" data-line-number="20"&gt;    &lt;span class="fu"&gt;?&lt;/span&gt; &lt;span class="dt"&gt;In&lt;/span&gt; the expression&lt;span class="fu"&gt;:&lt;/span&gt; toInt2 hoge2&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-21" data-line-number="21"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt2 hoge3&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-22" data-line-number="22"&gt;toInt2&lt;span class="ot"&gt; hoge3 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;確かに，&lt;code&gt;toInt1&lt;/code&gt; は &lt;code&gt;hoge1&lt;/code&gt; と &lt;code&gt;hoge2&lt;/code&gt; に適用でき，&lt;code&gt;toInt2&lt;/code&gt; は &lt;code&gt;hoge1&lt;/code&gt; と &lt;code&gt;hoge3&lt;/code&gt; に適用できている．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;さて，&lt;code&gt;toInt1&lt;/code&gt; と &lt;code&gt;toInt2&lt;/code&gt; の実装を与えてみる． 実は簡単なのは後者 &lt;code&gt;toInt2&lt;/code&gt; だ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedLabels #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;span class="ot"&gt;toInt2 ::&lt;/span&gt; (xs ⊆ &lt;span class="dt"&gt;HogeFields&lt;/span&gt;) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;toInt2 &lt;span class="fu"&gt;=&lt;/span&gt; flip matchField (spread&lt;span class="ot"&gt; xs ::&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;fuga &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;a href="https://matsubara0507.github.io/posts/2017-11-28-fun-of-extensible-1.html"&gt;昔の記事&lt;/a&gt;でも紹介した) &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Inclusion.html#v:spread"&gt;&lt;code&gt;spread&lt;/code&gt;&lt;/a&gt; 関数を用いることで &lt;strong&gt;バリアント型を拡張できる&lt;/strong&gt; (&lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Field.html#v:matchField"&gt;&lt;code&gt;matchField&lt;/code&gt;&lt;/a&gt; 関数の使い方についてはこの&lt;a href="https://matsubara0507.github.io/posts/2018-01-31-fun-of-extensible-2.html"&gt;記事&lt;/a&gt;を参照して)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="ot"&gt;shrink ::&lt;/span&gt; (xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; ys &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;&lt;span class="ot"&gt;spread ::&lt;/span&gt; (xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; ys&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;del&gt;拡縮する関数 &lt;code&gt;spread&lt;/code&gt; や &lt;code&gt;shrink&lt;/code&gt; は強力なのだが，多相的すぎて前後の型が分からないとエラーになる(気がする(パッケージの作者じゃないので細かいことはよくわからん))ので，型注釈 (&lt;code&gt;spread xs :: Hoge&lt;/code&gt; の部分)を与える必要がある．&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;(2018.04.13 追記) &lt;code&gt;spread&lt;/code&gt; や &lt;code&gt;shrink&lt;/code&gt; の代わりに &lt;code&gt;shrinkAssoc&lt;/code&gt; や &lt;code&gt;spreadAssoc&lt;/code&gt; を使えば値が多相でもうまく扱えるとのコトを&lt;a href="https://www.reddit.com/r/haskell_jp/comments/86rx9b/多相バリアントを使いこなそう_with_haskell/dwaq3cw/"&gt;作者様よりコメント&lt;/a&gt;いただいた． 感謝．&lt;/p&gt;
&lt;h3 id="必殺-coinclusion"&gt;必殺 Coinclusion&lt;/h3&gt;
&lt;p&gt;前者が難しいのは，&lt;code&gt;spread&lt;/code&gt; や &lt;code&gt;shrink&lt;/code&gt; とは逆の振る舞いを要求するからだ． そのために(この前作者から教えてもらった隠し技(別に隠してない)) &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Nullable.html"&gt;&lt;code&gt;Nullable&lt;/code&gt;&lt;/a&gt; を使う！ &lt;code&gt;Nullable&lt;/code&gt; を使うとバリアントやレコードの全ての要素を簡単に &lt;code&gt;Maybe&lt;/code&gt; でラップできる(なんかいいテーマがあったら，そのうち解説する)． さらに &lt;code&gt;Nullable&lt;/code&gt; を用いることで，Coinclusion を定義できる！&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="ot"&gt;wrench ::&lt;/span&gt; (&lt;span class="dt"&gt;Generate&lt;/span&gt; ys, xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (h &lt;span class="fu"&gt;:*&lt;/span&gt; xs) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Nullable&lt;/span&gt; h &lt;span class="fu"&gt;:*&lt;/span&gt; ys&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;&lt;span class="ot"&gt;retrench ::&lt;/span&gt; (&lt;span class="dt"&gt;Generate&lt;/span&gt; ys, xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (h &lt;span class="fu"&gt;:|&lt;/span&gt; ys) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Nullable&lt;/span&gt; ((&lt;span class="fu"&gt;:|&lt;/span&gt;) h) xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;wrench&lt;/code&gt; や &lt;code&gt;retrench&lt;/code&gt; は &lt;code&gt;shrink&lt;/code&gt; と &lt;code&gt;spread&lt;/code&gt; の逆向きの変換になっているのが分かるだろうか？ 逆向きにしたせいで足りない部分は &lt;code&gt;Nullable&lt;/code&gt; によって &lt;code&gt;Nothing&lt;/code&gt; となる． 例えば &lt;code&gt;Variant (&amp;quot;piyo&amp;quot; &amp;gt;: () ': HogeFields)&lt;/code&gt; から &lt;code&gt;Hoge&lt;/code&gt; に縮小する場合は，&lt;code&gt;embedAssoc (#piyo @= ())&lt;/code&gt; が &lt;code&gt;Nothing&lt;/code&gt; となり，他が &lt;code&gt;Just&lt;/code&gt; でラップされる．&lt;/p&gt;
&lt;h2 id="section-3"&gt;&lt;/h2&gt;
&lt;p&gt;Coinclusion を用いて &lt;code&gt;toInt2&lt;/code&gt; 関数を実装してみると次のようになる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE PolyKinds           #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# LANGUAGE RankNTypes          #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE ScopedTypeVariables #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;&lt;span class="ot"&gt;toInt1 ::&lt;/span&gt; (&lt;span class="dt"&gt;Generate&lt;/span&gt; xs, &lt;span class="dt"&gt;HogeFields&lt;/span&gt; ⊆ xs) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;toInt1 &lt;span class="fu"&gt;=&lt;/span&gt; matchFieldWithDefault &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" data-line-number="7"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; () &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" data-line-number="8"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;fuga &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;2&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; () &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-9" data-line-number="9"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-11" data-line-number="11"&gt;&lt;span class="ot"&gt;matchFieldWithDefault ::&lt;/span&gt; forall xs ys h r &lt;span class="fu"&gt;.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-12" data-line-number="12"&gt;  (&lt;span class="dt"&gt;Generate&lt;/span&gt; ys, xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; r &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; h r) xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;VariantOf&lt;/span&gt; h ys &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; r&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-13" data-line-number="13"&gt;matchFieldWithDefault defaultValue pat &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-14" data-line-number="14"&gt;  fromMaybe defaultValue &lt;span class="fu"&gt;.&lt;/span&gt; matchFieldWithMaybe pat&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-16" data-line-number="16"&gt;&lt;span class="ot"&gt;matchFieldWithMaybe ::&lt;/span&gt; forall xs ys h r &lt;span class="fu"&gt;.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-17" data-line-number="17"&gt;  (&lt;span class="dt"&gt;Generate&lt;/span&gt; ys, xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; h r) xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;VariantOf&lt;/span&gt; h ys &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; r&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-18" data-line-number="18"&gt;matchFieldWithMaybe pat &lt;span class="fu"&gt;=&lt;/span&gt; matchWith func (wrench pat)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-19" data-line-number="19"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-20" data-line-number="20"&gt;&lt;span class="ot"&gt;    func ::&lt;/span&gt; forall x &lt;span class="fu"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Nullable&lt;/span&gt; (&lt;span class="dt"&gt;Field&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; h r)) x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; h x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; r&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-21" data-line-number="21"&gt;    func fx gx &lt;span class="fu"&gt;=&lt;/span&gt; (\x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; runMatch (getField x) &lt;span class="fu"&gt;$&lt;/span&gt; getField gx) &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; getNullable fx&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;めんどくさいので細かい解説はしない(そもそももっといい方法があるかもしれない)． この &lt;code&gt;matchFieldWithMaybe&lt;/code&gt; を用いれば &lt;code&gt;getNumber&lt;/code&gt; も簡単に実装できるだろう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="ot"&gt;getNumber ::&lt;/span&gt; (&lt;span class="dt"&gt;Generate&lt;/span&gt; xs, &lt;span class="ch"&gt;&amp;#39;[&amp;quot;number&amp;quot; &amp;gt;: Int] ⊆ xs) =&amp;gt; Variant xs -&amp;gt; Maybe Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;getNumber &lt;span class="fu"&gt;=&lt;/span&gt; matchFieldWithMaybe &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; id &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="例-イベントを拡張する"&gt;例 : イベントを拡張する&lt;/h2&gt;
&lt;p&gt;ここからは「多相バリアントを使いこなそう」で取り上げられてた例を Haskell で示そう． ひとつ目は次のふたつのイベント型を考える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;KeyboardEvent&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;KeyboardEventFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;KeyboardEventFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;keyPress&amp;quot; &amp;gt;: Char&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;keyRelease&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Char&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;MouseEvent&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;MouseEventFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;MouseEventFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;mousePress&amp;quot; &amp;gt;: (Int, Int)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-10" data-line-number="10"&gt;   , &lt;span class="st"&gt;&amp;quot;mouseRelease&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; (&lt;span class="dt"&gt;Int&lt;/span&gt;, &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-11" data-line-number="11"&gt;   , &lt;span class="st"&gt;&amp;quot;click&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; (&lt;span class="dt"&gt;Int&lt;/span&gt;, &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-12" data-line-number="12"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;さて，これらの両方の型許容する型 &lt;code&gt;Event&lt;/code&gt; を作りたい． 普通の直和型を用いて次のように書くことが出来る．&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Event&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Key&lt;/span&gt; &lt;span class="dt"&gt;KeyboardEvent&lt;/span&gt; &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Mouse&lt;/span&gt; &lt;span class="dt"&gt;MouseEvent&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;もちろん，これでは元のふたつの型をうまく再利用できていない． 既に何度か登場している型レベルリストの連結 &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Product.html#t:-43--43-"&gt;&lt;code&gt;++&lt;/code&gt;&lt;/a&gt; を使って次のように書くこともできる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Event&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; (&lt;span class="dt"&gt;KeyboardEventFields&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="dt"&gt;MouseEventFields&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こうすると，&lt;code&gt;Event&lt;/code&gt; 型と &lt;code&gt;KeyboardEvent&lt;/code&gt; 型・&lt;code&gt;MouseEvent&lt;/code&gt; 型には包含関係ができ，前述した &lt;code&gt;Hoge&lt;/code&gt; 型で示した方法により各々で関数を共有することが出来る． 例えば次の &lt;code&gt;getCharFromEvent&lt;/code&gt; 関数は &lt;code&gt;KeyboardEvent&lt;/code&gt; 型と &lt;code&gt;Event&lt;/code&gt; 型の両方で利用できる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb18-1" data-line-number="1"&gt;&lt;span class="ot"&gt;getCharFromEvent ::&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-2" data-line-number="2"&gt;  (&lt;span class="dt"&gt;Generate&lt;/span&gt; xs, &lt;span class="dt"&gt;KeyboardEventFields&lt;/span&gt; ⊆ xs) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Char&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-3" data-line-number="3"&gt;getCharFromEvent &lt;span class="fu"&gt;=&lt;/span&gt; matchFieldWithDefault (error &lt;span class="st"&gt;&amp;quot;not a key&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-4" data-line-number="4"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;keyPress   &lt;span class="fu"&gt;@=&lt;/span&gt; id&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-5" data-line-number="5"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;keyRelease &lt;span class="fu"&gt;@=&lt;/span&gt; id&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-6" data-line-number="6"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="例-トランプで-expression-problem"&gt;例 : トランプで Expression Problem&lt;/h2&gt;
&lt;p&gt;Expression Problem が何なのかは各位ググってもらうとして，「多相バリアントを使いこなそう」の最後で紹介されていた，多相バリアントによる Expression Problem の解法を Haskell でもやってみる．&lt;/p&gt;
&lt;p&gt;次のような型と関数があったとする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb19-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;CardFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;CardFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-3" data-line-number="3"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;number&amp;quot; &amp;gt;: Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;jack&amp;quot;&lt;/span&gt;   &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-5" data-line-number="5"&gt;   , &lt;span class="st"&gt;&amp;quot;queen&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-6" data-line-number="6"&gt;   , &lt;span class="st"&gt;&amp;quot;king&amp;quot;&lt;/span&gt;   &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-7" data-line-number="7"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-9" data-line-number="9"&gt;&lt;span class="ot"&gt;cardNum ::&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-10" data-line-number="10"&gt;cardNum &lt;span class="fu"&gt;=&lt;/span&gt; matchField cardNumPattern&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-12" data-line-number="12"&gt;&lt;span class="ot"&gt;cardNumPattern ::&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; &lt;span class="dt"&gt;Identity&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="dt"&gt;CardFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-13" data-line-number="13"&gt;cardNumPattern&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-14" data-line-number="14"&gt;    &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; id&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-15" data-line-number="15"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;jack   &lt;span class="fu"&gt;@=&lt;/span&gt; const &lt;span class="dv"&gt;11&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-16" data-line-number="16"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;queen  &lt;span class="fu"&gt;@=&lt;/span&gt; const &lt;span class="dv"&gt;12&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-17" data-line-number="17"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;king   &lt;span class="fu"&gt;@=&lt;/span&gt; const &lt;span class="dv"&gt;13&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-18" data-line-number="18"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;cardNumPattern&lt;/code&gt; を切り出しているのがあからさまに恣意的だが…)これに以下のことは可能だろうか？&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;静的で安全に(キャストせず)&lt;/li&gt;
&lt;li&gt;元のコードを一切変更せず&lt;/li&gt;
&lt;li&gt;新しい場合分けを加え&lt;/li&gt;
&lt;li&gt;新しい操作も加えた&lt;/li&gt;
&lt;li&gt;新しい場合分け構造を定義する&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最後の「構造」というのは今回は置いておいて(OCaml ではモジュールとして定義してたが，Haskell でモジュールに切り分けるにはファイルを切り分ける必要があるので…めんどい…)，1-4を考えてみよう． &lt;code&gt;Card&lt;/code&gt; 型やその関数を拡張したものとして，次のような &lt;code&gt;CardExt&lt;/code&gt; 型とその関数を定義した．&lt;/p&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb20-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;CardExt&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;CardExtFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;CardExtFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;CardFields&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[&amp;quot;joker&amp;quot; &amp;gt;: ()]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-4" data-line-number="4"&gt;&lt;span class="ot"&gt;cardExtNum ::&lt;/span&gt; &lt;span class="dt"&gt;CardExt&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-5" data-line-number="5"&gt;cardExtNum &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-6" data-line-number="6"&gt;  matchField &lt;span class="fu"&gt;$&lt;/span&gt; shrink (&lt;span class="fu"&gt;#&lt;/span&gt;joker &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;0&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; () &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; cardNumPattern)&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-8" data-line-number="8"&gt;&lt;span class="ot"&gt;nextCardExt ::&lt;/span&gt; &lt;span class="dt"&gt;CardExt&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;CardExt&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-9" data-line-number="9"&gt;nextCardExt &lt;span class="fu"&gt;=&lt;/span&gt; matchField&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-10" data-line-number="10"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; (\n &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;if&lt;/span&gt; n &lt;span class="fu"&gt;&amp;lt;&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt; &lt;span class="kw"&gt;then&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; n &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="kw"&gt;else&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;jack &lt;span class="fu"&gt;@=&lt;/span&gt; ())&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-11" data-line-number="11"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;jack   &lt;span class="fu"&gt;@=&lt;/span&gt; const (embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;queen  &lt;span class="fu"&gt;@=&lt;/span&gt; ())&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-12" data-line-number="12"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;queen  &lt;span class="fu"&gt;@=&lt;/span&gt; const (embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;king   &lt;span class="fu"&gt;@=&lt;/span&gt; ())&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-13" data-line-number="13"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;king   &lt;span class="fu"&gt;@=&lt;/span&gt; const (embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;joker  &lt;span class="fu"&gt;@=&lt;/span&gt; ())&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-14" data-line-number="14"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;joker  &lt;span class="fu"&gt;@=&lt;/span&gt; const (embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-15" data-line-number="15"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これで一応&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;静的で安全に(もちろん!)&lt;/li&gt;
&lt;li&gt;既存のコードを改造せず&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;joker&amp;quot; &amp;gt;: ()&lt;/code&gt; という新しい場合分けを加え&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextCardExt&lt;/code&gt; という新しい操作(関数)を加える&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ことができた．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;組込みでこれらの機能がある OCaml はいいなぁとなった．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://haskell.jp/blog/posts/2018/renew-haskell-antenna.html</id><title type="text">Haskell Antenna をリニューアルしました</title><updated>2018-03-21T00:00:00Z</updated><author><name>Haskell-jp</name></author><link href="https://haskell.jp/blog/posts/2018/renew-haskell-antenna.html"/><summary type="html">&lt;article&gt;
    &lt;div class="container"&gt;
        &lt;div class="row"&gt;
            &lt;div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10"&gt;
                &lt;ul class="social-buttons"&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a href="https://twitter.com/share" class="twitter-share-button"&gt;Tweet&lt;/a&gt;
                        &lt;script&gt;!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;script type="text/javascript"&gt;
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        &lt;/script&gt;
                        &lt;script type="text/javascript" src="//www.redditstatic.com/button/button1.js"&gt;&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"&gt;&lt;/a&gt;
                        &lt;script type="text/javascript"&gt;!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"&gt;
              &lt;p&gt;&lt;a href="https://haskell.jp/antenna/"&gt;&lt;span class="ascii"&gt;Haskell Antenna&lt;/span&gt;&lt;/a&gt;は&lt;a href="https://github.com/lotz84"&gt;&lt;span class="ascii"&gt;lotz84&lt;/span&gt;&lt;/a&gt;氏が作った&lt;span class="ascii"&gt;Haskell&lt;/span&gt;の日本語情報を収集するウェブサイトです。 下記の記事を読むと、動機付けなどが分かると思います。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://haskell.jp/blog/posts/2017/03-haskell-antenna.html"&gt;&lt;span class="ascii"&gt;Haskell Antenna&lt;/span&gt; を公開しました &lt;span class="ascii"&gt;- Haskell-jp&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;残念なことに&lt;span class="ascii"&gt;Haskell Antenna&lt;/span&gt;は動作が重く、なかなか満足に閲覧することが出来ませんでした。 そこで、&lt;span class="ascii"&gt;Haskell Antenna&lt;/span&gt;をリニューアルしました！&lt;/p&gt;
&lt;p&gt;正確には、&lt;a href="https://planet.haskell.org/"&gt;&lt;span class="ascii"&gt;Planet Haskell&lt;/span&gt;&lt;/a&gt;の日本語版として作成した&lt;a href="https://github.com/matsubara0507/planet-haskell-jp-demo"&gt;もの&lt;/a&gt;を、新しい&lt;span class="ascii"&gt;Haskell Antenna&lt;/span&gt;として置き換えました。 新&lt;span class="ascii"&gt;Antenna&lt;/span&gt;は旧&lt;span class="ascii"&gt;Antenna&lt;/span&gt;と比べると見た目も機能も更新頻度も残念なことになってしまいましたが、各サイトのフィードから記事の一覧を取得し静的サイトとして生成しているだけなので動作は軽快です。&lt;/p&gt;
&lt;p&gt;旧&lt;span class="ascii"&gt;Antenna&lt;/span&gt;同様に新&lt;span class="ascii"&gt;Antenna&lt;/span&gt;でも配信する情報源&lt;span class="ascii"&gt;(&lt;/span&gt;今のところ&lt;span class="ascii"&gt;Atom&lt;/span&gt;か&lt;span class="ascii"&gt;RSS2.0&lt;/span&gt;形式のフィード&lt;span class="ascii"&gt;)&lt;/span&gt;をいつでも募集しています。 もし追加すべき情報源にアイデアがあれば&lt;a href="https://github.com/haskell-jp/antenna#サイトの追加方法"&gt;&lt;span class="ascii"&gt;GitHub&lt;/span&gt;レポジトリの&lt;span class="ascii"&gt;README&lt;/span&gt;&lt;/a&gt;にかかれている方法を参考に&lt;span class="ascii"&gt;Pull Request&lt;/span&gt;を送っていただくことが可能です。 また、&lt;span class="ascii"&gt;PR&lt;/span&gt;を送るのは面倒だという方は&lt;span class="ascii"&gt;Haskell-jp&lt;/span&gt;の&lt;span class="ascii"&gt;Slack&lt;/span&gt;の&lt;span class="ascii"&gt;#antenna&lt;/span&gt;チャンネルを通じて提案を行ってもらうことも大歓迎です。 &lt;span class="ascii"&gt;(Planet Haskell&lt;/span&gt;がそうであるように&lt;span class="ascii"&gt;)Haskell&lt;/span&gt;中心でなくても良いので、&lt;span class="ascii"&gt;Haskell&lt;/span&gt;の情報を発信しているブログを持っている方は是非、追加提案をしていただけると助かります。&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div id="post-navigation" class="row" style="margin-top: 20px;"&gt;
            &lt;div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4"&gt;
                
                &lt;i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"&gt;&lt;/i&gt;
                &lt;a href="/posts/2018/main-tester.html"&gt;CLIアプリのE2Eテストを行うためのライブラリー main-testerをリリースしました&lt;/a&gt;
                
            &lt;/div&gt;
            &lt;div class="col-lg-2 col-md-2 col-xs-4 text-center"&gt;
                &lt;a href="/"&gt;トップに戻る&lt;/a&gt;
            &lt;/div&gt;
            &lt;div class="col-lg-3 col-md-4 col-xs-4"&gt;
                
                &lt;a href="/posts/2018/windows-long-path.html" style="margin-left: auto;"&gt;WindowsでHaskellを扱う時によく遭遇するNo such file or directoryについて&lt;/a&gt;
                &lt;i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"&gt;&lt;/i&gt;
                
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/article&gt;

</summary></entry><entry><id>http://ilyaletre.hatenablog.com/entry/2018/03/20/224320</id><title type="text">Haskellで再帰的な構文木にFix(不動点)を導入してみる</title><updated>2018-03-20T22:47:14+09:00</updated><author><name>ilyaletre</name></author><link href="http://ilyaletre.hatenablog.com/entry/2018/03/20/224320"/><summary type="html">まえおき 例によって僕の記事など読まなくても下記のリンクで解説されているので、 Haskell楽しいなと思う人はこちらをどうぞ。 An Introduction to Recursion Schemes 生きるのに疲れた人は半分白目のゆるい気持ちで以降を読んでね。 Haskellで抽象構文木 (AST) にメタデータを付与する 以前この記事でASTへのメタデータの埋め込み方について少し整理して、 下記のようなアプローチがあることを明らかにした。 メタデータを保存するための値コンストラクタをASTのブランチとして定義する メタデータを保存するラッパーを定義する 加えて Fixを使ってなんかファン…</summary></entry><entry><id>https://haskell.jp/blog/posts/2018/windows-long-path.html</id><title type="text">WindowsでHaskellを扱う時によく遭遇するNo such file or directoryについて</title><updated>2018-03-13T00:00:00Z</updated><author><name>Haskell-jp</name></author><link href="https://haskell.jp/blog/posts/2018/windows-long-path.html"/><summary type="html">&lt;article&gt;
    &lt;div class="container"&gt;
        &lt;div class="row"&gt;
            &lt;div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10"&gt;
                &lt;ul class="social-buttons"&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a href="https://twitter.com/share" class="twitter-share-button"&gt;Tweet&lt;/a&gt;
                        &lt;script&gt;!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;script type="text/javascript"&gt;
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        &lt;/script&gt;
                        &lt;script type="text/javascript" src="//www.redditstatic.com/button/button1.js"&gt;&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"&gt;&lt;/a&gt;
                        &lt;script type="text/javascript"&gt;!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"&gt;
              &lt;hr /&gt;
&lt;p&gt;去年、&lt;a href="/posts/2017/windows-gotchas.html"&gt;&lt;span class="ascii"&gt;Windows&lt;/span&gt;で&lt;span class="ascii"&gt;Haskell&lt;/span&gt;を扱う時によく遭遇するエラーと対処法&lt;/a&gt;という記事で、&lt;span class="ascii"&gt;Windows&lt;/span&gt;ユーザーが&lt;span class="ascii"&gt;Haskell&lt;/span&gt;で開発したとき、あるいは&lt;span class="ascii"&gt;Haskell&lt;/span&gt;製のプログラムを使用した際によく遭遇するエラーやその回避方法を紹介しました。&lt;br /&gt;
今回は、そこに追記したい内容として、最近私がよく出遭うようになったエラーを紹介します。&lt;/p&gt;
&lt;h1 id="openfile-does-not-exist-no-such-file-or-directoryといわれたら短いパスに移そう"&gt;&lt;code&gt;openFile: does not exist (No such file or directory)&lt;/code&gt;といわれたら短いパスに移そう&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;does not exist (No such file or directory)&lt;/code&gt;というエラーは、本当に読んで字のごとく、開こうとしたファイルが存在しないためのエラーであることとがもちろん多いのですが、エラーメッセージに反して違う原因である場合もあります。&lt;/p&gt;
&lt;p&gt;例えば、最近私はとあるプロジェクトを数文字長い名前にリネームしたのですが、たったそれだけで、&lt;code&gt;stack test&lt;/code&gt;した際必ず問題のエラーが発生するようになってしまいました。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack test
a-little-longer-name-project-0.1.0.0: build (lib + exe + test)
Preprocessing library for a-little-longer-name-project-0.1.0.0..
Building library for a-little-longer-name-project-0.1.0.0..
Preprocessing executable &amp;#39;mmlh&amp;#39; for a-little-longer-name-project-0.1.0.0..
Building executable &amp;#39;mmlh&amp;#39; for a-little-longer-name-project-0.1.0.0..
Preprocessing test suite &amp;#39;a-little-longer-name-project-test&amp;#39; for a-little-longer-name-project-0.1.0.0..
Building test suite &amp;#39;a-little-longer-name-project-test&amp;#39; for a-little-longer-name-project-0.1.0.0..
[1 of 5] Compiling Paths_aLittleLongerNameProject ( .stack-work\dist\5c8418a7\build\a-little-longer-name-project-test\autogen\Paths_aLittleLongerNameProject.hs, .stack-work\dist\5c8418a7\build\a-little-longer-name-project-test\a-little-longer-name-project-test-tmp\Paths_aLittleLongerNameProject.o )
.stack-work\dist\5c8418a7\build\a-little-longer-name-project-test\a-little-longer-name-project-test-tmp\.stack-work\dist\5c8418a7\build\a-little-longer-name-project-test\autogen\Paths_aLittleLongerNameProject.dump-hi: openFile: does not exist (No such file or directory)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;どういうことかと悩んでいたところ、&lt;a href="https://github.com/commercialhaskell/stack/issues/3649"&gt;こんな&lt;span class="ascii"&gt;Issue&lt;/span&gt;&lt;/a&gt;を見つけました。&lt;br /&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3649#issuecomment-351612621"&gt;&lt;span class="ascii"&gt;Snoyman&lt;/span&gt;の指摘&lt;/a&gt;のとおり、こちらの問題は&lt;span class="ascii"&gt;Windows&lt;/span&gt;で使えるパスの長さが原因のエラーのようです。&lt;br /&gt;
どういうことかというと、&lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247%20(v=vs.85)#maxpath"&gt;&lt;span class="ascii"&gt;MSDN&lt;/span&gt;のこちらのページ&lt;/a&gt;でも触れているとおり、&lt;span class="ascii"&gt;Windows&lt;/span&gt;の（&lt;span class="ascii"&gt;C&lt;/span&gt;言語レベルでの）各種ファイル操作用&lt;span class="ascii"&gt;API&lt;/span&gt;では、一度に扱えるパスの長さが&lt;span class="ascii"&gt;260&lt;/span&gt;文字までと決められていて、その制限にかかったためのエラーだというのです！&lt;br /&gt;
&lt;code&gt;does not exist (No such file or directory)&lt;/code&gt;なんてエラーメッセージで表されるのでわかりづらい！&lt;small&gt;（おそらく&lt;span class="ascii"&gt;Windows&lt;/span&gt;のエラーコードの出し方に問題があるんじゃないかと思います）&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="ascii"&gt;DOS&lt;/span&gt;時代から残るこの制限、完全に時代錯誤なものでしかないのですが、&lt;span class="ascii"&gt;Windows&lt;/span&gt;でパッケージマネージャーなどが自動的に作ったパスを扱っていると、しばしば出くわすことがあります。&lt;br /&gt;
&lt;span class="ascii"&gt;stack&lt;/span&gt;においても、&lt;a href="https://github.com/commercialhaskell/stack/issues/3285"&gt;こちらの&lt;span class="ascii"&gt;Issue&lt;/span&gt;&lt;/a&gt;で同じ問題が議論されていたり、&lt;a href="https://github.com/commercialhaskell/stack/releases/tag/v1.6.5"&gt;&lt;span class="ascii"&gt;ver. 1.6.5&lt;/span&gt;の&lt;span class="ascii"&gt;ChangeLog&lt;/span&gt;&lt;/a&gt;でも言及されていたりと、至る所で格闘している跡があります。&lt;/p&gt;
&lt;h2 id="回避方法"&gt;回避方法&lt;/h2&gt;
&lt;p&gt;そんな&lt;code&gt;does not exist (No such file or directory)&lt;/code&gt;ですが、残念ながら私が知る限り、プロジェクトなどのパスを（&lt;code&gt;C:\&lt;/code&gt;などのよりルートに近い場所に置いて）より短くする以外の回避方法はありません。&lt;br /&gt;
&lt;a href="https://github.com/haskell/haskell-ide-engine#installation-on-windows"&gt;&lt;span class="ascii"&gt;haskell-ide-engine&lt;/span&gt;のインストール方法のページ&lt;/a&gt;曰く、（新しめの）&lt;span class="ascii"&gt;Windows 10&lt;/span&gt;であれば、グループポリシーを編集して、「&lt;span class="ascii"&gt;Win32&lt;/span&gt;の長いパスを有効にする」を「有効」にすれば回避できるとのことですが、残念ながら手元で試した限りうまくいきませんでした。何かやり方がまずかったのかもしれませんが。&lt;br /&gt;
いずれにしても、&lt;code&gt;stack build&lt;/code&gt;コマンドなどを実行したときに問題のエラーに遭遇した場合、ビルドしたいもののパスをなんとかして短くする以上の方法はありません。&lt;br /&gt;
&lt;code&gt;C:\&lt;/code&gt;直下をホームディレクトリのように使う人が今でもたくさんいるわけです。&lt;/p&gt;
&lt;p&gt;一方、あなたが問題のエラーが発生するプログラムを&lt;strong&gt;修正する&lt;/strong&gt;ことができる立場にある場合、次の方法で回避できるかもしれません。&lt;/p&gt;
&lt;h3 id="長いパスをより短くするためにカレントディレクトリーを変更して相対パスを短くする"&gt;長いパスをより短くするために、カレントディレクトリーを変更して、相対パスを短くする。&lt;/h3&gt;
&lt;p&gt;本件はあくまでも、&lt;span class="ascii"&gt;Windows&lt;/span&gt;の各種ファイル操作用&lt;span class="ascii"&gt;API&lt;/span&gt;の&lt;span class="ascii"&gt;1&lt;/span&gt;回の呼び出しで渡せる長さの制限ですので、制限を超えてしまうような場合はパスを分割すればよいのです。&lt;br /&gt;
&lt;a href="https://hackage.haskell.org/package/filepath-1.4.2/docs/System-FilePath-Posix.html#v:splitFileName"&gt;&lt;span class="ascii"&gt;filepath&lt;/span&gt;パッケージの&lt;code&gt;splitFileName&lt;/code&gt;関数&lt;/a&gt;や&lt;a href="https://hackage.haskell.org/package/filepath-1.4.2/docs/System-FilePath-Posix.html#v:splitPath"&gt;&lt;code&gt;splitPath&lt;/code&gt;関数&lt;/a&gt;を駆使してパスを分割した上で、対象のファイルの親ディレクトリーまで&lt;a href="https://hackage.haskell.org/package/directory-1.3.2.1/docs/System-Directory.html#v:setCurrentDirectory"&gt;&lt;span class="ascii"&gt;directory&lt;/span&gt;パッケージの&lt;code&gt;setCurrentDirectory&lt;/code&gt;関数&lt;/a&gt;で移動すれば、制限に引っかからないはずです&lt;small&gt;（時間の都合でこちらについては試すコードを用意しておりません。あしからず）&lt;/small&gt;。&lt;/p&gt;
&lt;p&gt;残念ながらカレントディレクトリーはプロセス全体で共有される情報ですので、マルチスレッドなプログラムでは頭の痛い問題が出てきてしまいますが、一番確実に回避できる方法のはずです。&lt;br /&gt;
マルチスレッドである場合を考慮したくない場合は、次に紹介する方法を検討するとよいでしょう。&lt;/p&gt;
&lt;h3 id="win32-apiのユニコード版の関数にというプレフィックスを着けた絶対パスを渡す"&gt;&lt;span class="ascii"&gt;Win32 API&lt;/span&gt;のユニコード版の関数に、&lt;code&gt;\\?\&lt;/code&gt;というプレフィックスを着けた絶対パスを渡す。&lt;/h3&gt;
&lt;p&gt;ここまでに出てきた、「&lt;span class="ascii"&gt;Windows&lt;/span&gt;の各種ファイル操作用&lt;span class="ascii"&gt;API&lt;/span&gt;」は、すべて「&lt;span class="ascii"&gt;Win32 API&lt;/span&gt;」と呼ばれる&lt;span class="ascii"&gt;Windows&lt;/span&gt;固有の&lt;span class="ascii"&gt;API&lt;/span&gt;群の一部です。&lt;br /&gt;
この「&lt;span class="ascii"&gt;Win32 API&lt;/span&gt;」に含まれる関数の多くは、「ユニコード版」とそうでないものに分かれます&lt;small&gt;（詳細は&lt;a href="https://msdn.microsoft.com/ja-jp/library/windows/desktop/dd317766(v=vs.85).aspx"&gt;&lt;span class="ascii"&gt;Conventions for Function Prototypes (Windows)&lt;/span&gt;&lt;/a&gt;をご覧ください）&lt;/small&gt;。&lt;/p&gt;
&lt;p&gt;このうち、「ユニコード版」の&lt;span class="ascii"&gt;API&lt;/span&gt;には、この制限を緩和する専用の機能が含まれています。&lt;br /&gt;
先ほども触れた&lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247%20(v=vs.85)#maxpath"&gt;&lt;span class="ascii"&gt;MSDN&lt;/span&gt;のページ&lt;/a&gt;曰く、なんと&lt;code&gt;\\?\&lt;/code&gt;という変な文字列を絶対パスの頭に着けると、最大約&lt;span class="ascii"&gt;32,767&lt;/span&gt;文字のパスまで受け付けるようになるというのです！&lt;br /&gt;
なんともアドホックな感じのする解決方法ですが、&lt;span class="ascii"&gt;Microsoft&lt;/span&gt;が言うんだから間違いありません。&lt;br /&gt;
いずれにしても&lt;span class="ascii"&gt;32,767&lt;/span&gt;文字という微妙な最大文字数ができてしまいますが、&lt;span class="ascii"&gt;UTF-16&lt;/span&gt;での&lt;span class="ascii"&gt;32,767&lt;/span&gt;文字なので、そう簡単に超えることはないでしょう。&lt;br /&gt;
いちいち絶対パスに変えて変なプレフィックスを加えないといけないという面倒くささはありますが、いちいち分割して相対パスに変換するよりは簡単なはずですので、検討する価値があります。&lt;/p&gt;
&lt;p&gt;この、&lt;code&gt;\\?\&lt;/code&gt;機能を試す場合、下記のコードを適当なファイルに貼り付けて保存し、&lt;code&gt;stack runghc file.hs&lt;/code&gt;などと実行してみてください &lt;span class="ascii"&gt;(Thanks,&lt;/span&gt; &lt;span class="citation" data-cites="matsubara0507"&gt;&lt;span class="ascii"&gt;@matsubara0507&lt;/span&gt;&lt;/span&gt;&lt;span class="ascii"&gt;!)&lt;/span&gt;。&lt;br /&gt;
&lt;code&gt;catch&lt;/code&gt;関数を使って例外を捕捉している箇所では、実際にパスが長すぎるためにエラーが発生し、&lt;code&gt;catch&lt;/code&gt;されているはずです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Control.Exception&lt;/span&gt; (catch, &lt;span class="dt"&gt;IOException&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.List&lt;/span&gt;        (replicate)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;System.Directory&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;  crDir &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getCurrentDirectory&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;    path1 &lt;span class="fu"&gt;=&lt;/span&gt; mconcat &lt;span class="fu"&gt;$&lt;/span&gt; replicate &lt;span class="dv"&gt;20&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;abcdefgh/&amp;quot;&lt;/span&gt; &lt;span class="co"&gt;-- ok&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;    path2 &lt;span class="fu"&gt;=&lt;/span&gt; mconcat &lt;span class="fu"&gt;$&lt;/span&gt; replicate &lt;span class="dv"&gt;30&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;abcdefgh/&amp;quot;&lt;/span&gt; &lt;span class="co"&gt;-- error&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;    path3 &lt;span class="fu"&gt;=&lt;/span&gt; crDir &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;/&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; path2 &lt;span class="co"&gt;-- error&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;    path4 &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\\\?\\&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; path3 &lt;span class="co"&gt;-- ok&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-14" data-line-number="14"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;path1: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show path1&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-15" data-line-number="15"&gt;  createDirectoryIfMissing &lt;span class="dt"&gt;True&lt;/span&gt; path1&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-16" data-line-number="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-17" data-line-number="17"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;path2: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show path2&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-18" data-line-number="18"&gt;  createDirectoryIfMissing &lt;span class="dt"&gt;True&lt;/span&gt; path2 &lt;span class="ot"&gt;`catch`&lt;/span&gt; (\e &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;  &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show (&lt;span class="ot"&gt;e ::&lt;/span&gt; &lt;span class="dt"&gt;IOException&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-19" data-line-number="19"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-20" data-line-number="20"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;path3: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show path3&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-21" data-line-number="21"&gt;  createDirectoryIfMissing &lt;span class="dt"&gt;True&lt;/span&gt; path3 &lt;span class="ot"&gt;`catch`&lt;/span&gt; (\e &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;  &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show (&lt;span class="ot"&gt;e ::&lt;/span&gt; &lt;span class="dt"&gt;IOException&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-22" data-line-number="22"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-23" data-line-number="23"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;path4: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show path4&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-24" data-line-number="24"&gt;  createDirectoryIfMissing &lt;span class="dt"&gt;True&lt;/span&gt; path4&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="おわりに"&gt;おわりに&lt;/h1&gt;
&lt;p&gt;さて、またしても&lt;span class="ascii"&gt;Windows&lt;/span&gt;固有の面倒な問題を紹介することとなってしまいましたが、俗世の喜び（主にゲーム）と簡単にインストールできる&lt;span class="ascii"&gt;GUI&lt;/span&gt;に慣らされてしまった私は、今後も&lt;span class="ascii"&gt;Windows&lt;/span&gt;を使い続けるつもりです。&lt;br /&gt;
いろいろ困難は尽きませんがこれからも&lt;span class="ascii"&gt;Windows&lt;/span&gt;で&lt;span class="ascii"&gt;Happy Haskell Life&lt;/span&gt;を！🏁🏁🏁&lt;/p&gt;
&lt;h1 id="参考url"&gt;参考&lt;span class="ascii"&gt;URL&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;※本文中で言及していないもののみ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://kkamegawa.hatenablog.jp/entry/2016/07/27/220014"&gt;プログラマ的に&lt;span class="ascii"&gt;Windows 10 Anniversary Update&lt;/span&gt;のうれしいところ &lt;span class="ascii"&gt;- kkamegawa&lt;/span&gt;’&lt;span class="ascii"&gt;s weblog&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://superuser.com/questions/1119883/windows-10-enable-ntfs-long-paths-policy-option-missing"&gt;&lt;span class="ascii"&gt;Windows 10&lt;/span&gt; “&lt;span class="ascii"&gt;Enable NTFS long paths policy&lt;/span&gt;” &lt;span class="ascii"&gt;option missing - Super User&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div id="post-navigation" class="row" style="margin-top: 20px;"&gt;
            &lt;div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4"&gt;
                
                &lt;i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"&gt;&lt;/i&gt;
                &lt;a href="/posts/2018/renew-haskell-antenna.html"&gt;Haskell Antenna をリニューアルしました&lt;/a&gt;
                
            &lt;/div&gt;
            &lt;div class="col-lg-2 col-md-2 col-xs-4 text-center"&gt;
                &lt;a href="/"&gt;トップに戻る&lt;/a&gt;
            &lt;/div&gt;
            &lt;div class="col-lg-3 col-md-4 col-xs-4"&gt;
                
                &lt;a href="/posts/2018/topic-request.html" style="margin-left: auto;"&gt;Haskell-jp Blogで書いてほしいネタを募集します！&lt;/a&gt;
                &lt;i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"&gt;&lt;/i&gt;
                
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/article&gt;

</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2018/02/11/185306</id><title type="text">HaskellでDiscordのBotを作る</title><updated>2018-03-09T13:45:13+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2018/02/11/185306"/><summary type="html">Discordはゲーミング向けのテキストチャットと音声通話を兼ねるプラットフォームであり、「テキストチャンネル」と「ボイスチャンネル」の二種を好きなだけ作ることができる。もちろん音声を全チャンネルに常時垂れ流すわけには行かないので、通話するにはボイスチャンネルに参加するという手順を踏む必要がある。しかし、例えば誰かがやっているゲームに混ざろうとしてボイスチャンネルに参加しても、チャンネル外のユーザーにはいかなる通知も発生しないため、気づかれないままのことがよくある。 そこで、ボイスチャンネルに参加したとき、テキストチャンネルにその旨を投稿するボットを用意すれば、気軽に通話の合図を送れる。全員に…</summary></entry><entry><id>https://kurokawh.blogspot.com/2018/03/haskell-http-clienthaskellhttp.html</id><title type="text">[haskell] http-clientライブラリを利用してHaskellでHTTPクライアント機能を実装する</title><updated>2018-03-05T09:34:57.715+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2018/03/haskell-http-clienthaskellhttp.html"/><summary type="text">Haskellでは、http-clientライブラリを用いることで、HTTPクライアント機能を簡単に実装できます。http-client以外にも何種類かライブラリがありますが、今回はhttp-client, http-client-tlsの機能と使い方をまとめておきます。

本エントリで紹介するhttp-client, http-client-tlsライブラリの機能：

単純なHTTP GETリクエスト

主要な型の説明 

Managerのカスタマイズ 

https
proxy設定 
タイムアウト値の設定

Requestのカスタマイズ

ベーシック認証 
リクエストヘッダ 

Responseの操作

ストリーミング受信 
レスポンスヘッダの参照 

エラーハンドリング 






単純なHTTP GETリクエスト
{-# LANGUAGE OverloadedStrings #</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-03-04-fix-tasty-discover-windows.html</id><title type="text">tasty-discover が Windows+日本語環境で動かなかったので直す</title><updated>2018-03-04T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-03-04-fix-tasty-discover-windows.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;tasty-discover が Windows+日本語環境で動かなかったので直す&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-03-04" itemprop="datePublished"&gt;
        Mar 4, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;おそらく少数派であろう Windows + 日本語環境の Haskeller のひげです．&lt;/p&gt;
&lt;p&gt;最近は知人のすゝめで，Haskell のテストフレームワークに &lt;a href="https://hackage.haskell.org/package/tasty"&gt;&lt;code&gt;tasty&lt;/code&gt;&lt;/a&gt; を使ってます． &lt;code&gt;tasty&lt;/code&gt; にも例に漏れず &lt;a href="http://hackage.haskell.org/package/tasty-discover"&gt;&lt;code&gt;tasty-discover&lt;/code&gt;&lt;/a&gt; というテスト用の関数を &lt;code&gt;.hs&lt;/code&gt; ファイルから集めてきてくれるツールがある． しかし，悲しいことに &lt;code&gt;tasty-discover&lt;/code&gt; がマルチバイト文字(日本語とか)を Windows で読み込むと &lt;strong&gt;いつもの&lt;/strong&gt; エラーで死んでしまう．&lt;/p&gt;
&lt;p&gt;なので，直して PR 出した． この記事はそのメモです．&lt;/p&gt;
&lt;h2 id="問題のエラー"&gt;問題のエラー&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Building test suite &amp;#39;test&amp;#39; for tasty-discover-4.1.3..
tasty-discover: test\ConfigTest.hs: hGetContents: invalid argument (invalid byte sequence)
`tasty-discover&amp;#39; failed in phase `Haskell pre-processor&amp;#39;. (Exit code: 1)
Progress: 1/2
--  While building custom Setup.hs for package tasty-discover-4.1.3 using:
      C:\Users\Hoge\AppData\Roaming\stack\setup-exe-cache\i386-windows\Cabal-simple_Z6RU0evB_2.0.1.0_ghc-8.2.2.exe --builddir=.stack-work\dist\010ee936 build lib:tasty-discover exe:tasty-discover test:test --ghc-options &amp;quot; -ddump-hi -ddump-to-file -fdiagnostics-color=always&amp;quot;
    Process exited with code: ExitFailure 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;hGetContents: invalid argument (invalid byte sequence)&lt;/code&gt; は 日本語 Windows Haskeller なら親の顔より良く見るエラーメッセージですね(そんなことは無い)． このエラーは &lt;code&gt;hGetContents&lt;/code&gt; で読み込もうとしているファイルの文字コードが，&lt;code&gt;hGetContents&lt;/code&gt; で設定されている文字コードと違うために起きている(&lt;code&gt;hGetContents&lt;/code&gt; 関数は，例えば &lt;code&gt;readFile&lt;/code&gt; 関数などで呼び出されている)．&lt;/p&gt;
&lt;h2 id="対処法"&gt;対処法&lt;/h2&gt;
&lt;p&gt;日本語 Windows Haskeller 筆頭の igrep 氏が Haskell-jp Blog に投稿してくれてる．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://haskell.jp/blog/posts/2017/windows-gotchas.html"&gt;WindowsでHaskellを扱う時によく遭遇するエラーと対処法 - Haskell-jp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今回は(孫プロセスとして読んでるせいか)「それでもダメな場合」に当たる． つまり，場当たり的な解決方法(&lt;code&gt;chcp 65001&lt;/code&gt; と打つとか)ではダメで，プログラムを修正するしかない．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;神な igrep 氏は，この場合の解決策も書いておいてくれた． この &lt;a href="https://github.com/haskell/haddock/pull/566"&gt;PR&lt;/a&gt; を参考にして書き換えてやればよい．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tasty-discover&lt;/code&gt; も&lt;a href="https://github.com/lwm/tasty-discover/pull/138/files"&gt;こんな感じに書き加えた&lt;/a&gt;．&lt;/p&gt;
&lt;h2 id="pr-を出す"&gt;PR を出す&lt;/h2&gt;
&lt;p&gt;修正自体は1時間ほどで終わり(移動中の新幹線の中で直した)，これでテストを実行できるようになったので PR を出さずに満足してしまった(あるある)． 半月ほどほっといてたら，同じケースで困った知り合いに &lt;a href="https://github.com/lwm/tasty-discover/issues/135"&gt;Issue&lt;/a&gt; を出されてしまった(笑)&lt;/p&gt;
&lt;p&gt;しょうがないので PR を出そうとしたら，「Windows は良く分からないから，ぜひ Windows 環境用の自動テストも欲しい！」と&lt;a href="https://github.com/lwm/tasty-discover/issues/127"&gt;作者に言われてしまった&lt;/a&gt;(「時間があればやって」とね)．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.appveyor.com/"&gt;AppVeyor&lt;/a&gt; と言うのを使えばいいみたい． 調べたらサクッとできそうなので，やってみた．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.snoyman.com/blog/2016/08/appveyor-haskell-windows-ci"&gt;Using AppVeyor for Haskell+Windows CI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;記事にある設定ファイルをそのままコピペしてやってみたが，問題がふたつあった． ひとつ目は，&lt;code&gt;tasty-discover&lt;/code&gt; のテスト自体に &lt;code&gt;tasty-discover&lt;/code&gt; を使っている点だ． 最初に &lt;code&gt;stack test&lt;/code&gt; を実行するときにはまだ &lt;code&gt;tasty-discover&lt;/code&gt; はインストールされてないのでテストが落ちてしまう．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[2 of 2] Compiling Paths_tasty_discover ( .stack-work\dist\010ee936\build\tasty-discover\autogen\Paths_tasty_discover.hs, .stack-work\dist\010ee936\build\tasty-discover\tasty-discover-tmp\Paths_tasty_discover.o )
Linking .stack-work\dist\010ee936\build\tasty-discover\tasty-discover.exe ...
Preprocessing test suite &amp;#39;test&amp;#39; for tasty-discover-4.1.3..
Building test suite &amp;#39;test&amp;#39; for tasty-discover-4.1.3..
ghc.EXE: could not execute: tasty-discover&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;なので，&lt;code&gt;stack test&lt;/code&gt; する前に &lt;code&gt;stack install&lt;/code&gt; することにした．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;ふたつ目は，そもそも WIndows のビルドが落ちる点． &lt;code&gt;System.FilePath&lt;/code&gt; に関するバグだったので，&lt;a href="https://github.com/lwm/tasty-discover/pull/136/files#diff-383b12983902facd1ce205458e1061b6"&gt;サクッと直した&lt;/a&gt;． Windows のテストに関する &lt;a href="https://github.com/lwm/tasty-discover/pull/136"&gt;PR&lt;/a&gt; もマージされたので，本命の &lt;a href="https://github.com/lwm/tasty-discover/pull/138"&gt;PR&lt;/a&gt; も出した(これもマージされた)．&lt;/p&gt;
&lt;h2 id="今回の問題をテストする"&gt;今回の問題をテストする(？)&lt;/h2&gt;
&lt;p&gt;今回の問題のテストも欲しいと言われた． &lt;code&gt;tasty-discover&lt;/code&gt; のテスト自体が &lt;code&gt;tasty-discover&lt;/code&gt; を使うため，ユニットテストとして表現できない． &lt;code&gt;stack test&lt;/code&gt; そのものが落ちるか落ちないかのテストはできるが，それはなんか違うなぁと思い，結局コミットはしていない．&lt;/p&gt;
&lt;p&gt;ただし，いちおう AppVeyor で&lt;a href="https://ci.appveyor.com/project/matsubara0507/tasty-discover/build/1.0.9"&gt;再現できるようにはした&lt;/a&gt;． AppVeyor はデフォルトだと日本語環境になっていない(即ち Shift-JIS じゃない)ため落ちない． なので，以下を参考にして日本語環境にして実行した．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/appveyor/ci/issues/846"&gt;Support a different code page · Issue #846 · appveyor/ci&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;init:
- ps: Set-WinSystemLocale ja-JP
- ps: Start-Sleep -s 5
- ps: Restart-Computer&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;というのを &lt;code&gt;appveyor.yml&lt;/code&gt; に書き加えるだけで良い．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;なんか &lt;a href="https://github.com/lwm/tasty-discover/issues/139"&gt;Push 権限を貰った&lt;/a&gt;． こういうこともあるんですね(OSS歴が浅いので驚いた)．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/12/23/082635</id><title type="text">猫でもわかる rkt + Kubernetes</title><updated>2018-02-28T00:36:58+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/12/23/082635"/><summary type="html">このエントリは Kubernetes Advent Calendar 2017 の 23 日目の記事です。ちなみに昨日は takezaki さんの「GCBを利用したContinuous Delivery環境」でした。 LT で使用したスライド 先日、市ヶ谷Geek★Night #16 の 10 分 LT 枠で、CoreOS 社によるコンテナ実装 rkt とその Kubernetes 連携について発表してきました。今回のエントリはこの LT の内容を補足しつつ、実際に手を動かして rkt を試せるような構成にしてあります。 Hello, rkt! rkt は、Docker の対抗馬として Cor…</summary></entry><entry><id>https://kurokawh.blogspot.com/2018/02/haskell-stack-install-cryptoniteno-such.html</id><title type="text">[haskell] stack install cryptoniteがno such instruction: `rdrand %r8'エラーで失敗する問題の対処方法</title><updated>2018-02-25T15:34:07.378+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2018/02/haskell-stack-install-cryptoniteno-such.html"/><summary type="text">手許の環境（mac）で、cryptoniteライブラリのビルドがエラーになる問題が発生したが、ネットの情報を元に解決できたので、その症状と手順をblogに残しておく。



エラーの症状：
stack install cryptoniteで以下のようなエラーが発生。
% stack install cryptonite
--  While building custom Setup.hs for package cryptonite-0.24 using:
      /Users/xxx/.stack/setup-exe-cache/x86_64-osx/Cabal-simple_mPHDZzAJ_2.0.1.0_ghc-8.2.2 --builddir=.stack-work/dist/x86_64-osx/Cabal-2.0.1.0 build --ghc-options " </summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/12/25/%E3%81%AA%E3%81%9C_Haskell_%E3%81%8C%E5%A5%BD%E3%81%8D%E3%81%AA%E3%81%AE%E3%81%8B</id><title type="text">なぜ Haskell が好きなのか</title><updated>2018-02-25T14:53:18+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/12/25/%E3%81%AA%E3%81%9C_Haskell_%E3%81%8C%E5%A5%BD%E3%81%8D%E3%81%AA%E3%81%AE%E3%81%8B"/><summary type="html">自分は Haskell が好きで休日は Haskell を書いています。そういうことを言うと関数型が好きなんですねと言われるのですが、Haskell のよさはそこじゃないと感じているので書き起こそうかと、筆を執りました。 というわけで、この記事は技術的文書というよりもお話です。Haskell を知らない人向けです。 この記事は Haskell Advent Calendar 2017 その3の6日めの記事です。6日が過ぎても担当のいない日だったため担当します。 関数型プログラミングだから Haskell が好きというわけではない まず、「Haskell というと手続き型とは全然違う関数型なんで…</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-02-22-fun-of-extensible-3.html</id><title type="text">拡張可能タングルでDo記法レスプログラミング♪ (Haskell)</title><updated>2018-02-22T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-02-22-fun-of-extensible-3.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;拡張可能タングルでDo記法レスプログラミング♪ (Haskell)&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-02-22" itemprop="datePublished"&gt;
        Feb 22, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/extensible-package.html"&gt;extensible-package&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;「&lt;a href="https://hackage.haskell.org/package/extensible"&gt;&lt;code&gt;extensible&lt;/code&gt;&lt;/a&gt; パッケージの楽しみ その３」です．&lt;/p&gt;
&lt;p&gt;拡張可能レコードやら Extensible Effect やら，Haskell の Extensible なものを全て統一された仕組みで提供する化け物パッケージ &lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1"&gt;&lt;code&gt;extensible&lt;/code&gt;&lt;/a&gt; について，割とドキュメントには無い(？)ネタを書いておくシリーズ第三弾です． ぼく自身は作者ではないし，間違っているかもなのでこの記事を完全には当てにしないでください．&lt;/p&gt;
&lt;p&gt;また，現在の最新バージョンは 0.4.7.1 です(そのバージョンでハナシをしてる)．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="/posts/2017-11-28-fun-of-extensible-1.html"&gt;前々回&lt;/a&gt;は拡張可能レコードの拡縮の話を，&lt;a href="/posts/2018-01-31-fun-of-extensible-2.html"&gt;前回&lt;/a&gt;は拡張可能直和型(バリアント)を引数に取る関数の話を書きました．&lt;/p&gt;
&lt;p&gt;今回は &lt;strong&gt;拡張可能タングル&lt;/strong&gt; で遊んでみます． 今回の Haskell コードは基本的に&lt;a href="https://gist.github.com/matsubara0507/be20aa514016c991f19f2e604409cd96"&gt;コレ&lt;/a&gt;．&lt;/p&gt;
&lt;h2 id="拡張可能タングル"&gt;拡張可能タングル&lt;/h2&gt;
&lt;p&gt;作者さんの拡張可能タングルについての記事があり，非常に分かりやすいです．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://fumieval.hatenablog.com/entry/2016/12/18/181540"&gt;波打たせるものの正体(エクステンシブル・タングル) - モナドとわたしとコモナド&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拡張可能タングルを用いれば，文脈付き(&lt;code&gt;IO&lt;/code&gt; などの &lt;code&gt;Monad&lt;/code&gt; 型クラスのインスタンス)で拡張可能レコードを生成し，更にフィールド間で依存関係を持つ際に，型クラスを用いて各フィールドごとに振る舞いを記述できるようになる． まぁこのヒトコトでは伝わらないですよね．&lt;/p&gt;
&lt;p&gt;百聞は一見に如かず．例えば&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Rec&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="dt"&gt;Fields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Fields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;    &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;hoge1&amp;quot; &amp;gt;: String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;     , &lt;span class="st"&gt;&amp;quot;hoge2&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;     , &lt;span class="st"&gt;&amp;quot;hoge3&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;     ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;&lt;span class="ot"&gt;makeRec ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Rec&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;makeRec &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;  hoge1 &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getLine&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;  hoge3 &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; randomRIO (&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="fu"&gt;*&lt;/span&gt; length hoge1)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;  pure&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;     &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge1 &lt;span class="fu"&gt;@=&lt;/span&gt; hoge1&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" data-line-number="14"&gt;    &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge2 &lt;span class="fu"&gt;@=&lt;/span&gt; (length hoge1 &lt;span class="fu"&gt;&amp;lt;=&lt;/span&gt; hoge3)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" data-line-number="15"&gt;    &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge3 &lt;span class="fu"&gt;@=&lt;/span&gt; hoge3&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" data-line-number="16"&gt;    &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; emptyRecord&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;というような関数があったとする． これを拡張可能タングルを使って書き直すと次のようになります．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;makeRec ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Rec&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;makeRec &lt;span class="fu"&gt;=&lt;/span&gt; runTangles tangles (wrench emptyRecord)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; &lt;span class="dt"&gt;Identity&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;&lt;span class="ot"&gt;tangles ::&lt;/span&gt; &lt;span class="dt"&gt;Comp&lt;/span&gt; (&lt;span class="dt"&gt;TangleT&lt;/span&gt; &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="dt"&gt;Fields&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt;) &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="fu"&gt;:*&lt;/span&gt; &lt;span class="dt"&gt;Fields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;tangles &lt;span class="fu"&gt;=&lt;/span&gt; htabulateFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="dt"&gt;MakeRec&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;  \m &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Comp&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; pure &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; make m&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;MakeRec&lt;/span&gt; kv &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;&lt;span class="ot"&gt;  make ::&lt;/span&gt; proxy kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TangleT&lt;/span&gt; &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="dt"&gt;Fields&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;AssocValue&lt;/span&gt; kv)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeRec&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;hoge1&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-14" data-line-number="14"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; lift getLine&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-16" data-line-number="16"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeRec&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;hoge2&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-17" data-line-number="17"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; (&lt;span class="fu"&gt;&amp;lt;=&lt;/span&gt;) &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; (length &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;hoge1) &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;hoge3&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-18" data-line-number="18"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-19" data-line-number="19"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeRec&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;hoge3&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-20" data-line-number="20"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-21" data-line-number="21"&gt;    ml &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; length &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;hoge1&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-22" data-line-number="22"&gt;    lift &lt;span class="fu"&gt;$&lt;/span&gt; randomRIO (&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="fu"&gt;*&lt;/span&gt; ml)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;コード量そのものは倍近くなっている． しかし，フィールドの構築方法ごとにインスタンスメソッドとして切り分けることが出来ている． しかも，&lt;strong&gt;摩訶不思議な &lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Tangle.html#v:lasso"&gt;&lt;code&gt;lasso&lt;/code&gt;&lt;/a&gt; 関数により依存関係も勝手に解決してくれる&lt;/strong&gt; ． もちろん，フィールドのインスタンスが足りないときは，足りないというコンパイルエラーになるよ．&lt;/p&gt;
&lt;h2 id="do記法レスプログラミング"&gt;Do記法レスプログラミング&lt;/h2&gt;
&lt;p&gt;Haskell はなんらかの作用付きの振る舞いは次のように &lt;code&gt;Monad&lt;/code&gt; と &lt;code&gt;do&lt;/code&gt; 記法を用いて書くのが一般的だ． しかし，便利な Do 記法に甘えて無駄に長い，数十行もある Do 式を書いたことは無いだろうか？ たしかに(関数合成だけで記述するより)読みやすいが，なんかこう…ちがうじゃないですか！？&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;そこで，先述した拡張可能タングルを用いて長いDo式をフィールドごとに切り分けてみよう． 例題として次のようなログ(っぽいなにか)を読み込む関数を考える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Log&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="dt"&gt;LogFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;LogFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;    &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;path&amp;quot;    &amp;gt;: FilePath&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;     , &lt;span class="st"&gt;&amp;quot;time&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Time&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;     , &lt;span class="st"&gt;&amp;quot;code&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;     , &lt;span class="st"&gt;&amp;quot;message&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;     ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Time&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" data-line-number="11"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;LogCsv&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="dt"&gt;CsvFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-13" data-line-number="13"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;CsvFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-14" data-line-number="14"&gt;    &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;time&amp;quot;    &amp;gt;: Time&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-15" data-line-number="15"&gt;     , &lt;span class="st"&gt;&amp;quot;info&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;LB.ByteString&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-16" data-line-number="16"&gt;     ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-17" data-line-number="17"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-18" data-line-number="18"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-19" data-line-number="19"&gt;    &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;code&amp;quot;    &amp;gt;: Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-20" data-line-number="20"&gt;     , &lt;span class="st"&gt;&amp;quot;message&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-21" data-line-number="21"&gt;     ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-22" data-line-number="22"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-23" data-line-number="23"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Eff&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-24" data-line-number="24"&gt;    &lt;span class="ch"&gt;&amp;#39;[ EitherDef String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-25" data-line-number="25"&gt;     , &lt;span class="st"&gt;&amp;quot;IO&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-26" data-line-number="26"&gt;     ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-27" data-line-number="27"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-28" data-line-number="28"&gt;&lt;span class="ot"&gt;runEIO ::&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;Either&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; a)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-29" data-line-number="29"&gt;runEIO &lt;span class="fu"&gt;=&lt;/span&gt; retractEff &lt;span class="fu"&gt;.&lt;/span&gt; runEitherDef&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-30" data-line-number="30"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-31" data-line-number="31"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-32" data-line-number="32"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-33" data-line-number="33"&gt;  result &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; runEIO &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-34" data-line-number="34"&gt;    (path&lt;span class="fu"&gt;:&lt;/span&gt;_) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; liftIO getArgs&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-35" data-line-number="35"&gt;    file &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt;  liftIO (LB.readFile path)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-36" data-line-number="36"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-37" data-line-number="37"&gt;      csv &lt;span class="fu"&gt;=&lt;/span&gt; mconcat [header, &lt;span class="st"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;, file]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-38" data-line-number="38"&gt;    (_, logs) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; either throwError pure (decodeByName csv)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; (&lt;span class="dt"&gt;Header&lt;/span&gt;, &lt;span class="dt"&gt;LogCsv&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-39" data-line-number="39"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-40" data-line-number="40"&gt;      log&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; V.head logs&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-41" data-line-number="41"&gt;    info &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; either throwError pure (eitherDecode &lt;span class="fu"&gt;$&lt;/span&gt; log&amp;#39; &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;info)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-42" data-line-number="42"&gt;    pure &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-43" data-line-number="43"&gt;      &lt;span class="fu"&gt;#&lt;/span&gt;path &lt;span class="fu"&gt;@=&lt;/span&gt; path &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;time &lt;span class="fu"&gt;@=&lt;/span&gt; (log&amp;#39; &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;time) &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; info&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-44" data-line-number="44"&gt;  either error print result&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-45" data-line-number="45"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-46" data-line-number="46"&gt;&lt;span class="ot"&gt;header ::&lt;/span&gt; &lt;span class="dt"&gt;LB.ByteString&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-47" data-line-number="47"&gt;header &lt;span class="fu"&gt;=&lt;/span&gt; LB.intercalate &lt;span class="st"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; fmap fromString &lt;span class="fu"&gt;$&lt;/span&gt; henumerateFor&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-48" data-line-number="48"&gt;  (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; (&lt;span class="dt"&gt;KeyValue&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-49" data-line-number="49"&gt;  (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="dt"&gt;CsvFields&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-50" data-line-number="50"&gt;  ((&lt;span class="fu"&gt;:&lt;/span&gt;) &lt;span class="fu"&gt;.&lt;/span&gt; symbolVal &lt;span class="fu"&gt;.&lt;/span&gt; proxyAssocKey)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-51" data-line-number="51"&gt;  []&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このメイン関数は次のような CSV をログデータとして読み込んで，2行目の JSON もパースしたうえで，ひとつの拡張可能レコードとして吐き出す．&lt;/p&gt;
&lt;pre class="csv"&gt;&lt;code&gt;2018-02-23T03:10:00,&amp;quot;{&amp;quot;&amp;quot;code&amp;quot;&amp;quot;:123,&amp;quot;&amp;quot;message&amp;quot;&amp;quot;:&amp;quot;&amp;quot;hello&amp;quot;&amp;quot;}&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正直，この例だと大した長さではないので切り分けるメリットはなーーんにもないんですけど．&lt;/p&gt;
&lt;h3 id="stack-script-とカスタムスナップショット"&gt;&lt;code&gt;stack script&lt;/code&gt; とカスタムスナップショット&lt;/h3&gt;
&lt;p&gt;その前に，このメイン関数をどうやって実行するか． この程度のモノをいちいち stack プロジェクトにしていてはスペースの無駄なので，&lt;code&gt;stack script&lt;/code&gt; を使う．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stack script&lt;/code&gt; コマンド知っていますか？ &lt;code&gt;stack runghc&lt;/code&gt; と基本的には一緒なのだが，違いは2点(たぶん)．&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;resolver の指定が必須 (たしか &lt;code&gt;runghc&lt;/code&gt; は指定しなければプロジェクトのを使うはず)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;パッケージを引数で指定する必要が無い&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(2)がすごいよね． &lt;code&gt;runghc&lt;/code&gt; の場合，使ってるパッケージを &lt;code&gt;--package hoge&lt;/code&gt; と一つずつ指定しなければならない(今回は&lt;a href="https://gist.github.com/matsubara0507/be20aa514016c991f19f2e604409cd96#file-fun-of-tangle-hs-L13"&gt;使ってるパッケージが多い&lt;/a&gt;ので尚更大変)が，&lt;code&gt;script&lt;/code&gt; なら指定した resolver から自動で解決してくれる．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;ただ問題がひとつ． 今回は &lt;a href="https://hackage.haskell.org/package/aeson"&gt;&lt;code&gt;aeson&lt;/code&gt;&lt;/a&gt; や &lt;a href="https://hackage.haskell.org/package/cassava"&gt;&lt;code&gt;cassava&lt;/code&gt;&lt;/a&gt; の型クラスのインスタンスを拡張可能レコードで使いたいので，Stackage に登録していない &lt;a href="https://github.com/matsubara0507/extensible-instances"&gt;&lt;code&gt;matsubara0507/extensible-instances&lt;/code&gt;&lt;/a&gt; にも依存したい． そこで，カスタムスナップショットだ． 日本語で詳しくは下記のサイトにまとまっていた．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://haskell.e-bigmoon.com/posts/2017-12-23-stack161.html"&gt;カスタムスナップショットの紹介&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここには書いてないが，カスタムスナップショットは &lt;code&gt;stack script&lt;/code&gt; にも使える． 例えば今回は次のようなカスタムスナップショットを作った．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="fu"&gt;resolver:&lt;/span&gt;&lt;span class="at"&gt; lts-10.6&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; matsubara0507&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;span class="fu"&gt;packages:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;git:&lt;/span&gt;&lt;span class="at"&gt; https://github.com/matsubara0507/extensible-instances.git&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;  &lt;span class="fu"&gt;commit:&lt;/span&gt;&lt;span class="at"&gt; 8dabe7a3dd9cf162e2d81e4ca16dbe73b98a3809&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これを &lt;code&gt;snapshot.yaml&lt;/code&gt; とし，例題のコードを &lt;code&gt;fun-of-tangle.hs&lt;/code&gt; とすると次のように実行できる&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;$ &lt;span class="fu"&gt;cat&lt;/span&gt; sampleLog.csv&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="ex"&gt;2018-02-23T03&lt;/span&gt;:10:00,&lt;span class="st"&gt;&amp;quot;{&amp;quot;&amp;quot;code&amp;quot;&amp;quot;:123,&amp;quot;&amp;quot;message&amp;quot;&amp;quot;:&amp;quot;&amp;quot;hello&amp;quot;&amp;quot;}&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;$ &lt;span class="ex"&gt;stack&lt;/span&gt; script --resolver ./snapshot.yaml -- fun-of-tangle.hs sampleLog.csv&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;&lt;span class="ex"&gt;Using&lt;/span&gt; resolver: custom: ./snapshot.yaml specified on command line&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;&lt;span class="ex"&gt;path&lt;/span&gt; @= &lt;span class="st"&gt;&amp;quot;sampleLog.csv&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;: time @= &lt;span class="st"&gt;&amp;quot;2018-02-23T03:10:00&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;: code @= 123 &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;: message @= &lt;span class="st"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;: nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="ヘッダの生成"&gt;ヘッダの生成&lt;/h3&gt;
&lt;p&gt;CSV の読み込みには &lt;code&gt;cassava&lt;/code&gt; というパッケージを使っている． このパッケージには &lt;code&gt;FromRecord&lt;/code&gt; と &lt;code&gt;FromNamedRecord&lt;/code&gt; 型クラスがある． 前者は前から順に勝手に取っていくのに対し，後者はフィールド名と CSV の列名を対応させて取ってきてくれる．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cassava&lt;/code&gt; 系の拡張可能レコードのインスタンスを書いてるときは &lt;code&gt;extensible&lt;/code&gt; 力がまだ低く，フィールドからインデックスをとっていくる方法が分からなかった． そのため &lt;code&gt;FromRecord&lt;/code&gt; 型クラスのインスタンスが &lt;code&gt;extensible-instances&lt;/code&gt; にはない(何故かついこの前，&lt;a href="https://github.com/fumieval/extensible/commit/074210e76ed5bd35f62d452f66c940a40d821534"&gt;本家へコミット&lt;/a&gt;されたけど)．&lt;/p&gt;
&lt;p&gt;なので，型から列名のヘッダーを生成してしまおう，というのが &lt;code&gt;header&lt;/code&gt; 関数．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="ot"&gt;header ::&lt;/span&gt; &lt;span class="dt"&gt;LB.ByteString&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;header &lt;span class="fu"&gt;=&lt;/span&gt; LB.intercalate &lt;span class="st"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; fmap fromString &lt;span class="fu"&gt;$&lt;/span&gt; henumerateFor&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;  (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; (&lt;span class="dt"&gt;KeyValue&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;  (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="dt"&gt;CsvFields&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;  ((&lt;span class="fu"&gt;:&lt;/span&gt;) &lt;span class="fu"&gt;.&lt;/span&gt; symbolVal &lt;span class="fu"&gt;.&lt;/span&gt; proxyAssocKey)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" data-line-number="6"&gt;  []&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Proxy (KeyValue KnownSymbol Show)&lt;/code&gt; ってのが悲しいですよね…(&lt;code&gt;Show&lt;/code&gt; は全く無意味)． キー側だけ型クラスを指定する方法は無いような気がしたんだよなぁ．&lt;/p&gt;
&lt;h2 id="分割しましょう"&gt;分割しましょう&lt;/h2&gt;
&lt;p&gt;では本題．&lt;/p&gt;
&lt;p&gt;まずは型クラスを考えよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; kv &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  make ::&lt;/span&gt; proxy kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TangleT&lt;/span&gt; &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="dt"&gt;LogFields&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; (&lt;span class="dt"&gt;AssocValue&lt;/span&gt; kv)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;試しに，&lt;code&gt;&amp;quot;path&amp;quot; &amp;gt;: FilePath&lt;/code&gt; のインスタンスを書いてみる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;path&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; FilePath) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; lift &lt;span class="fu"&gt;$&lt;/span&gt; liftIO getArgs &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; \&lt;span class="kw"&gt;case&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;    (path &lt;span class="fu"&gt;:&lt;/span&gt; _) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; pure path&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;    _          &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; throwError &lt;span class="st"&gt;&amp;quot;please path.&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;他のはできるだろうか？ 元のメイン関数を見ればわかると思うが，たぶん無理だと思う． 他のフィールドは &lt;code&gt;log'&lt;/code&gt; 変数に保存した中間状態を共有するからだ．&lt;/p&gt;
&lt;h3 id="中間状態をどうするか"&gt;中間状態をどうするか&lt;/h3&gt;
&lt;p&gt;他にもっといい手はあるかもしれないが，今回は &lt;strong&gt;レコードを中間状態も加えて拡張する&lt;/strong&gt; ことにする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;MidFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[&amp;quot;log&amp;quot; &amp;gt;: LogCsv &amp;#39;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;info&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt;] &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="dt"&gt;LogFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; kv &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;span class="ot"&gt;  make ::&lt;/span&gt; proxy kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TangleT&lt;/span&gt; &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="dt"&gt;MidFields&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; (&lt;span class="dt"&gt;AssocValue&lt;/span&gt; kv)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Product.html#t:-43--43-"&gt;&lt;code&gt;(++)&lt;/code&gt;&lt;/a&gt; は型レベルリストの連結演算子だ． &lt;code&gt;'[&amp;quot;log&amp;quot; &amp;gt;: LogCsv ': &amp;quot;info&amp;quot; &amp;gt;: Info]&lt;/code&gt; が追加する中間状態にあたる． これを最後にどうやって外すかと言うと，実は簡単で &lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Inclusion.html#v:shrink"&gt;&lt;code&gt;shrink&lt;/code&gt;&lt;/a&gt; 関数で縮小してやればよい．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="ot"&gt;makeLog ::&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt; &lt;span class="dt"&gt;Log&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;makeLog &lt;span class="fu"&gt;=&lt;/span&gt; shrink &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; runTangles tangles (wrench emptyRecord)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;&lt;span class="ot"&gt;tangles ::&lt;/span&gt; &lt;span class="dt"&gt;Comp&lt;/span&gt; (&lt;span class="dt"&gt;TangleT&lt;/span&gt; &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="dt"&gt;MidFields&lt;/span&gt; &lt;span class="dt"&gt;EIO&lt;/span&gt;) &lt;span class="dt"&gt;FieldI&lt;/span&gt; &lt;span class="fu"&gt;:*&lt;/span&gt; &lt;span class="dt"&gt;MidFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;tangles &lt;span class="fu"&gt;=&lt;/span&gt; htabulateFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" data-line-number="6"&gt;  \m &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Comp&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; pure &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; make m&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;中間状態のインスタンス定義してしまう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;log&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;LogCsv&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;    file &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lift &lt;span class="fu"&gt;.&lt;/span&gt; liftIO &lt;span class="fu"&gt;.&lt;/span&gt; LB.readFile &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;path&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;    (_, log&amp;#39;) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lift &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" data-line-number="5"&gt;      either throwError pure (decodeByName &lt;span class="fu"&gt;$&lt;/span&gt; mconcat [header, &lt;span class="st"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;, file])&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" data-line-number="6"&gt;    pure &lt;span class="fu"&gt;$&lt;/span&gt; V.head log&amp;#39;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-8" data-line-number="8"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;info&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-9" data-line-number="9"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-10" data-line-number="10"&gt;    log&amp;#39; &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;log&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-11" data-line-number="11"&gt;    lift &lt;span class="fu"&gt;$&lt;/span&gt; either throwError pure (eitherDecode &lt;span class="fu"&gt;$&lt;/span&gt; log&amp;#39; &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;info)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;うん…まぁ…読みやすさのためにね，多少は &lt;code&gt;do&lt;/code&gt; を残しましたよ(タイトル詐欺)．&lt;/p&gt;
&lt;h3 id="残りは簡単"&gt;残りは簡単&lt;/h3&gt;
&lt;p&gt;あとは，フィールドを取り出すだけなので簡単．&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;time&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Time&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; view &lt;span class="fu"&gt;#&lt;/span&gt;time &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;log&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;code&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; view &lt;span class="fu"&gt;#&lt;/span&gt;code &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;info&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" data-line-number="7"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;MakeLog&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;message&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" data-line-number="8"&gt;  make _ &lt;span class="fu"&gt;=&lt;/span&gt; view &lt;span class="fu"&gt;#&lt;/span&gt;message &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; lasso &lt;span class="fu"&gt;#&lt;/span&gt;info&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;メイン関数はこんな感じ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; either error print &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; runEIO makeLog&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;わぁすっきり(メイン関数は)．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;これぐらいの規模だとメリットが皆無なんですが，もっと CSV の列数が多くなったらどうでしょう？ うーーーん，あんまり変わらないかも(笑) まぁ，少なくとも面白い(不思議な)プログラミングが出来るのは確かです．&lt;/p&gt;
&lt;p&gt;僕は試しにこの方法で，&lt;a href="https://github.com/matsubara0507/source-gh-pages/blob/tangle/app/Rules.hs"&gt;このサイトの Hakyll コード&lt;/a&gt;を切り刻んでみました．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-02-21-add-feats-mysite-2018.html</id><title type="text">このサイトに機能を追加 2018</title><updated>2018-02-21T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-02-21-add-feats-mysite-2018.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;このサイトに機能を追加 2018&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-02-21" itemprop="datePublished"&gt;
        Feb 21, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/site.html"&gt;site&lt;/a&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;このサイトは Haskell の静的サイトジェネレーター &lt;a href="https://jaspervdj.be/hakyll/"&gt;Hakyll&lt;/a&gt; を使っています．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/posts/2016-07-07-started-github-pages.html"&gt;GitHub Pages はじめました - ひげメモ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定期的に自分のサイトをいじってるんだけど，久々に本腰入れて改良した． このサイトを作り始めたころと違い「Haskell力」が段違いなのでサクサクできたぜ．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;追加したのは以下の7つ．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;リンクチェッカー&lt;/li&gt;
&lt;li&gt;LTS 10 に対応&lt;/li&gt;
&lt;li&gt;可変なキーバリューストアを aeson で&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post/&lt;/code&gt; 以下のマークダウン置き場を変更&lt;/li&gt;
&lt;li&gt;フィードの生成&lt;/li&gt;
&lt;li&gt;ページネーションの追加&lt;/li&gt;
&lt;li&gt;タグの追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最初のリンクチェッカーは &lt;code&gt;stack test&lt;/code&gt; で行うのだが，追加したのは実は結構前． 記事にしてなかったので書き足しておく．&lt;/p&gt;
&lt;h2 id="リンクチェッカー"&gt;リンクチェッカー&lt;/h2&gt;
&lt;p&gt;記事内にあるリンクを実際に ping して，リンクが有効かを検査するテストを作った． もちろん Haskell で書いて &lt;code&gt;stack test&lt;/code&gt; で実行できるようにした． コードはこんな感じ&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Main&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Prelude&lt;/span&gt;                   &lt;span class="kw"&gt;hiding&lt;/span&gt; (&lt;span class="dt"&gt;FilePath&lt;/span&gt;, null)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.List&lt;/span&gt;                 (nub, sort)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Maybe&lt;/span&gt;                (fromMaybe)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Text&lt;/span&gt;                 (&lt;span class="dt"&gt;Text&lt;/span&gt;, isPrefixOf, null, unpack)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Traversable&lt;/span&gt;          (traverse)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Network.HTTP.Client&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Network.HTTP.Client.TLS&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Network.HTTP.Types.Status&lt;/span&gt; (&lt;span class="dt"&gt;Status&lt;/span&gt;, ok200)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Shelly&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Test.Hspec&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" data-line-number="14"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Text.HTML.Scalpel.Core&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" data-line-number="16"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-17" data-line-number="17"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-18" data-line-number="18"&gt;  urls &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; fmap mconcat &lt;span class="fu"&gt;.&lt;/span&gt; shelly &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-19" data-line-number="19"&gt;    run_ &lt;span class="st"&gt;&amp;quot;stack&amp;quot;&lt;/span&gt; [&lt;span class="st"&gt;&amp;quot;exec&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;--&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;site&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;build&amp;quot;&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-20" data-line-number="20"&gt;    files &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; ls &lt;span class="st"&gt;&amp;quot;_site/posts&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-21" data-line-number="21"&gt;    traverse (fmap scrapeLinks &lt;span class="fu"&gt;.&lt;/span&gt; readfile) files&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-22" data-line-number="22"&gt;  hspec &lt;span class="fu"&gt;.&lt;/span&gt; mapM_ spec &lt;span class="fu"&gt;.&lt;/span&gt; nub &lt;span class="fu"&gt;.&lt;/span&gt; sort &lt;span class="fu"&gt;$&lt;/span&gt; filter check urls&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-23" data-line-number="23"&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-24" data-line-number="24"&gt;  check url &lt;span class="fu"&gt;=&lt;/span&gt; not &lt;span class="fu"&gt;.&lt;/span&gt; or &lt;span class="fu"&gt;.&lt;/span&gt; (&lt;span class="fu"&gt;:&lt;/span&gt;) (null url) &lt;span class="fu"&gt;$&lt;/span&gt; fmap&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-25" data-line-number="25"&gt;    (&lt;span class="ot"&gt;`isPrefixOf`&lt;/span&gt; url)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-26" data-line-number="26"&gt;    [&lt;span class="st"&gt;&amp;quot;https://matsubara0507.github.io&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;../&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;#&amp;quot;&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-27" data-line-number="27"&gt;  spec url &lt;span class="fu"&gt;=&lt;/span&gt; it (unpack url) &lt;span class="fu"&gt;$&lt;/span&gt; linkStatus url &lt;span class="ot"&gt;`shouldReturn`&lt;/span&gt; ok200&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-28" data-line-number="28"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-29" data-line-number="29"&gt;&lt;span class="ot"&gt;scrapeLinks ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Text&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-30" data-line-number="30"&gt;scrapeLinks txt &lt;span class="fu"&gt;=&lt;/span&gt; fromMaybe [] &lt;span class="fu"&gt;$&lt;/span&gt; scrapeStringLike txt scraper&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-31" data-line-number="31"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt; scraper &lt;span class="fu"&gt;=&lt;/span&gt; attrs &lt;span class="st"&gt;&amp;quot;href&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-32" data-line-number="32"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-33" data-line-number="33"&gt;&lt;span class="ot"&gt;linkStatus ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Status&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-34" data-line-number="34"&gt;linkStatus url &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-35" data-line-number="35"&gt;  manager &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; newManager tlsManagerSettings&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-36" data-line-number="36"&gt;  request &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; parseRequest &lt;span class="fu"&gt;$&lt;/span&gt; unpack url&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-37" data-line-number="37"&gt;  responseStatus&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-38" data-line-number="38"&gt;    &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; httpNoBody (request { requestHeaders &lt;span class="fu"&gt;=&lt;/span&gt; [(&lt;span class="st"&gt;&amp;quot;User-Agent&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;)] }) manager&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HTTPクライアントには &lt;a href="https://hackage.haskell.org/package/http-client"&gt;&lt;code&gt;http-client&lt;/code&gt;&lt;/a&gt; を，スクレイピングには &lt;a href="https://hackage.haskell.org/package/scalpel"&gt;&lt;code&gt;scalpel&lt;/code&gt;&lt;/a&gt; を使っている． &lt;a href="https://hackage.haskell.org/package/shelly"&gt;&lt;code&gt;shelly&lt;/code&gt;&lt;/a&gt; の &lt;code&gt;ls&lt;/code&gt; 関数を使って記事の一覧を取得してきている(これが Windows でも動くからうれしい)． 表示をそれっぽくするために &lt;a href="https://hackage.haskell.org/package/hspec"&gt;&lt;code&gt;hspec&lt;/code&gt;&lt;/a&gt; を使っている． &lt;code&gt;check&lt;/code&gt; 補助関数で自分のページや空文字を排除している．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;これでリンク切れや単純にタイポなんかを検出できるようになったんだが，直すのがめんどくさくて結局放置していること(オイ)．&lt;/p&gt;
&lt;h2 id="lts-10-に対応"&gt;LTS 10 に対応&lt;/h2&gt;
&lt;p&gt;リンクチェッカを回すために TravisCI を使い始めたが，なぜか GHC8 系の LTS だと OUT OF MEMORY してしまう…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--  While building custom Setup.hs for package Cabal-2.0.1.1 using:
      /home/travis/.stack/setup-exe-cache/x86_64-linux/Cabal-simple_mPHDZzAJ_2.0.1.0_ghc-8.2.2 --builddir=.stack-work/dist/x86_64-linux/Cabal-2.0.1.0 build --ghc-options &amp;quot; -ddump-hi -ddump-to-file -fdiagnostics-color=always&amp;quot;
    Process exited with code: ExitFailure (-9) (THIS MAY INDICATE OUT OF MEMORY)
    Logs have been written to: /home/travis/build/matsubara0507/source-gh-pages/.stack-work/logs/Cabal-2.0.1.1.log
    Configuring Cabal-2.0.1.1...
    Preprocessing library for Cabal-2.0.1.1..
    Building library for Cabal-2.0.1.1..&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;かなーーり古い LTS だとうまくいくので，仕方なくそれを使っていたのだが直すことにした． というか知り合いが直し方を記事にしてくれてたのでやってみた．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://haskell.e-bigmoon.com/posts/2017-12-31-travis-out-of-memory.html"&gt;travis-ci の初回ビルドで OUT OF MEMORY が出た時の対処法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;戦犯は &lt;code&gt;Cabal&lt;/code&gt; パッケージなので，こいつだけ先に &lt;code&gt;-j 1&lt;/code&gt; オプション(メモリを節約するが速度が遅い)でビルドしてしまうという戦略． この記事のサイトの &lt;a href="https://github.com/e-bigmoon/haskell-blog/blob/a229f118f121e0ad843faae1412e938e3e4f3a6b/.travis.yml"&gt;&lt;code&gt;.travis.yml&lt;/code&gt;&lt;/a&gt; を &lt;del&gt;コピペ&lt;/del&gt; 参考にして次のようにした&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="fu"&gt;install:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; mkdir -p ~/.local/bin&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;export PATH=$HOME/.local/bin:&lt;/span&gt;&lt;span class="at"&gt;$PATH&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;travis_retry curl -L https:&lt;/span&gt;&lt;span class="at"&gt;//www.stackage.org/stack/linux-x86_64 | tar xz --wildcards --strip-components=1 -C ~/.local/bin &amp;#39;*/stack&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;&lt;span class="fu"&gt;jobs:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;  &lt;span class="fu"&gt;include:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;stage:&lt;/span&gt;&lt;span class="at"&gt; install cabal&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;      &lt;span class="fu"&gt;script:&lt;/span&gt;&lt;span class="at"&gt; stack --no-terminal build -j 1 Cabal&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;stage:&lt;/span&gt;&lt;span class="at"&gt; install pandoc&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;      &lt;span class="fu"&gt;script:&lt;/span&gt;&lt;span class="at"&gt; travis_wait 30 stack --no-terminal build pandoc&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" data-line-number="11"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;stage:&lt;/span&gt;&lt;span class="at"&gt; install deprndences&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-12" data-line-number="12"&gt;      &lt;span class="fu"&gt;script:&lt;/span&gt;&lt;span class="at"&gt; stack --no-terminal test --only-dependencies&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-13" data-line-number="13"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;stage:&lt;/span&gt;&lt;span class="at"&gt; stack test&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-14" data-line-number="14"&gt;      &lt;span class="fu"&gt;script:&lt;/span&gt;&lt;span class="at"&gt; stack --no-terminal test --no-run-benchmarks --no-haddock-deps&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="hakyll-4.10-が落ちる"&gt;hakyll-4.10 が落ちる&lt;/h3&gt;
&lt;p&gt;OUT OF MEMORY は突破したが…&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;    &lt;span class="fu"&gt;/&lt;/span&gt;tmp&lt;span class="fu"&gt;/&lt;/span&gt;stack3402&lt;span class="fu"&gt;/&lt;/span&gt;hakyll&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;4.10&lt;/span&gt;&lt;span class="fu"&gt;.&lt;/span&gt;&lt;span class="fl"&gt;0.0&lt;/span&gt;&lt;span class="fu"&gt;/&lt;/span&gt;rts&lt;span class="fu"&gt;/&lt;/span&gt;posix&lt;span class="fu"&gt;/&lt;/span&gt;OSThreads.c&lt;span class="fu"&gt;:&lt;/span&gt;&lt;span class="dv"&gt;137&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; error&lt;span class="fu"&gt;:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;         error&lt;span class="fu"&gt;:&lt;/span&gt; undefined reference to &lt;span class="ch"&gt;&amp;#39;pthread_create&amp;#39;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;なぜだ… 最新の &lt;a href="https://github.com/jaspervdj/hakyll/commit/480da307d22aff8ab3817d1586710c5f4ff6d779"&gt;&lt;code&gt;hakyll-4.11&lt;/code&gt; では直ってるみたい&lt;/a&gt;なので，&lt;code&gt;stack.yaml&lt;/code&gt; に追加したら上手くいった．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="fu"&gt;extra-deps:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; hakyll-4.11.0.0&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; pandoc-citeproc-0.13.0.1&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="シンタックスハイライトが"&gt;シンタックスハイライトが…&lt;/h3&gt;
&lt;p&gt;おかしくなった． 理由は簡単で，Hakyll というか Pandoc がシンタックスハイライトにもともと使っていた &lt;a href="https://hackage.haskell.org/package/highlighting-kate"&gt;&lt;code&gt;highlighting-kate&lt;/code&gt;&lt;/a&gt; をやめて &lt;a href="https://hackage.haskell.org/package/skylighting"&gt;&lt;code&gt;skylighting&lt;/code&gt;&lt;/a&gt; に対応したからみたいだ．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://fixpt.de/blog/2017-12-03-hakyll-highlighting-themes.html"&gt;fixpt - Hakyll Code Highlighting Themes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なので，パッケージを変えたら元に戻った．&lt;/p&gt;
&lt;h2 id="可変なキーバリューストアを-aeson-で"&gt;可変なキーバリューストアを aeson で&lt;/h2&gt;
&lt;p&gt;テンプレートの方だけで出てくる変数(e.g. &lt;code&gt;$github$&lt;/code&gt; とか)は &lt;code&gt;site.hs&lt;/code&gt; の実装に依存したくなくて，Hakyll をビルドせずとも &lt;code&gt;config.yaml&lt;/code&gt; に好きに追加できるようにしたかった． &lt;a href="https://hackage.haskell.org/package/yaml"&gt;yaml&lt;/a&gt; パッケージ(というか &lt;a href="https://hackage.haskell.org/package/aeson"&gt;&lt;code&gt;aeson&lt;/code&gt;&lt;/a&gt;)ではそういうのを出来ないと &lt;strong&gt;思い込んでいたが &lt;code&gt;Map k v&lt;/code&gt; 型を使えばできる&lt;/strong&gt; と最近分かった(インスタンスのリストを眺めてたら気づいた)． なので，今まで使ってた &lt;a href="https://hackage.haskell.org/package/yaml-light"&gt;&lt;code&gt;yaml-light&lt;/code&gt;&lt;/a&gt; パッケージを捨てて &lt;code&gt;yaml&lt;/code&gt; パッケージで次のように実装した．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Yaml&lt;/span&gt;   (decodeFileEither)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Map&lt;/span&gt;    (&lt;span class="dt"&gt;Map&lt;/span&gt;, foldMapWithKey)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Hakyll&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;  configYaml &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; either (error &lt;span class="fu"&gt;.&lt;/span&gt; show) id &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; decodeFileEither &lt;span class="st"&gt;&amp;quot;config.yaml&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-9" data-line-number="9"&gt;    siteCtx &lt;span class="fu"&gt;=&lt;/span&gt; mkSiteCtx configYaml&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-10" data-line-number="10"&gt;  hakyllWith config &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-11" data-line-number="11"&gt;    &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-13" data-line-number="13"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Map&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-14" data-line-number="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-15" data-line-number="15"&gt;&lt;span class="ot"&gt;mkSiteCtx ::&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-16" data-line-number="16"&gt;mkSiteCtx &lt;span class="fu"&gt;=&lt;/span&gt; foldMapWithKey constField&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こういう &lt;code&gt;config.yaml&lt;/code&gt; を書いておくと，全てテンプレートの中で参照できる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="fu"&gt;site_title:&lt;/span&gt;&lt;span class="at"&gt; ひげメモ&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;&lt;span class="fu"&gt;description:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;自分用のメモ書きだったり，イロイロといじって遊ぶようだったり&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;&lt;span class="fu"&gt;baseurl:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;https://matsubara0507.github.io&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;&lt;span class="fu"&gt;github:&lt;/span&gt;&lt;span class="at"&gt;  matsubara0507&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="post-以下のマークダウン置き場を変更"&gt;&lt;code&gt;post/&lt;/code&gt; 以下のマークダウン置き場を変更&lt;/h2&gt;
&lt;p&gt;記事のマークダウンは全て &lt;code&gt;posts/&lt;/code&gt; 以下に置いていたのだが，各年ごとにディレクトリを切りたいなぁと思った． 例えば &lt;code&gt;posts/2018/02-21-add-feats-mysite-2018.md&lt;/code&gt; といった具合に． しかし，出力は今まで通り &lt;code&gt;posts/2018-02-21-add-feats-mysite-2018.html&lt;/code&gt; としたい(リンクが変わっちゃうからね)． まんま&lt;a href="http://daimatz.net/text/2014/0126-hakyll.html"&gt;同じことをしてくれている記事&lt;/a&gt;があったので，参考にして次のように書き換えた．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;  match &lt;span class="st"&gt;&amp;quot;posts/*/*&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;    route &lt;span class="fu"&gt;$&lt;/span&gt; composeRoutes (gsubRoute &lt;span class="st"&gt;&amp;quot;/[0-9]{4}/&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; (&lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;) &lt;span class="fu"&gt;.&lt;/span&gt; init)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;                          (setExtension &lt;span class="st"&gt;&amp;quot;html&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;    compile&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;      &lt;span class="fu"&gt;$&lt;/span&gt;   pandocCompiler&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" data-line-number="9"&gt;      &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; loadAndApplyTemplate &lt;span class="st"&gt;&amp;quot;templates/post.html&amp;quot;&lt;/span&gt; postCtx&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" data-line-number="10"&gt;      &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; loadAndApplyTemplate &lt;span class="st"&gt;&amp;quot;templates/default.html&amp;quot;&lt;/span&gt; (postCtx &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; siteCtx)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" data-line-number="11"&gt;      &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; relativizeUrls&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;gsubRoute&lt;/code&gt; 関数を使うことで，ファイル名を特有のパターン記法(？)でマッチさせ置換できる． &lt;code&gt;gsubRoute &amp;quot;/[0-9]{4}/&amp;quot; $ (++ &amp;quot;-&amp;quot;) . init&lt;/code&gt; の場合，&lt;code&gt;/2018/&lt;/code&gt; をマッチさせ &lt;code&gt;init&lt;/code&gt; して &lt;code&gt;/2018&lt;/code&gt; となり，末尾に &lt;code&gt;&amp;quot;-&amp;quot;&lt;/code&gt; を追加している．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;さて実はもう一つ問題があって，Hakyll は日時を表すテンプレート変数(&lt;code&gt;$date$&lt;/code&gt; とか)を次のように取得する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;postCtx ::&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;postCtx &lt;span class="fu"&gt;=&lt;/span&gt; mconcat&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;  [ dateField &lt;span class="st"&gt;&amp;quot;time&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;%Y-%m-%d&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;  , dateField &lt;span class="st"&gt;&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;%b %-d, %Y&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;  , defaultContext&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;  ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;dateField&lt;/code&gt; 関数が記事のファイル名(&lt;code&gt;yyyy-mm-dd-*.md&lt;/code&gt; の部分)かマークダウンのメタ変数から取得している． つまり，&lt;code&gt;posts/2018/02-21-add-feats-mysite-2018.md&lt;/code&gt; というファイル名じゃ日時の変数を取得できない． しょうがないので Hakyll のソースコードを読んで無理やり書き換えた．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Time&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;System.FilePath&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;span class="ot"&gt;dateField&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;dateField&amp;#39; key format &lt;span class="fu"&gt;=&lt;/span&gt; field key &lt;span class="fu"&gt;$&lt;/span&gt; \item &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;  time &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getItemUTC&amp;#39; defaultTimeLocale &lt;span class="fu"&gt;$&lt;/span&gt; itemIdentifier item&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;  return &lt;span class="fu"&gt;$&lt;/span&gt; formatTime defaultTimeLocale format time&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;&lt;span class="ot"&gt;getItemUTC&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;MonadMetadata&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TimeLocale&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Identifier&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m &lt;span class="dt"&gt;UTCTime&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" data-line-number="10"&gt;getItemUTC&amp;#39; locale ident &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" data-line-number="11"&gt;  pure &lt;span class="fu"&gt;$&lt;/span&gt; parseTimeOrError &lt;span class="dt"&gt;True&lt;/span&gt; locale &lt;span class="st"&gt;&amp;quot;%Y%m-%d&amp;quot;&lt;/span&gt; (yyyy &lt;span class="fu"&gt;++&lt;/span&gt; mmdd)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" data-line-number="12"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" data-line-number="13"&gt;    path &lt;span class="fu"&gt;=&lt;/span&gt; toFilePath ident&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-14" data-line-number="14"&gt;    yyyy &lt;span class="fu"&gt;=&lt;/span&gt; takeFileName &lt;span class="fu"&gt;$&lt;/span&gt; takeDirectory path&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-15" data-line-number="15"&gt;    mmdd &lt;span class="fu"&gt;=&lt;/span&gt; take &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; takeBaseName path&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;さっきの &lt;code&gt;dateField&lt;/code&gt; の部分を &lt;code&gt;dateField'&lt;/code&gt; にすれば記事のビルドが出来る！&lt;/p&gt;
&lt;h3 id="vs-recentfirst-関数"&gt;vs &lt;code&gt;recentFirst&lt;/code&gt; 関数&lt;/h3&gt;
&lt;p&gt;記事を日時順に並び変えてくれる &lt;code&gt;recentFirst&lt;/code&gt; 関数もファイル名に依存してる． しょうがないので力技で書き換える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.List&lt;/span&gt;       (sortBy)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Ord&lt;/span&gt;        (comparing)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;&lt;span class="ot"&gt;recentFirst&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;MonadMetadata&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Item&lt;/span&gt; a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m [&lt;span class="dt"&gt;Item&lt;/span&gt; a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;recentFirst&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; fmap reverse &lt;span class="fu"&gt;.&lt;/span&gt; chronological&amp;#39;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-7" data-line-number="7"&gt;&lt;span class="ot"&gt;chronological&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;MonadMetadata&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Item&lt;/span&gt; a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m [&lt;span class="dt"&gt;Item&lt;/span&gt; a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-8" data-line-number="8"&gt;chronological&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-9" data-line-number="9"&gt;  sortByM &lt;span class="fu"&gt;$&lt;/span&gt; getItemUTC&amp;#39; defaultTimeLocale &lt;span class="fu"&gt;.&lt;/span&gt; itemIdentifier&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-11" data-line-number="11"&gt;&lt;span class="ot"&gt;sortByM ::&lt;/span&gt; (&lt;span class="dt"&gt;Monad&lt;/span&gt; m, &lt;span class="dt"&gt;Ord&lt;/span&gt; k) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m k) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m [a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-12" data-line-number="12"&gt;sortByM f &lt;span class="fu"&gt;=&lt;/span&gt; fmap (map fst &lt;span class="fu"&gt;.&lt;/span&gt; sortBy (comparing snd)) &lt;span class="fu"&gt;.&lt;/span&gt; mapM (fmap &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; (,) &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; f)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;sortByM&lt;/code&gt; 関数は &lt;code&gt;sortBy&lt;/code&gt; の &lt;code&gt;Monad&lt;/code&gt; 版． &lt;code&gt;[a]&lt;/code&gt; を &lt;code&gt;[(a, m k)]&lt;/code&gt; とし &lt;code&gt;[m (a, k)]&lt;/code&gt; にして &lt;code&gt;m [(a, k)]&lt;/code&gt; にしてから &lt;code&gt;k&lt;/code&gt; でソートし最後に &lt;code&gt;a&lt;/code&gt; だけ取り出している． ちなみに，&lt;code&gt;fmap &amp;lt;$&amp;gt; (,) &amp;lt;*&amp;gt; f&lt;/code&gt; の部分は分かりますか？ &lt;code&gt;\x -&amp;gt; (,) x &amp;lt;$&amp;gt; f x&lt;/code&gt; をしてるだけですよ．&lt;/p&gt;
&lt;h2 id="フィードページネーションタグ"&gt;フィード・ページネーション・タグ&lt;/h2&gt;
&lt;p&gt;実はフィード生成・ページネーション・タグは，もとから Hakyll で提供されている機能だ． どれもこの記事に日本語で書いてある．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part2.html"&gt;Hakyllでブログを作る(実践編2) - Wake up! Good night*&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part3.html"&gt;Hakyllでブログを作る(実践編3) - Wake up! Good night*&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;だが躓きポイントはいくつかあった(だいたい日時のやつだけど…)．&lt;/p&gt;
&lt;h3 id="フィードを生成"&gt;フィードを生成&lt;/h3&gt;
&lt;p&gt;記事の通りに作っても &lt;code&gt;$published$&lt;/code&gt; 変数が無いと怒られる． &lt;code&gt;renderAtom&lt;/code&gt; 関数の中で &lt;code&gt;dateField&lt;/code&gt; 関数を使っているからだ． さすがに書き換えるのはめんどいので，自分で取ってくることにした．&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="ot"&gt;postCtx ::&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;postCtx &lt;span class="fu"&gt;=&lt;/span&gt; mconcat&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;  [ dateField &lt;span class="st"&gt;&amp;quot;time&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;%Y-%m-%d&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;  , dateField &lt;span class="st"&gt;&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;%b %-d, %Y&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" data-line-number="5"&gt;  , dateField&amp;#39; &lt;span class="st"&gt;&amp;quot;published&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;%Y-%m-%dT%H:%M:%SZ&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" data-line-number="6"&gt;  , dateField&amp;#39; &lt;span class="st"&gt;&amp;quot;updated&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;%Y-%m-%dT%H:%M:%SZ&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" data-line-number="7"&gt;  , defaultContext&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-8" data-line-number="8"&gt;  ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;あと，&lt;a href="https://hackage.haskell.org/package/hakyll-4.11.0.0/docs/Hakyll-Web-Feed.html#t:FeedConfiguration"&gt;フィードに渡す変数&lt;/a&gt;は &lt;code&gt;config.yaml&lt;/code&gt; に書くことにした．&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="fu"&gt;site_title:&lt;/span&gt;&lt;span class="at"&gt; ひげメモ&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;&lt;span class="fu"&gt;author:&lt;/span&gt;&lt;span class="at"&gt; MATSUBARA Nobutada&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;&lt;span class="fu"&gt;email:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;&lt;span class="fu"&gt;description:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;自分用のメモ書きだったり，イロイロといじって遊ぶようだったり&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;&lt;span class="fu"&gt;baseurl:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;https://matsubara0507.github.io&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;&lt;span class="fu"&gt;val:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" data-line-number="7"&gt;  &lt;span class="fu"&gt;github:&lt;/span&gt;&lt;span class="at"&gt; matsubara0507&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これを &lt;code&gt;Config&lt;/code&gt; 型という拡張可能レコードにマッピングし，そのあとに &lt;code&gt;FeedConfiguration&lt;/code&gt; 型に変換する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Control.Lens&lt;/span&gt; ((^.))&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Extensible&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" data-line-number="4"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-5" data-line-number="5"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;site_title&amp;quot; &amp;gt;: String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-6" data-line-number="6"&gt;   , &lt;span class="st"&gt;&amp;quot;author&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-7" data-line-number="7"&gt;   , &lt;span class="st"&gt;&amp;quot;email&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-8" data-line-number="8"&gt;   , &lt;span class="st"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-9" data-line-number="9"&gt;   , &lt;span class="st"&gt;&amp;quot;baseurl&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-10" data-line-number="10"&gt;   , &lt;span class="st"&gt;&amp;quot;val&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Map&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-11" data-line-number="11"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-13" data-line-number="13"&gt;&lt;span class="ot"&gt;mkFeedConfig ::&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;FeedConfiguration&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-14" data-line-number="14"&gt;mkFeedConfig conf &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;FeedConfiguration&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-15" data-line-number="15"&gt;  { feedTitle       &lt;span class="fu"&gt;=&lt;/span&gt; conf &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;site_title&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-16" data-line-number="16"&gt;  , feedDescription &lt;span class="fu"&gt;=&lt;/span&gt; conf &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;description&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-17" data-line-number="17"&gt;  , feedAuthorName  &lt;span class="fu"&gt;=&lt;/span&gt; conf &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;author&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-18" data-line-number="18"&gt;  , feedAuthorEmail &lt;span class="fu"&gt;=&lt;/span&gt; conf &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;email&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-19" data-line-number="19"&gt;  , feedRoot        &lt;span class="fu"&gt;=&lt;/span&gt; conf &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;baseurl&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-20" data-line-number="20"&gt;  }&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;もちろん，&lt;code&gt;siteCtx&lt;/code&gt; も書き換える必要がある．&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="ot"&gt;mkSiteCtx ::&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;mkSiteCtx &lt;span class="fu"&gt;=&lt;/span&gt; hfoldMapFor&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;  (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; (&lt;span class="dt"&gt;KeyValue&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;  (toContext &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; symbolVal &lt;span class="fu"&gt;.&lt;/span&gt; proxyAssocKey &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; getField)&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;&lt;span class="ot"&gt;  toContext ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-10" data-line-number="10"&gt;  toContext _ &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; mempty&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-11" data-line-number="11"&gt;  toContext k v  &lt;span class="fu"&gt;=&lt;/span&gt; constField k v&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-13" data-line-number="13"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt; (&lt;span class="dt"&gt;Map&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-14" data-line-number="14"&gt;  toContext _ &lt;span class="fu"&gt;=&lt;/span&gt; foldMapWithKey toContext&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-16" data-line-number="16"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ToContext&lt;/span&gt; (&lt;span class="dt"&gt;Identity&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-17" data-line-number="17"&gt;  toContext k &lt;span class="fu"&gt;=&lt;/span&gt; toContext k &lt;span class="fu"&gt;.&lt;/span&gt; runIdentity&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拡張可能レコード最高です．&lt;/p&gt;
&lt;h3 id="ページネーションを追加"&gt;ページネーションを追加&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part2.html#%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%8D%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3"&gt;参考記事&lt;/a&gt;の中で使われている &lt;code&gt;sortRecentFirst&lt;/code&gt; も日時を取得しているので書き換える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="ot"&gt;sortRecentFirst&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;MonadMetadata&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Identifier&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m [&lt;span class="dt"&gt;Identifier&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;sortRecentFirst&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" data-line-number="3"&gt;  fmap (fmap itemIdentifier) &lt;span class="fu"&gt;.&lt;/span&gt; recentFirst&amp;#39; &lt;span class="fu"&gt;.&lt;/span&gt; fmap (flip &lt;span class="dt"&gt;Item&lt;/span&gt; ())&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="タグを追加"&gt;タグを追加&lt;/h3&gt;
&lt;p&gt;躓きと言うかデザインの問題なのだが，タグのテンプレート変数を生成する &lt;a href="https://hackage.haskell.org/package/hakyll-4.11.0.0/docs/Hakyll-Web-Tags.html#v:tagsField"&gt;&lt;code&gt;tagsField&lt;/code&gt;&lt;/a&gt; 関数が，タグをカンマ区切りの文字列にしちゃうのがあった． 個人的には空白区切りにして欲しいので書き換えた．&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.List&lt;/span&gt;                   (intersperse)&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Text.Blaze.Html&lt;/span&gt;             (toHtml, toValue, (!))&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Text.Blaze.Html5&lt;/span&gt;            &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;H&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Text.Blaze.Html5.Attributes&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;A&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-6" data-line-number="6"&gt;&lt;span class="ot"&gt;tagsFieldWithSep ::&lt;/span&gt; &lt;span class="dt"&gt;H.Html&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Tags&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Context&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-7" data-line-number="7"&gt;tagsFieldWithSep sep &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-8" data-line-number="8"&gt;  tagsFieldWith getTags simpleRenderLink (mconcat &lt;span class="fu"&gt;.&lt;/span&gt; intersperse sep)&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-10" data-line-number="10"&gt;&lt;span class="ot"&gt;simpleRenderLink ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; FilePath &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;H.Html&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-11" data-line-number="11"&gt;simpleRenderLink tag &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-12" data-line-number="12"&gt;  fmap (\path &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; H.a &lt;span class="fu"&gt;!&lt;/span&gt; A.href (toValue &lt;span class="fu"&gt;$&lt;/span&gt; toUrl path) &lt;span class="fu"&gt;$&lt;/span&gt; toHtml tag)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;tagsFieldWithSep &amp;quot; &amp;quot;&lt;/code&gt; とすれば空白区切りになる．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;ずーーとやろうやろうと思ってたことをいっきに片したぜ．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-02-19-create-whoami-cli.html</id><title type="text">自己紹介ページを生成する whoami CLI を作った (Haskell)</title><updated>2018-02-19T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-02-19-create-whoami-cli.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;自己紹介ページを生成する whoami CLI を作った (Haskell)&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-02-19" itemprop="datePublished"&gt;
        Feb 19, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/application.html"&gt;application&lt;/a&gt; &lt;a href="/tags/extensible-package.html"&gt;extensible-package&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;&lt;a href="https://github.com/matsubara0507/whoami"&gt;whoami&lt;/a&gt; という CLI を作りました． こんな感じの Yaml ファイルから&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; MATSUBARA Nobutada&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="fu"&gt;account:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;github:&lt;/span&gt;&lt;span class="at"&gt; matsubara0507&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;  &lt;span class="fu"&gt;qiita:&lt;/span&gt;&lt;span class="at"&gt; matsubara0507&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;span class="fu"&gt;site:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; ひげメモ&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;    &lt;span class="fu"&gt;url:&lt;/span&gt;&lt;span class="at"&gt; http://matsubara0507.github.io&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;    &lt;span class="fu"&gt;description:&lt;/span&gt;&lt;span class="at"&gt; メモ書きブログ&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;&lt;span class="fu"&gt;post:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;  &lt;span class="fu"&gt;latest:&lt;/span&gt;&lt;span class="at"&gt; 10&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;  &lt;span class="fu"&gt;posts:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;url:&lt;/span&gt;&lt;span class="at"&gt; http://haskell.jp/blog/posts/2017/advent-calendar-2017.html&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;      &lt;span class="fu"&gt;date:&lt;/span&gt;&lt;span class="at"&gt; 2017-12-31&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" data-line-number="14"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;url:&lt;/span&gt;&lt;span class="at"&gt; http://iggg.github.io/2017/06/01/make-tweet-slack-bot&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" data-line-number="15"&gt;&lt;span class="fu"&gt;library:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" data-line-number="16"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; chatwork&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-17" data-line-number="17"&gt;    &lt;span class="fu"&gt;url:&lt;/span&gt;&lt;span class="at"&gt; http://hackage.haskell.org/package/chatwork&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-18" data-line-number="18"&gt;    &lt;span class="fu"&gt;description:&lt;/span&gt;&lt;span class="at"&gt; The ChatWork API in Haskell&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-19" data-line-number="19"&gt;    &lt;span class="fu"&gt;language:&lt;/span&gt;&lt;span class="at"&gt; haskell&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-20" data-line-number="20"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; thank_you_stars&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-21" data-line-number="21"&gt;    &lt;span class="fu"&gt;url:&lt;/span&gt;&lt;span class="at"&gt; http://hex.pm/packages/thank_you_stars&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-22" data-line-number="22"&gt;    &lt;span class="fu"&gt;language:&lt;/span&gt;&lt;span class="at"&gt; elixir&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-23" data-line-number="23"&gt;&lt;span class="fu"&gt;qiita:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-24" data-line-number="24"&gt;  &lt;span class="fu"&gt;posts:&lt;/span&gt;&lt;span class="at"&gt; true&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-25" data-line-number="25"&gt;&lt;span class="fu"&gt;app:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-26" data-line-number="26"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; AnaQRam&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-27" data-line-number="27"&gt;    &lt;span class="fu"&gt;url:&lt;/span&gt;&lt;span class="at"&gt; http://github.com/matsubara0507/AnaQRam&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-28" data-line-number="28"&gt;    &lt;span class="fu"&gt;description:&lt;/span&gt;&lt;span class="at"&gt; QRコードを利用したアナグラム(並び替えパズル)&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こんな感じの Markdown を生成する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode markdown"&gt;&lt;code class="sourceCode markdown"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="fu"&gt;# MATSUBARA Nobutada&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;- &lt;span class="ot"&gt;[GitHub](https://github.com/matsubara0507)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="fl"&gt;- &lt;/span&gt;&lt;span class="ot"&gt;[Qiita](https://qiita.com/matsubara0507)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="fu"&gt;## My Sites&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;- &lt;span class="ot"&gt;[ひげメモ](http://matsubara0507.github.io)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;&lt;span class="fl"&gt;    - メモ書きブログ&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;&lt;span class="fu"&gt;## My Posts&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;- &lt;span class="ot"&gt;[Haskell Advent Calendar 2017 まとめ - Haskell-jp](http://haskell.jp/blog/posts/2017/advent-calendar-2017.html)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;&lt;span class="fl"&gt;    - posted on 2017-12-31&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;&lt;span class="fl"&gt;- &lt;/span&gt;&lt;span class="ot"&gt;[LINE の Echo Bot を Google Cloud Functions に作る](https://qiita.com/matsubara0507/items/04ab3c2197aa5f68e499)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;&lt;span class="fl"&gt;    - posted on 2017-11-21&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-14" data-line-number="14"&gt;&lt;span class="fl"&gt;- &lt;/span&gt;&lt;span class="ot"&gt;[GitHub にチャット機能のようなものが追加された (team discussions)](https://qiita.com/matsubara0507/items/47d2e2545553e415f969)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-15" data-line-number="15"&gt;&lt;span class="fl"&gt;    - posted on 2017-11-21&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-16" data-line-number="16"&gt;&lt;span class="fl"&gt;- &lt;/span&gt;&lt;span class="ot"&gt;[GitHub Project に自動でカードのカラム遷移をする機能が追加された](https://qiita.com/matsubara0507/items/f384991b4854aa28745a)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-17" data-line-number="17"&gt;&lt;span class="fl"&gt;    - posted on 2017-10-31&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-18" data-line-number="18"&gt;&lt;span class="fl"&gt;- &lt;/span&gt;&lt;span class="ot"&gt;[Slack から特定のアカウントでツイートする Bot を作った｜群馬大学電子計算機研究会 IGGG](http://iggg.github.io/2017/06/01/make-tweet-slack-bot)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-19" data-line-number="19"&gt;&lt;span class="fl"&gt;    - posted on 2017-06-01&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-20" data-line-number="20"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-21" data-line-number="21"&gt;&lt;span class="fu"&gt;## Applications&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-22" data-line-number="22"&gt;- &lt;span class="ot"&gt;[AnaQRam](http://github.com/matsubara0507/AnaQRam)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-23" data-line-number="23"&gt;&lt;span class="fl"&gt;    - QRコードを利用したアナグラム(並び替えパズル)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-24" data-line-number="24"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-25" data-line-number="25"&gt;&lt;span class="fu"&gt;## Libraries&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-26" data-line-number="26"&gt;- &lt;span class="ot"&gt;[chatwork](http://hackage.haskell.org/package/chatwork)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-27" data-line-number="27"&gt;&lt;span class="fl"&gt;    - The ChatWork API in Haskell&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-28" data-line-number="28"&gt;&lt;span class="fl"&gt;- &lt;/span&gt;&lt;span class="ot"&gt;[thank_you_stars](http://hex.pm/packages/thank_you_stars)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-29" data-line-number="29"&gt;&lt;span class="fl"&gt;    - A tool for starring GitHub repositories.&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yaml ファイルでは足りない情報をスクレイピングや各種 Web サービスの API で拾ってくる． なんか自分のアクティビティを紹介するページを SNS にリンクしてる人が多いと思うんだけど，そのページをできるだけ楽して生成したいなぁというのがモチベーション．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;ホントはバイト先で作ってる Haskell 製の社内用 CLI ツールを公開したくて，内容を公開できるようにしたツールです． こんな感じのデータ処理をするツールを，バイト先では Haskell で作ってた．&lt;/p&gt;
&lt;h2 id="extensible"&gt;extensible&lt;/h2&gt;
&lt;p&gt;このツールの(まぁまぁ)面白いところは，&lt;a href="https://hackage.haskell.org/package/extensible"&gt;extensible&lt;/a&gt; というパッケージの機能をふんだんに使っている． 拡張可能レコード，バリアント，作用を使い，ついでに &lt;a href="https://hackage.haskell.org/package/extensible/docs/Data-Extensible-GetOpt.html"&gt;GetOpt&lt;/a&gt; も使ってみた． 軽く補足しておく(&lt;strong&gt;但し，作者ではないので間違っている部分はあるかも&lt;/strong&gt;)．&lt;/p&gt;
&lt;h3 id="拡張可能レコード"&gt;拡張可能レコード&lt;/h3&gt;
&lt;p&gt;Haskell のレコード構文&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; {&lt;span class="ot"&gt; hoge1 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;,&lt;span class="ot"&gt; hoge2 ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; }&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;を，型レベル辞書を用いて次のように書ける．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;hoge1&amp;quot; &amp;gt;: Int, &amp;quot;hoge2&amp;quot; &amp;gt;: Text ]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt; 言語拡張と組み合わせて，名前衝突の無いフィールド名を扱えたり，&lt;code&gt;lens&lt;/code&gt; を用いた OOP のような参照(e.g. &lt;code&gt;hoge ^. #hoge1&lt;/code&gt;)が出来る． また，&lt;a href="/posts/2017-11-28-fun-of-extensible-1.html"&gt;レコードの拡縮もできる&lt;/a&gt;．&lt;/p&gt;
&lt;h3 id="拡張可能バリアント"&gt;拡張可能バリアント&lt;/h3&gt;
&lt;p&gt;次のような直和型&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Hoge1&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Hoge2&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;を，型レベル辞書を用いて，バリアント型のように書ける．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;hoge1&amp;quot; &amp;gt;: Int, &amp;quot;hoge2&amp;quot; &amp;gt;: Text ]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(正直あんまり利点が分かってないけど)拡縮はもちろん，&lt;a href="/posts/2018-01-31-fun-of-extensible-2.html"&gt;バリアントの操作関数をファイル分割して実装&lt;/a&gt;もできる．&lt;/p&gt;
&lt;h3 id="拡張可能作用"&gt;拡張可能作用&lt;/h3&gt;
&lt;p&gt;型レベル辞書によってモナドスタックを表現する． 今回は次のようなモナドを定義した．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;ServiceM&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Eff&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ ReaderDef Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;   , &lt;span class="dt"&gt;EitherDef&lt;/span&gt; &lt;span class="dt"&gt;ServiceException&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;   , &lt;span class="dt"&gt;LoggerDef&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;   , &lt;span class="st"&gt;&amp;quot;IO&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" data-line-number="6"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基本的に&lt;a href="/posts/2017-12-09-extensible-effects-step-by-step.html"&gt;普通のモナドトランスフォーマーのように扱える&lt;/a&gt;． じゃぁ素直にモナドトランスフォーマー使えよって感じかもしれないけど気にしないで．&lt;/p&gt;
&lt;h3 id="getopt-ラッパー"&gt;&lt;code&gt;GetOpt&lt;/code&gt; ラッパー&lt;/h3&gt;
&lt;p&gt;GHCには標準で &lt;code&gt;--output hoge&lt;/code&gt; みたいな CLI のオプション引数をパースしてくれるモジュール &lt;a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/System-Console-GetOpt.html"&gt;&lt;code&gt;GetOpt&lt;/code&gt;&lt;/a&gt; がある(ぼくは初めて使った)． extensible では，パース結果を拡張可能レコードにマッピングするための補助関数が&lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-GetOpt.html"&gt;提供されている&lt;/a&gt;．&lt;/p&gt;
&lt;p&gt;キモになるのは &lt;code&gt;withGetOpt&lt;/code&gt; 関数である．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;withGetOpt&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  ::&lt;/span&gt; &lt;span class="dt"&gt;MonadIO&lt;/span&gt; m&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;  &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;  &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; (&lt;span class="dt"&gt;OptionDescr&lt;/span&gt; h) xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;  &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="dt"&gt;RecordOf&lt;/span&gt; h xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;String&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;  &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一引数目の文字列はパース失敗したとき(要するにオプションが間違ってるとき)に表示する「使い方」に使われる． 例えば，whoami だと&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;whoami [options] [input-file]
  -o FILE               --output=FILE                Write output to FILE instead of stdout.
  -t FORMAT, -w FORMAT  --to=FORMAT, --write=FORMAT  Specify output format. default is `markdown`.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;の &lt;code&gt;[options] [input-file]&lt;/code&gt; が一引数目だ． 二引数目はオプションのパーサー(？)の定義を拡張可能レコードで与えており，三引数目がパース結果の拡張可能レコードと残りの(空白区切りの)文字列を受け取ってどうするかの振る舞いを与える．&lt;/p&gt;
&lt;p&gt;まぁ詳しくは&lt;a href="https://www.schoolofhaskell.com/user/fumieval/extensible/getopt-and-extensible-records"&gt;作者さんの記事&lt;/a&gt;で紹介されている(英語だけど，あと一引数目の文字列はこの記事以降に追加された機能らしく，サンプルコードにはない)．&lt;/p&gt;
&lt;h3 id="extensible-instances"&gt;extensible-instances&lt;/h3&gt;
&lt;p&gt;拡張可能レコードは全て &lt;code&gt;Record '[...]&lt;/code&gt; の型エイリアスで定義する． つまり，拡張可能レコードの何らかの型クラスのインスタンスは &lt;code&gt;Record '[...]&lt;/code&gt; に適用しておけば全部で使える(逆に影響力がでかいともいえる)．&lt;/p&gt;
&lt;p&gt;いくつかの自作アプリーケーションでインスタンスを作っていて，ダブってたのでひとつのリポジトリにまとめた．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/matsubara0507/extensible-instances"&gt;matsubara0507/extensible-instances - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(なんか作者本人じゃないから気が引けて) Hackage にはあげてないがパッケージの体はしてるので，&lt;a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#git-and-mercurial-repos"&gt;&lt;code&gt;stack.yaml&lt;/code&gt; の &lt;code&gt;extra-deps&lt;/code&gt; に記述&lt;/a&gt;することで使えるはず．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;注意点として &lt;a href="https://github.com/fumieval/extensible"&gt;fumieval/extensible&lt;/a&gt; の&lt;a href="https://github.com/fumieval/extensible/blob/master/examples/aeson.hs"&gt;例にある &lt;code&gt;FromJSON&lt;/code&gt; のインスタンス&lt;/a&gt;とは微妙に実装が違う． 作者さんのは &lt;code&gt;Maybe a&lt;/code&gt; にしてもキーが存在しないといけないのだが，&lt;code&gt;aeson&lt;/code&gt; の &lt;code&gt;Generics&lt;/code&gt; は &lt;code&gt;Maybe a&lt;/code&gt; ならキーが無くても良いので，そっちに合わせた．&lt;/p&gt;
&lt;h2 id="仕組み"&gt;仕組み&lt;/h2&gt;
&lt;p&gt;コード自体は&lt;a href="https://github.com/matsubara0507/whoami"&gt;このリポジトリ&lt;/a&gt;にある．&lt;/p&gt;
&lt;h3 id="基本的な部分"&gt;基本的な部分&lt;/h3&gt;
&lt;p&gt;基本的に Yaml ファイルにはサイト・記事・ライブラリ・アプリケーションを列挙してもらう． それらは次のような型になっている(型の値として取り出せる)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;name&amp;quot;    &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;account&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Accounts&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;site&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; [&lt;span class="dt"&gt;SiteConfig&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;   , &lt;span class="st"&gt;&amp;quot;post&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;latest&amp;quot; &amp;gt;: Maybe Int, &amp;quot;posts&amp;quot; &amp;gt;: [PostConfig]]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;   , &lt;span class="st"&gt;&amp;quot;library&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; [&lt;span class="dt"&gt;LibConfig&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;   , &lt;span class="st"&gt;&amp;quot;app&amp;quot;&lt;/span&gt;     &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; [&lt;span class="dt"&gt;AppConfig&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;   , &lt;span class="st"&gt;&amp;quot;qiita&amp;quot;&lt;/span&gt;   &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;QiitaConfig&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" data-line-number="11"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Accounts&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Map&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" data-line-number="12"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Url&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" data-line-number="13"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-14" data-line-number="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-15" data-line-number="15"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;SiteConfig&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-16" data-line-number="16"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;name&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-17" data-line-number="17"&gt;   , &lt;span class="st"&gt;&amp;quot;url&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Url&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-18" data-line-number="18"&gt;   , &lt;span class="st"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-19" data-line-number="19"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-20" data-line-number="20"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-21" data-line-number="21"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;PostConfig&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-22" data-line-number="22"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;title&amp;quot; &amp;gt;: Maybe Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-23" data-line-number="23"&gt;   , &lt;span class="st"&gt;&amp;quot;url&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Url&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-24" data-line-number="24"&gt;   , &lt;span class="st"&gt;&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-25" data-line-number="25"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-26" data-line-number="26"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-27" data-line-number="27"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;LibConfig&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-28" data-line-number="28"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;name&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-29" data-line-number="29"&gt;   , &lt;span class="st"&gt;&amp;quot;url&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Url&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-30" data-line-number="30"&gt;   , &lt;span class="st"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-31" data-line-number="31"&gt;   , &lt;span class="st"&gt;&amp;quot;language&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-32" data-line-number="32"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-33" data-line-number="33"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-34" data-line-number="34"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;AppConfig&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-35" data-line-number="35"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;name&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-36" data-line-number="36"&gt;   , &lt;span class="st"&gt;&amp;quot;url&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Url&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-37" data-line-number="37"&gt;   , &lt;span class="st"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-38" data-line-number="38"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://hackage.haskell.org/package/yaml"&gt;yaml&lt;/a&gt;パッケージを使って，Yaml ファイルから &lt;code&gt;Config&lt;/code&gt; 型にデコードしてもらう． &lt;code&gt;Maybe a&lt;/code&gt; になっているところは書いてあっても無くても良い項目だ．&lt;/p&gt;
&lt;p&gt;そしてサイト・記事・ライブラリ・アプリケーション固有の &lt;code&gt;Config&lt;/code&gt; 型を共通のフォーマットである &lt;code&gt;Info&lt;/code&gt; 型に変換する手続きを型クラスを用いて定義した．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;name&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;url&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Url&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;   , &lt;span class="st"&gt;&amp;quot;type&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;ServiceType&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" data-line-number="6"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-8" data-line-number="8"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;ServiceType&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-9" data-line-number="9"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;post&amp;quot; &amp;gt;: Post&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-10" data-line-number="10"&gt;   , &lt;span class="st"&gt;&amp;quot;app&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Application&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-11" data-line-number="11"&gt;   , &lt;span class="st"&gt;&amp;quot;lib&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Library&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-12" data-line-number="12"&gt;   , &lt;span class="st"&gt;&amp;quot;site&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Site&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-13" data-line-number="13"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-14" data-line-number="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-15" data-line-number="15"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Uniform&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-16" data-line-number="16"&gt;&lt;span class="ot"&gt;  fetch ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ServiceM&lt;/span&gt; &lt;span class="dt"&gt;Data&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-17" data-line-number="17"&gt;&lt;span class="ot"&gt;  fill ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Data&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ServiceM&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-18" data-line-number="18"&gt;&lt;span class="ot"&gt;  uniform ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ServiceM&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-19" data-line-number="19"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-20" data-line-number="20"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Data&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-21" data-line-number="21"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-22" data-line-number="22"&gt;&lt;span class="ot"&gt;toInfo ::&lt;/span&gt; &lt;span class="dt"&gt;Uniform&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ServiceM&lt;/span&gt; &lt;span class="dt"&gt;Info&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-23" data-line-number="23"&gt;toInfo conf &lt;span class="fu"&gt;=&lt;/span&gt; uniform &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; fill conf &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; fetch conf&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Uniform&lt;/code&gt; 型クラスに3つの関数は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fill&lt;/code&gt; 関数は共通のフォーマットにするための足りない情報(&lt;code&gt;Maybe a&lt;/code&gt; で &lt;code&gt;Nothing&lt;/code&gt; だったところ)をスクレイピングなどで補完&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fetch&lt;/code&gt; 関数はスクレイピングするための HTML などを取ってくる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uniform&lt;/code&gt; 関数は実際に共通フォーマットに変換する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;といった具合だ(正直分けなくてもいい)．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;他にも GitHub・BitBacket・GitLab なんかを全部一緒に取り扱う &lt;code&gt;Repo&lt;/code&gt; とかも作ってもいいかもしれない． 問題は，自分が GitHub 以外に使ってないのでテストできない点だ．&lt;/p&gt;
&lt;h3 id="qiita-とか"&gt;Qiita とか&lt;/h3&gt;
&lt;p&gt;Qiita とかは RESTful API を叩いて記事を集めてる． そもそも記事自体を集めるところと，&lt;code&gt;Uniform&lt;/code&gt; 型クラスのインスタンスを共通化するのに &lt;code&gt;Service&lt;/code&gt; 型クラスを作った(名前が微妙)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Service&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  genInfo ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ServiceM&lt;/span&gt; [&lt;span class="dt"&gt;Info&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Proxy a&lt;/code&gt; なのはしょうがない． お好きなサービス(自分のサイトとかでも)を &lt;code&gt;Service&lt;/code&gt; 型クラスのインスタンスにして，&lt;code&gt;Whoami&lt;/code&gt; 型のインスタンスを書き換えれば，いろんなサイトを共通の形式で扱える．&lt;/p&gt;
&lt;h2 id="on-github-pages"&gt;on GitHub Pages&lt;/h2&gt;
&lt;p&gt;GitHub Pages で簡単に使えるようにした． サンプルのリポジトリを作ったので，これをフォークして Travis CI と GitHub Pages を設定するだけで使えるはずだ(もちろん &lt;code&gt;whoami.yaml&lt;/code&gt; を書き換えて)．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/matsubara0507/whoami-example"&gt;matsubara0507/whoami-example - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Stackage (というか Hackage)に置いていないツールを &lt;code&gt;stack install&lt;/code&gt; するために，&lt;code&gt;package.yaml&lt;/code&gt; と &lt;code&gt;stack.yaml&lt;/code&gt; と &lt;code&gt;.gitignore&lt;/code&gt; を置いてるけど気にしないで． Travis CI の定期実行を設定しておけば定期的に Qita の記事とかを更新してくれる．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;そーいえば，UNIX 系には &lt;code&gt;whoami&lt;/code&gt; というコマンドがあるんでしたね(Windowsユーザー)． 紛らわしい名前にしてしまった．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://haskell.jp/blog/posts/2018/topic-request.html</id><title type="text">Haskell-jp Blogで書いてほしいネタを募集します！</title><updated>2018-02-18T00:00:00Z</updated><author><name>Haskell-jp</name></author><link href="https://haskell.jp/blog/posts/2018/topic-request.html"/><summary type="html">&lt;article&gt;
    &lt;div class="container"&gt;
        &lt;div class="row"&gt;
            &lt;div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10"&gt;
                &lt;ul class="social-buttons"&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a href="https://twitter.com/share" class="twitter-share-button"&gt;Tweet&lt;/a&gt;
                        &lt;script&gt;!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;script type="text/javascript"&gt;
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        &lt;/script&gt;
                        &lt;script type="text/javascript" src="//www.redditstatic.com/button/button1.js"&gt;&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"&gt;&lt;/a&gt;
                        &lt;script type="text/javascript"&gt;!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"&gt;
              &lt;hr /&gt;
&lt;p&gt;&lt;span class="ascii"&gt;Haskell-jp Blog&lt;/span&gt;では、設立当初より&lt;span class="ascii"&gt;Haskell&lt;/span&gt;に関する記事を幅広く募集してきました。&lt;br /&gt;
このたびはそれに加え、この&lt;span class="ascii"&gt;Haskell-jp Blog&lt;/span&gt;で「書いて欲しい！」「読んでみたい！」&lt;span class="ascii"&gt;Haskell&lt;/span&gt;に関する話題も募集することにしました！ 例えば、下記のような話題が考えられるでしょう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;○○パッケージの解説記事が欲しい&lt;/li&gt;
&lt;li&gt;数学用語と&lt;span class="ascii"&gt;Haskell&lt;/span&gt;用語の対応関係が知りたい&lt;/li&gt;
&lt;li&gt;&lt;span class="ascii"&gt;Real World Haskell&lt;/span&gt;を今読むならの注意点&lt;/li&gt;
&lt;li&gt;そのほか、&lt;span class="ascii"&gt;Haskell&lt;/span&gt;に関する話題であれば何でも！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ただし、提案していただいたネタに関する知見の持ち主が居ないかもしれませんし、誰かの負担になるものなので必ず記事になるとは限りません。&lt;/strong&gt; また、場合によっては既に記事があるため、既存の記事を薦められるかもしれません。&lt;/p&gt;
&lt;h2 id="ネタを提案してくれる場合"&gt;ネタを提案してくれる場合&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/haskell-jp/blog/issues/new?template=topic-request.md&amp;amp;labels=Topic+Request"&gt;この&lt;span class="ascii"&gt;Blog&lt;/span&gt;のリポジトリの&lt;span class="ascii"&gt;Issue&lt;/span&gt;&lt;/a&gt;からお願いします。 既に提案されていたら、その&lt;span class="ascii"&gt;Issue&lt;/span&gt;に対して 👍 するといいと思います。&lt;/p&gt;
&lt;h2 id="書いてもいいよって場合"&gt;書いてもいいよって場合&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;TopicRequest&lt;/code&gt; というラベルを作ったので、&lt;a href="https://github.com/haskell-jp/blog/issues?q=is:issue+is:Aopen+label:%22Topic+Request%22"&gt;&lt;span class="ascii"&gt;Issue&lt;/span&gt;をそのラベルで検索&lt;/a&gt;してください。 書いてもいいという提案があった場合は、&lt;span class="ascii"&gt;Issue&lt;/span&gt;に「書いてもいいよ」という旨をコメントしていただけるとバッティングが無くて助かります。&lt;/p&gt;
&lt;p&gt;それでは、今後は&lt;span class="ascii"&gt;Haskell&lt;/span&gt;に関するあなたの記事だけでなく、あなたが&lt;span class="ascii"&gt;Haskell&lt;/span&gt;について読みたい記事も募集していきますので、どしどし応募してください！ 🙏&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div id="post-navigation" class="row" style="margin-top: 20px;"&gt;
            &lt;div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4"&gt;
                
                &lt;i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"&gt;&lt;/i&gt;
                &lt;a href="/posts/2018/windows-long-path.html"&gt;WindowsでHaskellを扱う時によく遭遇するNo such file or directoryについて&lt;/a&gt;
                
            &lt;/div&gt;
            &lt;div class="col-lg-2 col-md-2 col-xs-4 text-center"&gt;
                &lt;a href="/"&gt;トップに戻る&lt;/a&gt;
            &lt;/div&gt;
            &lt;div class="col-lg-3 col-md-4 col-xs-4"&gt;
                
                &lt;a href="/posts/2018/ghc-proposal-and-patch.html" style="margin-left: auto;"&gt;GHCへの変更提案とパッチ送付の手順例&lt;/a&gt;
                &lt;i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"&gt;&lt;/i&gt;
                
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/article&gt;

</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2018/02/14/160833</id><title type="text">Haskellの実行バイナリにファイルを埋め込む</title><updated>2018-02-14T16:12:25+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2018/02/14/160833"/><summary type="html">コンパイルしてできる実行バイナリにファイルを埋め込みたいことがある。
アプリのGUIで使うアイコンとか機械学習の学習済みモデルとか。
Go では (現在では非推奨らしいが) go-bindata を使う場面だろうか。

Haskell ではそういうときには [file-embed](https://hackage.haskell.org/package/file-embed) パッケージが使える。
たとえば `[project root]/resources/lorem.txt` に置かれた [lorem ipsum](https://ja.wikipedia.org/wiki/Lorem_ipsum) テキストを埋め込む場合:</summary></entry><entry><id>https://haskell.jp/blog/posts/2018/ghc-proposal-and-patch.html</id><title type="text">GHCへの変更提案とパッチ送付の手順例</title><updated>2018-02-11T00:00:00Z</updated><author><name>Haskell-jp</name></author><link href="https://haskell.jp/blog/posts/2018/ghc-proposal-and-patch.html"/><summary type="html">&lt;article&gt;
    &lt;div class="container"&gt;
        &lt;div class="row"&gt;
            &lt;div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10"&gt;
                &lt;ul class="social-buttons"&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a href="https://twitter.com/share" class="twitter-share-button"&gt;Tweet&lt;/a&gt;
                        &lt;script&gt;!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;script type="text/javascript"&gt;
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        &lt;/script&gt;
                        &lt;script type="text/javascript" src="//www.redditstatic.com/button/button1.js"&gt;&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"&gt;&lt;/a&gt;
                        &lt;script type="text/javascript"&gt;!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"&gt;
              &lt;hr /&gt;
&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;のコンパイラの１つである&lt;span class="ascii"&gt;GHC&lt;/span&gt;は、オープンソースソフトウェア&lt;span class="ascii"&gt;(OSS)&lt;/span&gt;のプロジェクトとして今も活発に開発が進められています。 個人の経験や経歴や肩書きや権限などに関わらず、誰でも&lt;span class="ascii"&gt;GHC&lt;/span&gt;の開発にすぐに参加することができます。&lt;/p&gt;
&lt;p&gt;ここでは、&lt;span class="ascii"&gt;GHC&lt;/span&gt;に新しい変更を提案し実装するための、以下の手順例を紹介します。&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="#ch1"&gt;変更提案&lt;/a&gt; &lt;span class="ascii"&gt;(GitHub&lt;/span&gt;の&lt;span class="ascii"&gt;ghc-proposals&lt;/span&gt; リポジトリ上にて実施&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ch2"&gt;パッチ送付&lt;/a&gt; &lt;span class="ascii"&gt;(Phabricator&lt;/span&gt;の&lt;span class="ascii"&gt;Haskell.org&lt;/span&gt; インスタンス上にて実施&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class="ascii"&gt;GHC&lt;/span&gt;に改善したい点があれば、誰でも変更提案が可能です。 提案のハードルは案外高いものではありません。&lt;span class="ascii"&gt;GHC&lt;/span&gt;開発では、新たな&lt;span class="ascii"&gt;contribution&lt;/span&gt;が歓迎されています。&lt;br /&gt;
仮に提案やパッチが&lt;span class="ascii"&gt;reject&lt;/span&gt;判断されるとしても、&lt;span class="ascii"&gt;GHC&lt;/span&gt;の開発者と直接やり取りする良い機会が得られます。&lt;/p&gt;
&lt;p&gt;以下では、数値リテラルの構文を変更する単純な例をもとに、変更提案やパッチ送付の手順例を紹介します。&lt;span class="ascii"&gt;(&lt;/span&gt;文章だらけになってしまいましたがご容赦を 😊 &lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="ch1"&gt;&lt;span class="ascii"&gt;1.&lt;/span&gt; 変更提案&lt;span class="ascii"&gt;(proposal)&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id="概要"&gt;概要&lt;/h3&gt;
&lt;p&gt;&lt;span class="ascii"&gt;GHC&lt;/span&gt;は、コンパイラ本体やライブラリやツールチェーンなど多くの要素で構成されていますが、ここではコンパイラ本体への変更提案の手順について紹介します。&lt;/p&gt;
&lt;p&gt;&lt;span class="ascii"&gt;GHC&lt;/span&gt;のコンパイラ本体の開発では、&lt;a href="https://github.com/ghc-proposals/ghc-proposals#what-is-a-proposal"&gt;ユーザーに見える&lt;span class="ascii"&gt;(user-visible)&lt;/span&gt;振る舞い&lt;/a&gt;等を変更&lt;span class="ascii"&gt;(&lt;/span&gt;追加・修正・削除など&lt;span class="ascii"&gt;)&lt;/span&gt;するための提案&lt;span class="ascii"&gt;(proposal)&lt;/span&gt;手順が定められています。 事前の調整や権限などを必要とせず、&lt;span class="ascii"&gt;GitHub&lt;/span&gt;への&lt;span class="ascii"&gt;pull request&lt;/span&gt;を通じて誰もが提案できます。&lt;/p&gt;
&lt;p&gt;なお、変更提案&lt;span class="ascii"&gt;(&lt;/span&gt;仕様&lt;span class="ascii"&gt;)&lt;/span&gt;のプロセスと、修正パッチ送付&lt;span class="ascii"&gt;(&lt;/span&gt;実装&lt;span class="ascii"&gt;)&lt;/span&gt;のプロセスは、分離されています。必ずしも、変更提案者が実装まで行う必要はありません。&lt;/p&gt;
&lt;h3 id="変更提案の正確な手続き"&gt;変更提案の正確な手続き&lt;/h3&gt;
&lt;p&gt;提案の具体的な手続きについては、以下に記載されています。よく読んでおきましょう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ghc-proposals/ghc-proposals#ghc-proposals"&gt;&lt;span class="ascii"&gt;https://github.com/ghc-proposals/ghc-proposals#ghc-proposals&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;変更提案は、提案書を書いて以下の場所&lt;span class="ascii"&gt;(&lt;/span&gt;リポジトリ&lt;span class="ascii"&gt;)&lt;/span&gt;に、&lt;span class="ascii"&gt;pull request&lt;/span&gt;を送ることで行えます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ghc-proposals/ghc-proposals/pulls"&gt;&lt;span class="ascii"&gt;https://github.com/ghc-proposals/ghc-proposals/pulls&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="変更提案のおおまかな流れ"&gt;変更提案のおおまかな流れ&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/ghc-proposals/ghc-proposals#what-is-the-timeline-of-a-proposal"&gt;提案の流れ&lt;/a&gt;は、ざくっと以下の通りです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提案の作成
&lt;ul&gt;
&lt;li&gt;&lt;span class="ascii"&gt;GitHub&lt;/span&gt;上で、&lt;a href="https://github.com/ghc-proposals/ghc-proposals"&gt;&lt;span class="ascii"&gt;ghc-proposals&lt;/span&gt;&lt;/a&gt;のリポジトリを&lt;span class="ascii"&gt;fork&lt;/span&gt;する &lt;a href="https://github.com/takenobu-hs/ghc-proposals"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="ascii"&gt;fork&lt;/span&gt;してきた自分のリポジトリで作業用のブランチを作る &lt;a href="https://github.com/takenobu-hs/ghc-proposals/tree/numeric-underscores"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="ascii"&gt;proposals&lt;/span&gt;ディレクトリの下に、“&lt;span class="ascii"&gt;0000-&lt;/span&gt;プロポーザル名&lt;span class="ascii"&gt;.rst&lt;/span&gt;”のファイル名で&lt;a href="https://github.com/ghc-proposals/ghc-proposals#how-to-start-a-new-proposal"&gt;提案用のファイルを作る&lt;/a&gt; &lt;a href="https://github.com/takenobu-hs/ghc-proposals/blob/numeric-underscores/proposals/0000-numeric-underscores.rst"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;“&lt;span class="ascii"&gt;Motivation&lt;/span&gt;”などの&lt;a href="https://github.com/ghc-proposals/ghc-proposals#what-should-a-proposal-look-like"&gt;必要な項目&lt;/a&gt;を、&lt;a href="http://docs.sphinx-users.jp/rest.html"&gt;&lt;span class="ascii"&gt;reStructuredText&lt;/span&gt;&lt;/a&gt;の書式に従い記述する &lt;a href="https://github.com/takenobu-hs/ghc-proposals/blob/numeric-underscores/proposals/0000-numeric-underscores.rst"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;提案の送付
&lt;ul&gt;
&lt;li&gt;&lt;span class="ascii"&gt;GitHub&lt;/span&gt;上で、&lt;span class="ascii"&gt;ghc-proposals&lt;/span&gt;のリポジトリに、&lt;span class="ascii"&gt;pull request&lt;/span&gt;を送る &lt;a href="https://github.com/ghc-proposals/ghc-proposals/pull/76"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;確定した&lt;span class="ascii"&gt;pull request&lt;/span&gt;の&lt;span class="ascii"&gt;URL&lt;/span&gt;を、提案用のファイルの“&lt;span class="ascii"&gt;This proposal is discussed at this pull request.&lt;/span&gt;”の箇所に記載してから、再度&lt;span class="ascii"&gt;commit&lt;/span&gt;し直す &lt;a href="https://github.com/takenobu-hs/ghc-proposals/commit/61149ee277aadc6bd46e0ad35aeb529f02da1182#diff-1128b179eb6630a402469b59a8a7dce6"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="ascii"&gt;pull request&lt;/span&gt;の &lt;span class="ascii"&gt;Conversation&lt;/span&gt;のところに、“&lt;span class="ascii"&gt;Rendered&lt;/span&gt;”という文字で提案ファイルへのリンクを貼っておく &lt;a href="https://github.com/ghc-proposals/ghc-proposals/pull/76#issue-261822915"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;提案についての議論
&lt;ul&gt;
&lt;li&gt;&lt;span class="ascii"&gt;pull request&lt;/span&gt;上で、&lt;a href="https://github.com/ghc-proposals/ghc-proposals#discussion-goals"&gt;議論する&lt;/a&gt; &lt;a href="https://github.com/ghc-proposals/ghc-proposals/pull/76"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;フィードバックがあれば、提案ファイルを修正する&lt;/li&gt;
&lt;li&gt;議論期間を充分に&lt;span class="ascii"&gt;(&lt;/span&gt;一ヶ月くらいは&lt;span class="ascii"&gt;)&lt;/span&gt;設ける&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;提案の判断
&lt;ul&gt;
&lt;li&gt;議論が収束したら、&lt;a href="https://github.com/ghc-proposals/ghc-proposals#who-is-the-committee"&gt;&lt;span class="ascii"&gt;GHC Steering Committee&lt;/span&gt;&lt;/a&gt; へ、&lt;a href="https://github.com/ghc-proposals/ghc-proposals#how-to-bring-a-proposal-before-the-committee"&gt;判断依頼&lt;/a&gt;をかける &lt;a href="https://github.com/ghc-proposals/ghc-proposals/pull/76#issuecomment-339952996"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="ascii"&gt;GHC Steering Committee&lt;/span&gt;が&lt;span class="ascii"&gt;Accepted/Rejected&lt;/span&gt;を判断する &lt;a href="https://github.com/ghc-proposals/ghc-proposals/pull/76#event-1341434473"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="ascii"&gt;Accepted&lt;/span&gt;なら、&lt;span class="ascii"&gt;Trac&lt;/span&gt;で&lt;a href="https://ghc.haskell.org/trac/ghc/newticket?type=task"&gt;&lt;span class="ascii"&gt;ticket&lt;/span&gt;を登録&lt;/a&gt;する &lt;a href="https://ghc.haskell.org/trac/ghc/ticket/14473"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;次は、コード修正パッチの作成・送付フェーズへ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="変更提案の例"&gt;変更提案の例&lt;/h3&gt;
&lt;p&gt;数値リテラルの構文を変更する場合の、具体的な変更提案の例を紹介します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/takenobu-hs/ghc-proposals/blob/0a694636560ca37d9b76e56bddc43c6bf1c9348a/proposals/0000-numeric-underscores.rst"&gt;変更提案の初版&lt;/a&gt; &lt;span class="ascii"&gt;|&lt;/span&gt; &lt;a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0009-numeric-underscores.rst"&gt;最終的な変更提案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ghc-proposals/ghc-proposals/pull/76"&gt;議論フェーズの例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;その他の提案の例は以下にたくさんあります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ghc-proposals/ghc-proposals/pulls?q=is%3Aopen+is%3Apr"&gt;&lt;span class="ascii"&gt;Open&lt;/span&gt;中の提案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ghc-proposals/ghc-proposals/pulls?q=is%3Apr+is%3Aclosed"&gt;&lt;span class="ascii"&gt;Close&lt;/span&gt;済みの提案&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="いくつかのポイントなど"&gt;いくつかのポイントなど&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;他の良い提案が参考になります &lt;span class="ascii"&gt;(&lt;/span&gt;同じ種類の提案や議論がうまく進んでいる提案などから、色々な観点を学べます。&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;数カ月単位で気長に根気よくやる&lt;span class="ascii"&gt;(&lt;/span&gt;開発者は全員がボランティアで忙しい。&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;提案してよいか迷う場合は、事前に&lt;a href="https://mail.haskell.org/cgi-bin/mailman/listinfo/ghc-devs"&gt;&lt;span class="ascii"&gt;ghc-devs&lt;/span&gt;の&lt;span class="ascii"&gt;ML(&lt;/span&gt;メーリングリスト&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;などで相談してもよい&lt;/li&gt;
&lt;li&gt;英語の精度を必要以上に気にする必要はない。日本語でしっかり考える。あとは短い文に区切って、&lt;span class="ascii"&gt;Google&lt;/span&gt;翻訳にでも。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;提案プロセスは&lt;span class="ascii"&gt;GitHub&lt;/span&gt;上で行うものです。操作ミスがあったところでやり直しは何度でも行えます。失敗やミスを不必要に怖れる必要はありません。&lt;br /&gt;
また、多くの提案は&lt;span class="ascii"&gt;Accepted&lt;/span&gt;に至らないこともあるので、結果を恥ずかしがる必要もありません。提案の結果に関わらず、提案とその議論自体が、他の開発者に新たな観点や気づき・刺激を提供できます。&lt;/p&gt;
&lt;p&gt;それでは、提案プロセスをお楽しみ！&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="ch2"&gt;&lt;span class="ascii"&gt;2.&lt;/span&gt; パッチ送付&lt;span class="ascii"&gt;(patch)&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id="概要-1"&gt;概要&lt;/h3&gt;
&lt;p&gt;&lt;span class="ascii"&gt;GHC&lt;/span&gt;への変更提案に対するコード修正は、パッチを作成して送付することにより行われます。 ここでは、コード開発ツールである&lt;span class="ascii"&gt;Phabricator&lt;/span&gt;の&lt;span class="ascii"&gt;differential&lt;/span&gt;機能を用いる、標準的なパッチ送付の手順について紹介します。&lt;/p&gt;
&lt;p&gt;なお、修正パッチは&lt;span class="ascii"&gt;GitHub&lt;/span&gt;の&lt;span class="ascii"&gt;pull request&lt;/span&gt;を通じても送付できますが、後のコードレビューのフェーズを考慮すると、&lt;span class="ascii"&gt;Phabricator&lt;/span&gt;を用いるこの手順が効率的です。&lt;/p&gt;
&lt;h3 id="パッチ送付の正確な手続き"&gt;パッチ送付の正確な手続き&lt;/h3&gt;
&lt;p&gt;パッチ作成から送付についての具体的な手続きについては以下に記載されています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://ghc.haskell.org/trac/ghc/wiki/WorkingConventions/FixingBugs"&gt;&lt;span class="ascii"&gt;How to contribute a patch to GHC&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ghc.haskell.org/trac/ghc/wiki/Phabricator"&gt;&lt;span class="ascii"&gt;Using Phabricator for GHC development&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、&lt;span class="ascii"&gt;Phabricator&lt;/span&gt;の詳細な操作手順については、以下に解説記事があります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://medium.com/@zw3rk/contributing-to-ghc-290653b63147"&gt;&lt;span class="ascii"&gt;Contributing to GHC via Phabricator&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="パッチ送付のおおまかな流れ"&gt;パッチ送付のおおまかな流れ&lt;/h3&gt;
&lt;p&gt;パッチ送付の流れは、ざくっと以下の通りです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パッチの作成
&lt;ul&gt;
&lt;li&gt;&lt;span class="ascii"&gt;GHC&lt;/span&gt;の&lt;span class="ascii"&gt;build/validate&lt;/span&gt;用環境を&lt;a href="https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation"&gt;整えておく&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="ascii"&gt;GHC&lt;/span&gt;のリポジトリを&lt;a href="https://ghc.haskell.org/trac/ghc/wiki/Building/GettingTheSources#CloningHEAD"&gt;&lt;span class="ascii"&gt;clone&lt;/span&gt;する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;事前に&lt;span class="ascii"&gt;master&lt;/span&gt;ブランチ上で、&lt;a href="https://ghc.haskell.org/trac/ghc/wiki/Building/QuickStart"&gt;&lt;span class="ascii"&gt;build&lt;/span&gt;できることを確認しておく&lt;/a&gt; &lt;span class="ascii"&gt;(master&lt;/span&gt;自体が&lt;span class="ascii"&gt;fail&lt;/span&gt;していることがあるため。&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;事前に&lt;span class="ascii"&gt;master&lt;/span&gt;ブランチ上で、&lt;a href="https://ghc.haskell.org/trac/ghc/wiki/TestingPatches#Locally"&gt;&lt;span class="ascii"&gt;validate&lt;/span&gt;が正常終了することを確認しておく&lt;/a&gt; &lt;span class="ascii"&gt;(master&lt;/span&gt;自体が&lt;span class="ascii"&gt;fail&lt;/span&gt;していることがあるため。&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;作業用のブランチを作り、コードを修正する
&lt;ul&gt;
&lt;li&gt;修正が１つの&lt;span class="ascii"&gt;commit&lt;/span&gt;にまとまっていると、後の&lt;span class="ascii"&gt;arc&lt;/span&gt;コマンドでのパッチ送付がラクです。“&lt;span class="ascii"&gt;git merge&lt;/span&gt; –&lt;span class="ascii"&gt;squash&lt;/span&gt;”でまとめられます。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ghc.haskell.org/trac/ghc/wiki/Building/RunningTests/Adding"&gt;テストケースを追加する&lt;/a&gt; &lt;a href="https://phabricator.haskell.org/D4235#change-AHneoV84zpis"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;必要に応じて&lt;a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/UserManual"&gt;ユーザーガイド&lt;/a&gt;に変更機能についての説明を追加する &lt;a href="https://phabricator.haskell.org/D4235#change-0p_6dVtsoCP3"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;修正コードにて&lt;span class="ascii"&gt;build&lt;/span&gt;できることを確認しておく&lt;span class="ascii"&gt;(&lt;/span&gt;必ず行う&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;修正コードにて&lt;span class="ascii"&gt;validate&lt;/span&gt;が正常終了することを確認しておく&lt;span class="ascii"&gt;(&lt;/span&gt;必ず行う&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;パッチの送付
&lt;ul&gt;
&lt;li&gt;&lt;span class="ascii"&gt;Phabricator&lt;/span&gt;用のコマンドラインツール&lt;a href="https://ghc.haskell.org/trac/ghc/wiki/Phabricator#TheCLI:Arcanist"&gt;&lt;span class="ascii"&gt;Arcanist&lt;/span&gt;をインストールする&lt;/a&gt; &lt;span class="ascii"&gt;(&lt;/span&gt;&lt;a href="https://secure.phabricator.com/book/phabricator/article/arcanist/"&gt;&lt;span class="ascii"&gt;arcanist&lt;/span&gt;ツールの説明&lt;/a&gt;&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ghc.haskell.org/trac/ghc/wiki/Phabricator#Startingoff:Fixingabugsubmittingareview"&gt;&lt;span class="ascii"&gt;Phabricator&lt;/span&gt;にパッチを送付する&lt;/a&gt; &lt;a href="https://phabricator.haskell.org/D4235"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;具体的なコマンドは“&lt;span class="ascii"&gt;arc diff HEAD~&lt;/span&gt;”。 最後の&lt;span class="ascii"&gt;commit&lt;/span&gt;が送信される。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="ascii"&gt;Trac&lt;/span&gt;の&lt;span class="ascii"&gt;ticket&lt;/span&gt;の、“&lt;span class="ascii"&gt;Differential Rev&lt;/span&gt;”の箇所に&lt;span class="ascii"&gt;Phab&lt;/span&gt;の管理番号を書いておく &lt;a href="https://ghc.haskell.org/trac/ghc/ticket/14473"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="ascii"&gt;Phabricator&lt;/span&gt;上で、コードレビューしてもらう（待つ、議論する）&lt;/li&gt;
&lt;li&gt;必要に応じてコードを修正する
&lt;ul&gt;
&lt;li&gt;コード修正後に、修正パッチを送り直すコマンドは“&lt;span class="ascii"&gt;arc diff&lt;/span&gt;”。&lt;/li&gt;
&lt;li&gt;レビュー待ちの間に、&lt;span class="ascii"&gt;master&lt;/span&gt;と&lt;span class="ascii"&gt;conflict&lt;/span&gt;を起こした場合は、パッチを送り直すと親切。&lt;/li&gt;
&lt;li&gt;レビュー待ちの間に、&lt;span class="ascii"&gt;master&lt;/span&gt;との差分が大きくなった場合は、“&lt;span class="ascii"&gt;git rebase&lt;/span&gt;”してから送り直すのも親切。&lt;span class="ascii"&gt;rebase&lt;/span&gt;については&lt;a href="https://ghc.haskell.org/trac/ghc/wiki/Phabricator#Workingwithmultipledependentdiffs"&gt;ここを参照&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;レビューが完了して&lt;span class="ascii"&gt;master&lt;/span&gt;ブランチに取り込まれたら、&lt;span class="ascii"&gt;proposals&lt;/span&gt;の“&lt;span class="ascii"&gt;implemented&lt;/span&gt;”のフィールドに、実装済みの&lt;span class="ascii"&gt;GHC&lt;/span&gt;のバージョン番号を記載しておく &lt;a href="https://github.com/ghc-proposals/ghc-proposals/commit/1974c2a45a782461084ea596ec839638d4ff0743#diff-ffb9f607b8f1e69494a276ae9afa8268"&gt;&lt;span class="ascii"&gt;(&lt;/span&gt;例&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="パッチ送付の例"&gt;パッチ送付の例&lt;/h3&gt;
&lt;p&gt;数値リテラルの構文を変更する場合の、具体的なパッチ送付の例を紹介します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://phabricator.haskell.org/D4235"&gt;&lt;span class="ascii"&gt;https://phabricator.haskell.org/D4235&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;その他のレビュー中パッチの例は以下にたくさんあります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://phabricator.haskell.org/differential/"&gt;&lt;span class="ascii"&gt;https://phabricator.haskell.org/differential/&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="いくつかのポイントなど-1"&gt;いくつかのポイントなど&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;他の良いパッチが参考になります&lt;span class="ascii"&gt;(&lt;/span&gt;同じ種類の修正を探すと、修正方法や慣習や修正漏れなどを確認できます。&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="ascii"&gt;build&lt;/span&gt;確認と&lt;span class="ascii"&gt;validation&lt;/span&gt;確認は絶対に行う&lt;span class="ascii"&gt;(&lt;/span&gt;つたないコードは問題視されませんが、本来行うべき手順を行わないことは、開発全体にダメージを与えるとともに、個人の信用度に影響します。&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;数カ月単位で気長に根気よくやる&lt;span class="ascii"&gt;(&lt;/span&gt;パッチ作業は多数並走しており、&lt;span class="ascii"&gt;GHC&lt;/span&gt;のリリース時期は特に多忙です。全員がボランティアで行っている自発的な活動ですので、忘れられている状況への&lt;span class="ascii"&gt;ping&lt;/span&gt;は構いませんが、強い催促は控えるのが賢明です。&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;わからない点は、&lt;span class="ascii"&gt;ghc-devs ML&lt;/span&gt;や&lt;span class="ascii"&gt;Phabricator&lt;/span&gt;上で相談するとよいでしょう。&lt;/li&gt;
&lt;li&gt;&lt;span class="ascii"&gt;Phabricator(arc&lt;/span&gt;コマンド&lt;span class="ascii"&gt;)&lt;/span&gt;には慣れが必要かと思います。最初は影響範囲の少ない、ドキュメント修正などで&lt;span class="ascii"&gt;Phabricator&lt;/span&gt;の作業手順に慣れていくのも良いです。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;パッチ送付は、&lt;span class="ascii"&gt;Phabricator&lt;/span&gt;や&lt;span class="ascii"&gt;git&lt;/span&gt;の機能を用いて行うものです。操作ミスがあったところで、&lt;span class="ascii"&gt;GHC&lt;/span&gt;のリポジトリ本体に直ちに反映されるわけではありません。やり直しは何度でも行えます。失敗やミスを不必要に怖れる必要はありません。&lt;span class="ascii"&gt;community&lt;/span&gt;のためになる&lt;span class="ascii"&gt;contribution&lt;/span&gt;は常に歓迎されています。&lt;/p&gt;
&lt;p&gt;それでは、パッチ送付プロセスをお楽しみ！&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="補足"&gt;補足&lt;/h2&gt;
&lt;p&gt;わからないことがあれば、&lt;a href="https://mail.haskell.org/cgi-bin/mailman/listinfo/ghc-devs"&gt;&lt;span class="ascii"&gt;ghc-devs&lt;/span&gt;の&lt;span class="ascii"&gt;ML&lt;/span&gt;&lt;/a&gt;に問い合わせると親切に教えてもらえます。 もちろん、&lt;a href="https://join-haskell-jp-slack.herokuapp.com/"&gt;&lt;span class="ascii"&gt;Haskell-jp&lt;/span&gt;の&lt;span class="ascii"&gt;slack&lt;/span&gt;&lt;/a&gt;の&lt;span class="ascii"&gt;#questions&lt;/span&gt;チャネルなどで尋ねるのも良いでしょう。&lt;/p&gt;
&lt;p&gt;なお、&lt;span class="ascii"&gt;GHC&lt;/span&gt;での開発作業については、&lt;a href="https://ghc.haskell.org/trac/ghc/wiki/WorkingConventions"&gt;&lt;span class="ascii"&gt;Working on GHC&lt;/span&gt;&lt;/a&gt;も参考にどうぞ。&lt;br /&gt;
また、&lt;span class="ascii"&gt;GHC&lt;/span&gt;の開発フロー全体については、&lt;a href="https://takenobu-hs.github.io/downloads/ghc_development_flow.pdf"&gt;こちら&lt;/a&gt;も参考にどうぞ。&lt;span class="ascii"&gt;GHC&lt;/span&gt;関連のサイトの情報を力づくで検索するには、&lt;a href="https://takenobu-hs.github.io/haskell-wiki-search/"&gt;こちら&lt;/a&gt;もどうぞ。&lt;/p&gt;
&lt;p&gt;&lt;span class="ascii"&gt;Happy Hacking!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div id="post-navigation" class="row" style="margin-top: 20px;"&gt;
            &lt;div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4"&gt;
                
                &lt;i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"&gt;&lt;/i&gt;
                &lt;a href="/posts/2018/topic-request.html"&gt;Haskell-jp Blogで書いてほしいネタを募集します！&lt;/a&gt;
                
            &lt;/div&gt;
            &lt;div class="col-lg-2 col-md-2 col-xs-4 text-center"&gt;
                &lt;a href="/"&gt;トップに戻る&lt;/a&gt;
            &lt;/div&gt;
            &lt;div class="col-lg-3 col-md-4 col-xs-4"&gt;
                
                &lt;a href="/posts/2018/unordered-containers-hash-dos.html" style="margin-left: auto;"&gt;hashdos脆弱性とunordered-containers&lt;/a&gt;
                &lt;i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"&gt;&lt;/i&gt;
                
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/article&gt;

</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-02-04-water-towers-hs.html</id><title type="text">「積み木の水槽」問題の Haskell での回答を読み解く</title><updated>2018-02-04T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-02-04-water-towers-hs.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;「積み木の水槽」問題の Haskell での回答を読み解く&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-02-04" itemprop="datePublished"&gt;
        Feb 4, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;今朝，バイト先で&lt;a href="http://nabetani.sakura.ne.jp/hena/ord13blocktup/"&gt;「積み木の水槽」問題&lt;/a&gt;の &lt;a href="https://rosettacode.org/wiki/Water_collected_between_towers#Haskell"&gt;Haskell での回答&lt;/a&gt;について話題になりました． リンク先の解答を見ると，恐ろしいことに，一行で書けてしまいます(正しくは，この解答では &lt;code&gt;nabetani&lt;/code&gt; さんの問題は解けませんが…)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="co"&gt;-- 2 == solve [1,5,3,7,2]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;solve &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="fu"&gt;.&lt;/span&gt; filter (&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;) &lt;span class="fu"&gt;.&lt;/span&gt; (zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (zipWith min &lt;span class="fu"&gt;.&lt;/span&gt; scanl1 max &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; scanr1 max))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;普通の Haskeller であれば，これぐらい目コンパイルして振る舞いを読み解くのは朝飯前でしょうが，Haskell 初学者のために簡単な解説を残しておこうかなと思います．&lt;/p&gt;
&lt;h2 id="手直し"&gt;手直し&lt;/h2&gt;
&lt;p&gt;前述したとおり，そもそもこれでは &lt;code&gt;nabetani&lt;/code&gt; さんの問題は解けないので，解けるように手直しします． もちろん &lt;strong&gt;1行で&lt;/strong&gt; ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;solve &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="fu"&gt;.&lt;/span&gt; fmap (sum &lt;span class="fu"&gt;.&lt;/span&gt; (zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (zipWith min &lt;span class="fu"&gt;.&lt;/span&gt; scanl1 max &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; scanr1 max)) &lt;span class="fu"&gt;.&lt;/span&gt; fmap (read &lt;span class="fu"&gt;.&lt;/span&gt; (&lt;span class="fu"&gt;:&lt;/span&gt; []))) &lt;span class="fu"&gt;.&lt;/span&gt; words &lt;span class="fu"&gt;.&lt;/span&gt; fmap (bool &lt;span class="ch"&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; (&lt;span class="fu"&gt;/=&lt;/span&gt;) &lt;span class="ch"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Data.List&lt;/code&gt; と &lt;code&gt;Data.Bool&lt;/code&gt; を &lt;code&gt;import&lt;/code&gt; してる前提だが，一応一行で書けた． 雑に直したのでもう少し短くできるような気もしますが，まぁそもそも本質的なところでないので勘弁してください．&lt;/p&gt;
&lt;p&gt;ちなみに，そもそもなんで元のコードでは解けないのかというと，&lt;code&gt;nabetani&lt;/code&gt; さんの問題には &lt;code&gt;0&lt;/code&gt; が含むからだ． しかし，&lt;code&gt;0&lt;/code&gt; で水槽を切り分けてあげて，元の解答を &lt;code&gt;map&lt;/code&gt; してあげれば良いだけなのでコアのところはそのまんま(&lt;code&gt;filter (&amp;gt; 0)&lt;/code&gt; は要らない気がしたので消したけど)．&lt;/p&gt;
&lt;h2 id="読み解く"&gt;読み解く&lt;/h2&gt;
&lt;p&gt;手直しした最終的なコードはテストコードと共に&lt;a href="https://gist.github.com/matsubara0507/10a44fb2a9676bde9658c3eeec456676"&gt;ココ&lt;/a&gt;にあげた．&lt;/p&gt;
&lt;h3 id="トップダウンに"&gt;トップダウンに&lt;/h3&gt;
&lt;p&gt;順に読み解く． Haskell でプログラミングするとき(というか関数型プログラミング)はトップダウンに書いていくのが基本なので，読み解くときも上から順に切り分けてく．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="ot"&gt;solve ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;solve &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="fu"&gt;.&lt;/span&gt; fmap countWater &lt;span class="fu"&gt;.&lt;/span&gt; splitTank&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;span class="ot"&gt;splitTank ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;String&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;splitTank &lt;span class="fu"&gt;=&lt;/span&gt;  words &lt;span class="fu"&gt;.&lt;/span&gt; fmap (bool &lt;span class="ch"&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; (&lt;span class="fu"&gt;/=&lt;/span&gt;) &lt;span class="ch"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;&lt;span class="ot"&gt;countWater ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;countWater &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="fu"&gt;.&lt;/span&gt; (zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (zipWith min &lt;span class="fu"&gt;.&lt;/span&gt; scanl1 max &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; scanr1 max)) &lt;span class="fu"&gt;.&lt;/span&gt; fmap (read &lt;span class="fu"&gt;.&lt;/span&gt; (&lt;span class="fu"&gt;:&lt;/span&gt; []))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;splitTank&lt;/code&gt; 関数は &lt;code&gt;0&lt;/code&gt; を区切り文字として文字列を切り分けてるだけだ． 悲しいことに，Haskell (というか GHC)の標準モジュールには「任意の文字で文字列を切り分ける」関数がない． なので，&lt;code&gt;0&lt;/code&gt; だけを空白 &lt;code&gt;' '&lt;/code&gt; に置換してから，&lt;code&gt;words&lt;/code&gt; で切り分けている(空白で切り分ける関数 &lt;code&gt;words&lt;/code&gt; は何故か標準にある)．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;countWater&lt;/code&gt; 関数が各水槽の水の数を数え上げており，それを最後に総和 &lt;code&gt;sum&lt;/code&gt; しているだけだ．&lt;/p&gt;
&lt;h3 id="fmap-はわかるよね"&gt;&lt;code&gt;fmap&lt;/code&gt; はわかるよね？&lt;/h3&gt;
&lt;p&gt;ちなみに，さっきから出てきている &lt;code&gt;fmap&lt;/code&gt; という関数はわかりますよね？ 多くの言語でも導入されている，リストや配列の各要素に関数を適用する関数(あるいはメソッド) &lt;code&gt;map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&lt;/code&gt; をより一般化したものだ． 今回はリストにしか使わないので &lt;code&gt;map&lt;/code&gt; と同義だと考えてくれていい(hlint で注意されるので，&lt;code&gt;fmap&lt;/code&gt; と書く癖がついた)．&lt;/p&gt;
&lt;h3 id="コアの部分"&gt;コアの部分&lt;/h3&gt;
&lt;p&gt;さて，本題でもある &lt;code&gt;countWater&lt;/code&gt; 関数を読み解く． まずは切り分けよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;countWater ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;countWater &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="fu"&gt;.&lt;/span&gt; toWaterLine &lt;span class="fu"&gt;.&lt;/span&gt; toInts&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;span class="ot"&gt;toInts ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;toInts &lt;span class="fu"&gt;=&lt;/span&gt; fmap (read &lt;span class="fu"&gt;.&lt;/span&gt; (&lt;span class="fu"&gt;:&lt;/span&gt; []))&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-7" data-line-number="7"&gt;&lt;span class="ot"&gt;toWaterLine ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-8" data-line-number="8"&gt;toWaterLine &lt;span class="fu"&gt;=&lt;/span&gt; zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (zipWith min &lt;span class="fu"&gt;.&lt;/span&gt; scanl1 max &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; scanr1 max)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;toInts&lt;/code&gt; 関数は数列の文字列から数値のリストに変換している． Haskell で文字列を任意の型に変換するには &lt;code&gt;read :: String -&amp;gt; a&lt;/code&gt; 関数を使う． Haskell において &lt;code&gt;String = [Char]&lt;/code&gt; なので，&lt;code&gt;fmap (: [])&lt;/code&gt; をして &lt;code&gt;String&lt;/code&gt; のリストに変換し，各文字列を &lt;code&gt;read&lt;/code&gt; をしているというわけだ(&lt;code&gt;singleton&lt;/code&gt; みたいな関数が標準にあればいいのに)．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;toWaterLine&lt;/code&gt; 関数が水槽の各列の水の量を計算し，&lt;code&gt;sum&lt;/code&gt; で総和している． なので，重要なのは &lt;code&gt;toWaterLine&lt;/code&gt; 関数だ． &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt; 演算子や &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; 演算子などがあって意味不明かもしれないが，この辺りはポイントフリーにするためのツールみたいなもので，アルゴリズムの本質的な部分ではないよ．&lt;/p&gt;
&lt;h3 id="関数も-monad-型クラスのインスタンス"&gt;関数も &lt;code&gt;Monad&lt;/code&gt; 型クラスのインスタンス&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt; 演算子や &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; 演算子が何をしているかと言うのは &lt;strong&gt;関数型 &lt;code&gt;(-&amp;gt;) a&lt;/code&gt; も &lt;code&gt;Monad&lt;/code&gt; 型クラスのインスタンス&lt;/strong&gt; だという事実を知っていれば簡単に読めますね． Haskell 界隈では常識(要出典)なので，説明しなくても良いかもしれないが，初学者のために念のためしておく．&lt;/p&gt;
&lt;p&gt;それぞれの演算子の型は以下の通り(めんどいので &lt;code&gt;Monad&lt;/code&gt; で統一)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="ot"&gt;(&amp;lt;*&amp;gt;) ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; m (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m b&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="ot"&gt;(=&amp;lt;&amp;lt;) ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m b&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;で，前述したとおり，関数型 &lt;code&gt;(c -&amp;gt;)&lt;/code&gt; も &lt;code&gt;Monad&lt;/code&gt; 型クラスのインスタンスなので，&lt;code&gt;m = (c -&amp;gt;)&lt;/code&gt; と置き換えれる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="ot"&gt;(&amp;lt;*&amp;gt;) ::&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="ot"&gt;(=&amp;lt;&amp;lt;) ::&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;便利そうなコンビネーターになった． なので，&lt;code&gt;toWaterLine&lt;/code&gt; 関数のこれらの演算子を同様のラムダ式で置き換えてあげよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="ot"&gt;toWaterLine ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;toWaterLine&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; \xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) ((\ys &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (zipWith min &lt;span class="fu"&gt;.&lt;/span&gt; scanl1 max &lt;span class="fu"&gt;$&lt;/span&gt; ys) (scanr1 max ys)) xs) xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; \xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) ((\ys &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; zipWith min (scanl1 max ys) (scanr1 max ys)) xs) xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; \xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; zipWith (&lt;span class="fu"&gt;-&lt;/span&gt;) (zipWith min (scanl1 max xs) (scanr1 max xs)) xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ついでに，他の言語の人では分かりにくい演算子も置き換えたので，これでどの言語の人でも読めるはずだ．&lt;/p&gt;
&lt;h3 id="アルゴリズム"&gt;アルゴリズム&lt;/h3&gt;
&lt;p&gt;ここからは Haskell 関係ない． ひとつひとつ見ていこう．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scanl :: (b -&amp;gt; a -&amp;gt; b) -&amp;gt; b -&amp;gt; [a] -&amp;gt; [b]&lt;/code&gt; 関数は左畳み込み関数 &lt;code&gt;foldl :: (b -&amp;gt; a -&amp;gt; b) -&amp;gt; b -&amp;gt; [a] -&amp;gt; b&lt;/code&gt; の途中経過もリストで残したような関数だ． つまり &lt;code&gt;foldl f x xs = last $ scanl f x xs&lt;/code&gt; が成り立つ． &lt;code&gt;scanl1 :: (a -&amp;gt; a -&amp;gt; a) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt; 関数は初期値を無くしたバージョンだ． &lt;code&gt;scanr1&lt;/code&gt; は &lt;code&gt;scanl1&lt;/code&gt; の右畳み込みバージョン．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;scanl max xs&lt;/code&gt; は左から順に，水槽の高さを比較して高い方を残しているので，各列の最も高い左側が残る． &lt;code&gt;scanr1 max xs&lt;/code&gt; は各列の最も高い右側が残る．&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/water-towers-hs/water1.gif" /&gt;&lt;/p&gt;
&lt;p&gt;そして，それらの低い方を残して，もとの高さを引く．&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/water-towers-hs/water2.gif" /&gt;&lt;/p&gt;
&lt;p&gt;すごいできた！&lt;/p&gt;
&lt;h2 id="試しに"&gt;試しに&lt;/h2&gt;
&lt;p&gt;次のテストコードを走らせてみた．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="co"&gt;-- WalterTowers.hs&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; all ((&lt;span class="fu"&gt;==&lt;/span&gt;) &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; snd &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; (show &lt;span class="fu"&gt;.&lt;/span&gt; solve &lt;span class="fu"&gt;.&lt;/span&gt; fst)) testSet&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;solve &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;&lt;span class="ot"&gt;testSet ::&lt;/span&gt; [(&lt;span class="dt"&gt;String&lt;/span&gt;, &lt;span class="dt"&gt;String&lt;/span&gt;)]&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;testSet &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" data-line-number="9"&gt;  [ (&lt;span class="st"&gt;&amp;quot;83141310145169154671122&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;24&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" data-line-number="10"&gt;  , (&lt;span class="st"&gt;&amp;quot;923111128&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;45&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" data-line-number="11"&gt;  , (&lt;span class="st"&gt;&amp;quot;923101128&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-12" data-line-number="12"&gt;  , (&lt;span class="st"&gt;&amp;quot;903111128&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;9&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-13" data-line-number="13"&gt;  , (&lt;span class="st"&gt;&amp;quot;3&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-14" data-line-number="14"&gt;  , (&lt;span class="st"&gt;&amp;quot;31&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-15" data-line-number="15"&gt;  , (&lt;span class="st"&gt;&amp;quot;412&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-16" data-line-number="16"&gt;  , (&lt;span class="st"&gt;&amp;quot;3124&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;3&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-17" data-line-number="17"&gt;  , (&lt;span class="st"&gt;&amp;quot;11111&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-18" data-line-number="18"&gt;  , (&lt;span class="st"&gt;&amp;quot;222111&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-19" data-line-number="19"&gt;  , (&lt;span class="st"&gt;&amp;quot;335544&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-20" data-line-number="20"&gt;  , (&lt;span class="st"&gt;&amp;quot;1223455321&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-21" data-line-number="21"&gt;  , (&lt;span class="st"&gt;&amp;quot;000&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-22" data-line-number="22"&gt;  , (&lt;span class="st"&gt;&amp;quot;000100020003121&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-23" data-line-number="23"&gt;  , (&lt;span class="st"&gt;&amp;quot;1213141516171819181716151413121&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;56&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-24" data-line-number="24"&gt;  , (&lt;span class="st"&gt;&amp;quot;712131415161718191817161514131216&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;117&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-25" data-line-number="25"&gt;  , (&lt;span class="st"&gt;&amp;quot;712131405161718191817161514031216&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;64&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-26" data-line-number="26"&gt;  , (&lt;span class="st"&gt;&amp;quot;03205301204342100&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-27" data-line-number="27"&gt;  , (&lt;span class="st"&gt;&amp;quot;0912830485711120342&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;18&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-28" data-line-number="28"&gt;  , (&lt;span class="st"&gt;&amp;quot;1113241120998943327631001&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;20&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-29" data-line-number="29"&gt;  , (&lt;span class="st"&gt;&amp;quot;7688167781598943035023813337019904732&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;41&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-30" data-line-number="30"&gt;  , (&lt;span class="st"&gt;&amp;quot;2032075902729233234129146823006063388&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;79&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-31" data-line-number="31"&gt;  , (&lt;span class="st"&gt;&amp;quot;8323636570846582397534533&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;44&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-32" data-line-number="32"&gt;  , (&lt;span class="st"&gt;&amp;quot;2142555257761672319599209190604843&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;41&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-33" data-line-number="33"&gt;  , (&lt;span class="st"&gt;&amp;quot;06424633785085474133925235&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;51&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-34" data-line-number="34"&gt;  , (&lt;span class="st"&gt;&amp;quot;503144400846933212134&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;21&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-35" data-line-number="35"&gt;  , (&lt;span class="st"&gt;&amp;quot;1204706243676306476295999864&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;21&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-36" data-line-number="36"&gt;  , (&lt;span class="st"&gt;&amp;quot;050527640248767717738306306596466224&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;29&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-37" data-line-number="37"&gt;  , (&lt;span class="st"&gt;&amp;quot;5926294098216193922825&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;65&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-38" data-line-number="38"&gt;  , (&lt;span class="st"&gt;&amp;quot;655589141599534035&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;29&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-39" data-line-number="39"&gt;  , (&lt;span class="st"&gt;&amp;quot;7411279689677738&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;34&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-40" data-line-number="40"&gt;  , (&lt;span class="st"&gt;&amp;quot;268131111165754619136819109839402&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;102&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-41" data-line-number="41"&gt;  ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;stack runghc&lt;/code&gt; で走らせると．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack runghc WalterTowers.hs
True&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;こういうのを自分で思いつけるようになりたいね…&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-01-31-fun-of-extensible-2.html</id><title type="text">拡張可能直和型を引数に取る関数の定義 (Haskell)</title><updated>2018-01-31T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-01-31-fun-of-extensible-2.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;拡張可能直和型を引数に取る関数の定義 (Haskell)&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-01-31" itemprop="datePublished"&gt;
        Jan 31, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/extensible-package.html"&gt;extensible-package&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;「&lt;a href="https://hackage.haskell.org/package/extensible"&gt;&lt;code&gt;extensible&lt;/code&gt;&lt;/a&gt; パッケージの楽しみ その２」です．&lt;/p&gt;
&lt;p&gt;拡張可能レコードやら Extensible Effect やら，Haskell の Extensible なものを全て統一された仕組みで提供する化け物パッケージ &lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1"&gt;&lt;code&gt;extensible&lt;/code&gt;&lt;/a&gt; について，割とドキュメントには無い(？)ネタを書いておくシリーズ第二弾です． ぼく自身は作者ではないし，間違っているかもなのでこの記事を完全には当てにしないでください．&lt;/p&gt;
&lt;p&gt;また，現在の最新バージョンは 0.4.7.1 です(そのバージョンでハナシをしてる)．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="/posts/2017-11-28-fun-of-extensible-1.html"&gt;前回&lt;/a&gt;は拡張可能レコードの拡縮の話を書きました． その最後の方に，おまけとして拡張可能直和型の話を書きました． 実際に自分のプログラムで，この拡張可能直和型を使おうとしてみたんですが，パターンマッチが分からず分岐が出来なかったので調べました，ってのが今回のハナシ．&lt;/p&gt;
&lt;p&gt;今回の Haskell コードは基本的に&lt;a href="https://github.com/matsubara0507/test-extensible/blob/master/src/Sample/Variant.hs"&gt;コレ&lt;/a&gt;．&lt;/p&gt;
&lt;h2 id="拡張可能直和型"&gt;拡張可能直和型&lt;/h2&gt;
&lt;p&gt;ここでは，Haskell の代数的データ型において&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Color&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RGB&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;CMYK&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;のように複数の値コンストラクタをとり得る型を直和型ということにします(あんまり一般的ではない？)． このようなデータ型を extensible を使って書くと次のようになる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Color&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;rgb&amp;quot;  &amp;gt;: (Int,Int,Int)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;cmyk&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; (&lt;span class="dt"&gt;Int&lt;/span&gt;,&lt;span class="dt"&gt;Int&lt;/span&gt;,&lt;span class="dt"&gt;Int&lt;/span&gt;,&lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これが拡張可能直和型である(と呼んでいる)． 例えば次のような，&lt;code&gt;Color&lt;/code&gt; 型の構造的に部分型である &lt;code&gt;RGB&lt;/code&gt; 型の値を &lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Inclusion.html#v:spread"&gt;&lt;code&gt;spread&lt;/code&gt;&lt;/a&gt; という関数を使って持ち上げることが出来る．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;ghci&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;RGB&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;rgb&amp;quot; &amp;gt;: (Int,Int,Int) ]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;ghci&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; color1 &lt;span class="fu"&gt;=&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;rgb &lt;span class="fu"&gt;@=&lt;/span&gt; (&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;RGB&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;ghci&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; color2 &lt;span class="fu"&gt;=&lt;/span&gt; spread&lt;span class="ot"&gt; color1 ::&lt;/span&gt; &lt;span class="dt"&gt;Color&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ちなみに「拡張可能直和型」って単語は，ほぼほぼ造語です(すいません)． 作者さんは &lt;strong&gt;Extensible Variants&lt;/strong&gt; と書いているので，正確には拡張可能バリアント型ですかね． ML 系では「バリアント型」って単語は良く使われてますが，Haskell では馴染みが無いので「直和型」って単語を用います．&lt;/p&gt;
&lt;h2 id="パターンマッチ"&gt;パターンマッチ&lt;/h2&gt;
&lt;p&gt;ここからが本題． 例として次のような図形の型を用いる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Shape&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Circle&lt;/span&gt; &lt;span class="dt"&gt;Point&lt;/span&gt; &lt;span class="dt"&gt;Double&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Rect&lt;/span&gt; &lt;span class="dt"&gt;Point&lt;/span&gt; &lt;span class="dt"&gt;Point&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Point&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; (&lt;span class="dt"&gt;Double&lt;/span&gt;, &lt;span class="dt"&gt;Double&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Circle&lt;/code&gt; が円で中心点の座標と半径を持ち，&lt;code&gt;Rect&lt;/code&gt; が矩形で左下と右上の座標を持つ． 例えば，図形の面積を求める関数 &lt;code&gt;area&lt;/code&gt; を書くときはパターンマッチを用いて次のように書きますよね．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="ot"&gt;area ::&lt;/span&gt; &lt;span class="dt"&gt;Shape&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Double&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;area (&lt;span class="dt"&gt;Circle&lt;/span&gt; _ r) &lt;span class="fu"&gt;=&lt;/span&gt; pi &lt;span class="fu"&gt;*&lt;/span&gt; (r &lt;span class="fu"&gt;^&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;area (&lt;span class="dt"&gt;Rect&lt;/span&gt; (x1,y1) (x2,y2)) &lt;span class="fu"&gt;=&lt;/span&gt; abs (x2 &lt;span class="fu"&gt;-&lt;/span&gt; x1) &lt;span class="fu"&gt;*&lt;/span&gt; abs (y2 &lt;span class="fu"&gt;-&lt;/span&gt; y1)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;では，この &lt;code&gt;Shape&lt;/code&gt; 型を拡張可能直和型で書いてみる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Shape&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;circle&amp;quot; &amp;gt;: Circle&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;rect&amp;quot;&lt;/span&gt;   &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Rect&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Point&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;x&amp;quot; &amp;gt;: Double, &amp;quot;y&amp;quot; &amp;gt;: Double ]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Circle&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;  &lt;span class="dt"&gt;Circle&lt;/span&gt; (&lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;mid&amp;quot; &amp;gt;: Point, &amp;quot;r&amp;quot; &amp;gt;: Double ]) deriving (Show, Eq)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-9" data-line-number="9"&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Rect&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-10" data-line-number="10"&gt;  &lt;span class="dt"&gt;Rect&lt;/span&gt; (&lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;ll&amp;quot; &amp;gt;: Point, &amp;quot;ur&amp;quot; &amp;gt;: Point ]) deriving (Show, Eq)&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Record&lt;/code&gt; は拡張可能レコードだ． 後の話の流れのために &lt;code&gt;newtype&lt;/code&gt; で &lt;code&gt;Circle&lt;/code&gt; 型と &lt;code&gt;Rect&lt;/code&gt; 型を定義したが，別に型エイリアスでもいい．&lt;/p&gt;
&lt;p&gt;問題はココからで，どうやって &lt;code&gt;area&lt;/code&gt; 関数を定義するか． (作者さんに聞いてしまえば早いんだけど)パッケージを漁ってたらそれらしい関数 &lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Match.html#v:match"&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; があった． イロイロ試した結果，&lt;code&gt;match&lt;/code&gt; よりも &lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Field.html#v:matchField"&gt;&lt;code&gt;matchField&lt;/code&gt;&lt;/a&gt; の方が使いやすかったので，こっちを使って次のように書ける．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="ot"&gt;area ::&lt;/span&gt; &lt;span class="dt"&gt;Shape&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Double&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;area &lt;span class="fu"&gt;=&lt;/span&gt; matchField&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;circle &lt;span class="fu"&gt;@=&lt;/span&gt; (\(&lt;span class="dt"&gt;Circle&lt;/span&gt; s) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; pi &lt;span class="fu"&gt;*&lt;/span&gt; (s &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;r) &lt;span class="fu"&gt;^&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;rect   &lt;span class="fu"&gt;@=&lt;/span&gt; ((&lt;span class="fu"&gt;*&lt;/span&gt;) &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; width &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; height)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-7" data-line-number="7"&gt;width,&lt;span class="ot"&gt; height ::&lt;/span&gt; &lt;span class="dt"&gt;Rect&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Double&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-8" data-line-number="8"&gt;width  (&lt;span class="dt"&gt;Rect&lt;/span&gt; s) &lt;span class="fu"&gt;=&lt;/span&gt; abs &lt;span class="fu"&gt;$&lt;/span&gt; s &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;ur &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;x &lt;span class="fu"&gt;-&lt;/span&gt; s &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;ll &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;x&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-9" data-line-number="9"&gt;height (&lt;span class="dt"&gt;Rect&lt;/span&gt; s) &lt;span class="fu"&gt;=&lt;/span&gt; abs &lt;span class="fu"&gt;$&lt;/span&gt; s &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;ur &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;y &lt;span class="fu"&gt;-&lt;/span&gt; s &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;ll &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;y&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;意外と簡単にできた！&lt;/p&gt;
&lt;p&gt;(なんでこれでうまくいくかを説明しようと思ったけど，ぼくには説明するのが難しすぎてやめた．) (ちなみに，すごい簡潔に書けるのは &lt;a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Wrapper.html#t:Wrapper"&gt;&lt;code&gt;Wrapper&lt;/code&gt;&lt;/a&gt; 型クラスのおかげだと思う．)&lt;/p&gt;
&lt;h2 id="型クラスを使う"&gt;型クラスを使う&lt;/h2&gt;
&lt;p&gt;ここからが拡張可能直和型のすごいところ(パターンマッチしかできないなら普通の直和型でもいいもんね…)． 型クラスを用いて次のようにも &lt;code&gt;area&lt;/code&gt; 関数を定義できる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Area&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  area ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Double&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Area&lt;/span&gt; &lt;span class="dt"&gt;Circle&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;  area (&lt;span class="dt"&gt;Circle&lt;/span&gt; s) &lt;span class="fu"&gt;=&lt;/span&gt; pi &lt;span class="fu"&gt;*&lt;/span&gt; (s &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;r) &lt;span class="fu"&gt;^&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Area&lt;/span&gt; &lt;span class="dt"&gt;Rect&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;  area &lt;span class="fu"&gt;=&lt;/span&gt; (&lt;span class="fu"&gt;*&lt;/span&gt;) &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; width &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; height&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" data-line-number="10"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Forall&lt;/span&gt; (&lt;span class="dt"&gt;KeyValue&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt; &lt;span class="dt"&gt;Area&lt;/span&gt;) xs &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Area&lt;/span&gt; (&lt;span class="dt"&gt;Variant&lt;/span&gt; xs) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" data-line-number="11"&gt;  area &lt;span class="fu"&gt;=&lt;/span&gt; matchField &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-12" data-line-number="12"&gt;    htabulateFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; (&lt;span class="dt"&gt;KeyValue&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt; &lt;span class="dt"&gt;Area&lt;/span&gt;)) &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-13" data-line-number="13"&gt;      \_ &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; area &lt;span class="fu"&gt;.&lt;/span&gt; runIdentity)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Forall (KeyValue KnownSymbol Area) xs&lt;/code&gt; という型制約の直観的な解釈は，型レベルリスト &lt;code&gt;xs&lt;/code&gt; の全ての要素 &lt;code&gt;k &amp;gt;: v&lt;/code&gt; が &lt;code&gt;KnownSymbol k&lt;/code&gt; と &lt;code&gt;Area v&lt;/code&gt; を満たす，という意味だ． 即ち，拡張可能直和型の全ての要素が &lt;code&gt;Area&lt;/code&gt; 型クラスのインスタンスであれば，その拡張可能直和型は &lt;code&gt;Area&lt;/code&gt; 型クラスのインスタンスになり得るのだ． ちゃんと次のように動作する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;ghci&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; shape1&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;&lt;span class="dt"&gt;EmbedAt&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt;(mkMembership &lt;span class="dv"&gt;0&lt;/span&gt;) (circle &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="dt"&gt;Circle&lt;/span&gt; (mid &lt;span class="fu"&gt;@=&lt;/span&gt; (x &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="fl"&gt;1.0&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; y &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="fl"&gt;2.0&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil) &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; r &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="fl"&gt;2.0&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil))&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;ghci&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t shape1&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;&lt;span class="ot"&gt;shape1 ::&lt;/span&gt; &lt;span class="dt"&gt;Shape&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;ghci&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; area shape1&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;&lt;span class="fl"&gt;12.566370614359172&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これの何がすごいかと言うと，例えば次のように &lt;code&gt;Shape&lt;/code&gt; 型を拡張しよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Triangle&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;  &lt;span class="dt"&gt;Triangle&lt;/span&gt; (&lt;span class="dt"&gt;Point&lt;/span&gt;, &lt;span class="dt"&gt;Point&lt;/span&gt;, &lt;span class="dt"&gt;Point&lt;/span&gt;) &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Eq&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Shape&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;circle&amp;quot; &amp;gt;: Circle&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;   , &lt;span class="st"&gt;&amp;quot;rect&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Rect&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;   , &lt;span class="st"&gt;&amp;quot;triangle&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Triangle&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般的な直和型の場合は，&lt;code&gt;Shape&lt;/code&gt; 型のパターンマッチしている部分を全て増やさないといけない． しかし，型クラスを用いた拡張可能直和型の関数であれば，次のようにインスタンスを増やすだけで良い．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Area&lt;/span&gt; &lt;span class="dt"&gt;Triangle&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;  area (&lt;span class="dt"&gt;Triangle&lt;/span&gt; (p1, p2, p3)) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;    abs ((p1 &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;x &lt;span class="fu"&gt;-&lt;/span&gt; p3 &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;x) &lt;span class="fu"&gt;*&lt;/span&gt; (p2 &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;y &lt;span class="fu"&gt;-&lt;/span&gt; p3 &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;y) &lt;span class="fu"&gt;-&lt;/span&gt; (p2 &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;x &lt;span class="fu"&gt;-&lt;/span&gt; p3 &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;x) &lt;span class="fu"&gt;*&lt;/span&gt; (p1 &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;y &lt;span class="fu"&gt;-&lt;/span&gt; p3 &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;y)) &lt;span class="fu"&gt;/&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;書き込んでる行数は大差ないかもしれないが，例えばファイルを分けたりなど，より柔軟に関数を定義できる！&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;ちなみに，&lt;code&gt;area&lt;/code&gt; 関数は &lt;code&gt;a -&amp;gt; Double&lt;/code&gt; で返り値の型が &lt;code&gt;Double&lt;/code&gt; だったから楽だった． これが，例えば座標移動をする &lt;code&gt;nudge :: a -&amp;gt; Point -&amp;gt; a&lt;/code&gt; のように，返り値が &lt;code&gt;a&lt;/code&gt; なものは &lt;code&gt;Variant&lt;/code&gt; のインスタンスを定義するのが大変(&lt;a href="https://github.com/matsubara0507/test-extensible/blob/d5e58f59ad4b1a2f4809bbecd79eeffbe04eec51/src/Sample/Variant.hs#L94"&gt;頑張った&lt;/a&gt;)．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-01-30-scraping-posts-on-adc.html</id><title type="text">AdC の Haskell 記事を Haskell で集めた</title><updated>2018-01-30T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-01-30-scraping-posts-on-adc.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;AdC の Haskell 記事を Haskell で集めた&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-01-30" itemprop="datePublished"&gt;
        Jan 30, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/application.html"&gt;application&lt;/a&gt; &lt;a href="/tags/scraping.html"&gt;scraping&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;昨年最後に，Haskell-jp へ以下の記事を寄稿しました．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://haskell.jp/blog/posts/2017/advent-calendar-2017.html"&gt;Haskell Advent Calendar 2017 まとめ - Haskell-jp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2017年のアドベントカレンダーに投稿された Haskell 記事を分類して紹介してるだけです． &lt;a href="https://scrapbox.io/miyamoen/Elm_Advent_Calendar_2017_まとめ"&gt;Elm のやつ&lt;/a&gt;を見かけて &lt;del&gt;パクリ&lt;/del&gt; オマージュしました．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;分類は温もりのある手作業ですが，Haskell 記事は機械的にあ集めました． 本記事はそのために作った Haskell プログラムに関するメモ書きです．&lt;/p&gt;
&lt;p&gt;全てのコードは以下のリポジトリにあります．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/matsubara0507/haskell-advent-calendar"&gt;matsubara0507/haskell-advent-calendar - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特に本質的な意味は無いんですが CLI として作っています．&lt;/p&gt;
&lt;h2 id="作る"&gt;作る&lt;/h2&gt;
&lt;p&gt;ゴールとしては，&lt;strong&gt;年を指定すると Qiita と ADVENTAR の全てのカレンダーをスクレイピングして，結果(Haskell 記事のリスト)を JSON ファイルに書き出す&lt;/strong&gt; プログラムを作る． Haskell に関する記事かどうかは，単純にカレンダーか記事のタイトルに “Haskell” という単語か含まれているかどうかで判断する．&lt;/p&gt;
&lt;h3 id="パッケージ"&gt;パッケージ&lt;/h3&gt;
&lt;p&gt;お世話になった主要なパッケージ達を先に示しておく(&lt;a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/master/package.yaml"&gt;package.yaml&lt;/a&gt; を見れば十分なんだけどね)．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/extensible"&gt;extensible&lt;/a&gt; : フィールド数の多いレコード型は拡張可能レコードにしちゃえ
&lt;ul&gt;
&lt;li&gt;フィールドへのアクセスには &lt;a href="https://hackage.haskell.org/package/lens"&gt;lens&lt;/a&gt; を用いる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/aeson"&gt;aeson&lt;/a&gt; : JSON の読み書きパッケージの金字塔
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/aeson-pretty"&gt;aeson-pretty&lt;/a&gt; : JSON を綺麗にインデントしてくれる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/scalpel-core"&gt;scalpel-core&lt;/a&gt; : スクレイパーパッケージ(core じゃなくて &lt;a href="https://hackage.haskell.org/package/scalpel"&gt;scalpel&lt;/a&gt; は Windows だとビルドめんどい)
&lt;ul&gt;
&lt;li&gt;Qiita の HTML の取得には &lt;a href="https://hackage.haskell.org/package/wreq"&gt;wreq&lt;/a&gt; を使った(操作が簡単なので)&lt;/li&gt;
&lt;li&gt;ADVENTAR は React 製なので &lt;a href="https://hackage.haskell.org/package/webdriver"&gt;webdriver&lt;/a&gt; で Selenium を使う&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/shelly"&gt;shelly&lt;/a&gt; : スクレイピングが攻撃にならんよう1秒スリープ(OSに依存せずに書ける)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/conduit-combinators"&gt;conduit-combinators&lt;/a&gt; : ストリーミングパッケージの金字塔
&lt;ul&gt;
&lt;li&gt;コッチの方が &lt;a href="https://hackage.haskell.org/package/conduit"&gt;conduit&lt;/a&gt; より名前の衝突なく関数が使えるので(大本は同じ)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/optparse-applicative"&gt;optparse-applicative&lt;/a&gt; : CLI の引数をいい感じに処理してくれる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今回の主目的ではないが，このプログラムは extensible の拡張可能レコードを用いた optparse-applicative のサンプルコードにもなっていると思う．&lt;/p&gt;
&lt;h3 id="記事の型を考える"&gt;記事の型を考える&lt;/h3&gt;
&lt;p&gt;最低限必要なのは，記事のタイトルと URL である． 他に，記事の著者と記事が投稿されたカレンダー・日付があった方が，あとで列挙するときに映えるだろう． ということで，以下の型を考えた．&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DataKinds         #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TypeOperators     #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Extensible&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Text&lt;/span&gt; (&lt;span class="dt"&gt;Text&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Post&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;   &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;title&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;    , &lt;span class="st"&gt;&amp;quot;auther&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;    , &lt;span class="st"&gt;&amp;quot;url&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;    , &lt;span class="st"&gt;&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;    , &lt;span class="st"&gt;&amp;quot;calendar&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Calendar&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;    , &lt;span class="st"&gt;&amp;quot;category&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" data-line-number="14"&gt;    ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" data-line-number="16"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-17" data-line-number="17"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-18" data-line-number="18"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-19" data-line-number="19"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Calendar&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-20" data-line-number="20"&gt;   &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;title&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-21" data-line-number="21"&gt;    , &lt;span class="st"&gt;&amp;quot;url&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-22" data-line-number="22"&gt;    ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;category&amp;quot;&lt;/code&gt; は後の(手作業による)分類で用いる． extensible による拡張可能レコードな型だが，何となく読めるだろう(分からなかったググって)．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;インターフェースを揃えるために，&lt;code&gt;Qiita&lt;/code&gt; や &lt;code&gt;ADVENTAR&lt;/code&gt; って感じの型から 記事のリスト &lt;code&gt;[Post]&lt;/code&gt; を返す型クラスを定義しておく(正直あんまり意味はない)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;ToPosts&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  getPosts ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; [&lt;span class="dt"&gt;Post&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;順にインスタンスを定義していく．&lt;/p&gt;
&lt;h3 id="adventar"&gt;ADVENTAR&lt;/h3&gt;
&lt;p&gt;&lt;a href="/posts/2017-12-02-re-adventar-slack-bot-part1.html"&gt;ADVENTAR は昔集めた&lt;/a&gt;ので簡単だ．&lt;/p&gt;
&lt;h4 id="カレンダーの記事を集める"&gt;カレンダーの記事を集める&lt;/h4&gt;
&lt;p&gt;まずは，カレンダーの URL を与えたら記事のリストを返す関数を書く．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Data.Text.IO&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;TIO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Shelly&lt;/span&gt; (shelly, sleep)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Test.WebDriver&lt;/span&gt; (&lt;span class="dt"&gt;WDConfig&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Text.HTML.Scalpel.Core&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Adventar&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Adventar&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt; &lt;span class="dt"&gt;WDConfig&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToPosts&lt;/span&gt; &lt;span class="dt"&gt;Adventar&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;  getPosts (&lt;span class="dt"&gt;Adventar&lt;/span&gt; url conf) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;    html &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; fetchHtmlWith conf url&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" data-line-number="11"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-12" data-line-number="12"&gt;    posts &lt;span class="fu"&gt;=&lt;/span&gt; fromMaybe [] &lt;span class="fu"&gt;$&lt;/span&gt; scrapeHtml postsScraper html&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-13" data-line-number="13"&gt;  TIO.putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;get posts on &amp;quot;&lt;/span&gt; &lt;span class="ot"&gt;`mappend`&lt;/span&gt; url&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-14" data-line-number="14"&gt;  shelly &lt;span class="fu"&gt;$&lt;/span&gt; sleep &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-15" data-line-number="15"&gt;  return posts&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-16" data-line-number="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-17" data-line-number="17"&gt;&lt;span class="ot"&gt;scrapeHtml ::&lt;/span&gt; &lt;span class="dt"&gt;Scraper&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-18" data-line-number="18"&gt;scrapeHtml &lt;span class="fu"&gt;=&lt;/span&gt; flip scrapeStringLike&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-19" data-line-number="19"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-20" data-line-number="20"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-21" data-line-number="21"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-22" data-line-number="22"&gt;&lt;span class="ot"&gt;fetchHtmlWith ::&lt;/span&gt; &lt;span class="dt"&gt;WDConfig&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-23" data-line-number="23"&gt;fetchHtmlWith &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-24" data-line-number="24"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-25" data-line-number="25"&gt;&lt;span class="ot"&gt;postsScraper ::&lt;/span&gt; &lt;span class="dt"&gt;Scraper&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt; [&lt;span class="dt"&gt;Post&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-26" data-line-number="26"&gt;postsScraper &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ADVENTAR のカレンダーのページは React 製(?)かなんからしく，静的な HTML からでは記事を参照することが出来ない そのために，Selenium などのヘッドレスブラウザを使ってアクセスする． &lt;code&gt;WDConfig&lt;/code&gt; は Haskell から Selenium などを操作するための Web Driver の設定値の型である．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shelly $ sleep 1&lt;/code&gt; はDOS攻撃にならないように，ここで処理を1秒止めるために書いている．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;fetchHtmlWith&lt;/code&gt; と &lt;code&gt;postsScraper&lt;/code&gt; はこんな感じ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;fetchHtmlWith ::&lt;/span&gt; &lt;span class="dt"&gt;WDConfig&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;fetchHtmlWith config url &lt;span class="fu"&gt;=&lt;/span&gt; runSession config &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;  openPage (unpack url)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;  html &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getSource&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;  closeSession&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" data-line-number="6"&gt;  return html&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Default&lt;/span&gt; (def)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;span class="ot"&gt;postsScraper ::&lt;/span&gt; &lt;span class="dt"&gt;Scraper&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt; [&lt;span class="dt"&gt;Post&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;postsScraper &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;  chroots (&lt;span class="st"&gt;&amp;quot;table&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;@:&lt;/span&gt; [hasClass &lt;span class="st"&gt;&amp;quot;mod-entryList&amp;quot;&lt;/span&gt;] &lt;span class="fu"&gt;//&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;tr&amp;quot;&lt;/span&gt;) entryScraper&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" data-line-number="7"&gt;&lt;span class="ot"&gt;entryScraper ::&lt;/span&gt; &lt;span class="dt"&gt;Scraper&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="dt"&gt;Post&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-8" data-line-number="8"&gt;entryScraper &lt;span class="fu"&gt;=&lt;/span&gt; hsequence&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-9" data-line-number="9"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;title    &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; titleScraper&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-10" data-line-number="10"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;auther   &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; autherScraper&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-11" data-line-number="11"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;url      &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; urlScraper&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-12" data-line-number="12"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date     &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; dateScraper&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-13" data-line-number="13"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;calendar &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; pure def&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-14" data-line-number="14"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;category &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; pure &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-15" data-line-number="15"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-16" data-line-number="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-17" data-line-number="17"&gt;&lt;span class="ot"&gt;autherScraper ::&lt;/span&gt; &lt;span class="dt"&gt;Scraper&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-18" data-line-number="18"&gt;autherScraper &lt;span class="fu"&gt;=&lt;/span&gt; text &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;td&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;@:&lt;/span&gt; [hasClass &lt;span class="st"&gt;&amp;quot;mod-entryList-user&amp;quot;&lt;/span&gt;] &lt;span class="fu"&gt;//&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;span&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-19" data-line-number="19"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-20" data-line-number="20"&gt;&lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;xxxScraper&lt;/code&gt; を全部書いてると長くなるので割愛(&lt;a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/f6d6a097c08e741239f576693e3d6b2b7ae21a29/src/AdventCalendar/Adventar/Scraper.hs"&gt;ココ&lt;/a&gt;に全部ある)．&lt;/p&gt;
&lt;h4 id="脱線-拡張可能レコードの-etc.."&gt;脱線 : 拡張可能レコードの etc..&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://hackage.haskell.org/package/extensible-0.4.7/docs/Data-Extensible-Field.html#v:-60--64--61--62-"&gt;&lt;code&gt;(&amp;lt;@=&amp;gt;)&lt;/code&gt;&lt;/a&gt; 演算子は拡張可能レコードの値を設定する演算子 &lt;a href="https://hackage.haskell.org/package/extensible-0.4.7/docs/Data-Extensible-Field.html#v:-64--61-"&gt;&lt;code&gt;(@=)&lt;/code&gt;&lt;/a&gt; のモナディック版(正確には &lt;code&gt;Functor&lt;/code&gt;)というイメージだ． &lt;strong&gt;かなり&lt;/strong&gt; 直感的に型を書くと次のようになる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="ot"&gt;(@=) ::&lt;/span&gt; k &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; v &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (k &lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; v)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="ot"&gt;(&amp;lt;@=&amp;gt;) ::&lt;/span&gt; &lt;span class="dt"&gt;Functor&lt;/span&gt; f &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; k &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; f v &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; f (k &lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; v)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拡張可能レコードはフィールド名とフィールドの値の型レベル辞書みたいなモノであり，&lt;code&gt;k :&amp;gt; v&lt;/code&gt; が辞書のイチ要素というイメージだ． &lt;a href="https://hackage.haskell.org/package/extensible-0.4.7/docs/Data-Extensible-Product.html#v:-60-:"&gt;&lt;code&gt;(&amp;lt;:)&lt;/code&gt;&lt;/a&gt; で &lt;code&gt;[kv1, kv2, ... kvn]&lt;/code&gt; のような辞書を構築する(&lt;a href="https://hackage.haskell.org/package/extensible-0.4.7/docs/Data-Extensible-Product.html#v:nil"&gt;&lt;code&gt;nil&lt;/code&gt;&lt;/a&gt; が空リスト)．&lt;/p&gt;
&lt;p&gt;&lt;a href="https://hackage.haskell.org/package/extensible-0.4.7/docs/Data-Extensible-Product.html#v:hsequence"&gt;&lt;code&gt;hsequence&lt;/code&gt;&lt;/a&gt; 関数で &lt;code&gt;[f (k1 :&amp;gt; v1), ..., f (kn :&amp;gt; vn)] -&amp;gt; f [(k1 :&amp;gt; v1), ... (kn :&amp;gt; vn)]&lt;/code&gt; という型の変換をしているイメージだ(あくまでイメージね)．&lt;/p&gt;
&lt;h2 id="section-3"&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;def&lt;/code&gt; は &lt;a href="https://hackage.haskell.org/package/data-default"&gt;data-default&lt;/a&gt; パッケージの値で，&lt;a href="https://hackage.haskell.org/package/data-default-0.7.1.1/docs/Data-Default.html#t:Default"&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; 型クラスのインスタンスにしないと使えない． 拡張可能レコードのインスタンス化の説明はめんどくさいので割愛する． &lt;a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/f6d6a097c08e741239f576693e3d6b2b7ae21a29/src/Data/Extensible/Instance/Default.hs"&gt;ココ&lt;/a&gt;に書いてあるので参照してください．&lt;/p&gt;
&lt;h4 id="カレンダーを加える"&gt;カレンダーを加える&lt;/h4&gt;
&lt;p&gt;このままだとカレンダーが &lt;code&gt;def&lt;/code&gt; のまま(URL もカレンダー名も &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;)なので，スクレイピングしたカレンダーの情報を加えよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Control.Lens&lt;/span&gt; (set)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Text&lt;/span&gt; (strip)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;getPosts (&lt;span class="dt"&gt;Adventar&lt;/span&gt; url conf) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;  html &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; fetchHtmlWith conf url&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" data-line-number="6"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-7" data-line-number="7"&gt;    posts &lt;span class="fu"&gt;=&lt;/span&gt; fromMaybe [] &lt;span class="fu"&gt;$&lt;/span&gt; scrapeHtml postsScraper html&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-8" data-line-number="8"&gt;    calendar&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-9" data-line-number="9"&gt;        &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;title &lt;span class="fu"&gt;@=&lt;/span&gt; fromMaybe &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt; (scrapeHtml headerTitleScraper html)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-10" data-line-number="10"&gt;       &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;url   &lt;span class="fu"&gt;@=&lt;/span&gt; url&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-11" data-line-number="11"&gt;       &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; emptyRecord&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-12" data-line-number="12"&gt;  TIO.putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;get posts on &amp;quot;&lt;/span&gt; &lt;span class="ot"&gt;`mappend`&lt;/span&gt; url&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-13" data-line-number="13"&gt;  shelly &lt;span class="fu"&gt;$&lt;/span&gt; sleep &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-14" data-line-number="14"&gt;  return &lt;span class="fu"&gt;$&lt;/span&gt; fmap (set &lt;span class="fu"&gt;#&lt;/span&gt;calendar calendar) posts&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-16" data-line-number="16"&gt;&lt;span class="ot"&gt;headerTitleScraper ::&lt;/span&gt; &lt;span class="dt"&gt;Scraper&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-17" data-line-number="17"&gt;headerTitleScraper &lt;span class="fu"&gt;=&lt;/span&gt; strip &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; text (&lt;span class="st"&gt;&amp;quot;head&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;//&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;title&amp;quot;&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;strip&lt;/code&gt; は文字列の前後の空白などを排除してくれる．&lt;/p&gt;
&lt;h4 id="カレンダーを集める"&gt;カレンダーを集める&lt;/h4&gt;
&lt;p&gt;カレンダーから記事を集めるだとまだ半分． カレンダー自体を集めないと全ての記事を確認できない．&lt;/p&gt;
&lt;p&gt;ADVENTAR の場合は，&lt;code&gt;&amp;quot;https://adventar.org/calendars?year=2017&lt;/code&gt; という URL で任意の年のカレンダーの一覧を取得できる． この URL からカレンダーの URL のリストを返す関数を定義する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="ot"&gt;getUrls ::&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; [&lt;span class="dt"&gt;URL&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;getUrls url &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;  html &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; fetchHtml url&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;  return &lt;span class="fu"&gt;$&lt;/span&gt; fromMaybe [] (scrapeHtml calendarUrlsScraper html)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;&lt;span class="ot"&gt;fetchHtml ::&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;fetchHtml url &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;  response &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; get &lt;span class="fu"&gt;$&lt;/span&gt; unpack url&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" data-line-number="9"&gt;  return &lt;span class="fu"&gt;$&lt;/span&gt; fromMaybe &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt; (decodeConvertText &lt;span class="fu"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;UTF8&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; response &lt;span class="fu"&gt;^.&lt;/span&gt; responseBody)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" data-line-number="11"&gt;&lt;span class="ot"&gt;calendarUrlsScraper ::&lt;/span&gt; &lt;span class="dt"&gt;Scraper&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt; [&lt;span class="dt"&gt;URL&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-12" data-line-number="12"&gt;calendarUrlsScraper &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-13" data-line-number="13"&gt;  chroots (&lt;span class="st"&gt;&amp;quot;div&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;@:&lt;/span&gt; [hasClass &lt;span class="st"&gt;&amp;quot;mod-calendarList&amp;quot;&lt;/span&gt;] &lt;span class="fu"&gt;//&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;ul&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;//&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;li&amp;quot;&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-14" data-line-number="14"&gt;    url &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; attr &lt;span class="st"&gt;&amp;quot;href&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-15" data-line-number="15"&gt;      (&lt;span class="st"&gt;&amp;quot;div&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;@:&lt;/span&gt; [hasClass &lt;span class="st"&gt;&amp;quot;mod-calendarList-title&amp;quot;&lt;/span&gt;]) &lt;span class="fu"&gt;//&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-16" data-line-number="16"&gt;    return &lt;span class="fu"&gt;$&lt;/span&gt; append &lt;span class="st"&gt;&amp;quot;http://adventar.org&amp;quot;&lt;/span&gt; url&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こっちは静的な HTML で動作するのでヘッドレスブラウザは使わない． ただ単に HTML の文字列さへ手に入ればいいので，扱うのが簡単な wreq を今回は使った． &lt;code&gt;get&lt;/code&gt; という関数に URL を適用するだけで，HTML (型は &lt;code&gt;ByteString&lt;/code&gt;) を返してくれる．&lt;/p&gt;
&lt;h5 id="vs.文字コード"&gt;vs. 文字コード&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;ByteString&lt;/code&gt; から &lt;code&gt;Text&lt;/code&gt; への変換はかなりめんどくさい． というのも，文字コード回りで簡単に例外を投げるからだ．&lt;/p&gt;
&lt;p&gt;例えば，記事のリンク先が PDF のようなバイナリファイルだと UTF-8 の &lt;code&gt;Text&lt;/code&gt; に変換できなくて例外を投げてくる． もちろん，カレンダーの URL を集める場合は，そんな心配は無いんだけど，Qiita のところで困る…&lt;/p&gt;
&lt;h2 id="section-4"&gt;&lt;/h2&gt;
&lt;p&gt;ちゃんとやるなら例外に合わせて処理を分けるべきだが，めんどくさいので例外を返す場合は &lt;code&gt;Nothing&lt;/code&gt; が返ってくる &lt;a href="https://hackage.haskell.org/package/text-conversions"&gt;text-conversions&lt;/a&gt; パッケージを文字列変換に用いた．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; decodeConvertText (&lt;span class="dt"&gt;UTF8&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;ByteString&lt;/span&gt;))&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;&lt;span class="dt"&gt;Just&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; decodeConvertText (&lt;span class="dt"&gt;UTF8&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;\xc3\x28&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;ByteString&lt;/span&gt;))&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;&lt;span class="dt"&gt;Nothing&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="インスタンスの更新"&gt;インスタンスの更新&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;getUrls&lt;/code&gt; を使ってインスタンスを書き換える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToPosts&lt;/span&gt; &lt;span class="dt"&gt;Adventar&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;  getPosts (&lt;span class="dt"&gt;Adventar&lt;/span&gt; url conf) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;    urls &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getUrls url&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;    mconcat &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; mapM (getPosts&amp;#39; conf) urls&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;&lt;span class="ot"&gt;getPosts&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;WDConfig&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; [&lt;span class="dt"&gt;Post&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;getPosts&amp;#39; conf url &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;  &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;getPosts'&lt;/code&gt; は，もともとの &lt;code&gt;getPosts&lt;/code&gt; 関数と同じ実装である． 扱うのが楽になるように，スマートコンストラクタを定義しておく．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="ot"&gt;adventar ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;WDConfig&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Adventar&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;adventar year &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;  &lt;span class="dt"&gt;Adventar&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;https://adventar.org/calendars?year=&amp;quot;&lt;/span&gt; &lt;span class="ot"&gt;`mappend`&lt;/span&gt; year&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;&lt;span class="ot"&gt;mkDriver ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;WDConfig&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" data-line-number="6"&gt;mkDriver host port &lt;span class="fu"&gt;=&lt;/span&gt; useBrowser chrome &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-7" data-line-number="7"&gt;  defaultConfig { wdHost &lt;span class="fu"&gt;=&lt;/span&gt; T.unpack host, wdPort &lt;span class="fu"&gt;=&lt;/span&gt; port }&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="haskell-の記事か否か"&gt;Haskell の記事か否か&lt;/h4&gt;
&lt;p&gt;分類はカレンダーか記事のタイトルに「Haskell」という単語か含まれるか否かで判断する． 雑だけど，自然言語処理とか良く分からないので勘弁して．&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="ot"&gt;isHaskellPost ::&lt;/span&gt; &lt;span class="dt"&gt;Post&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;isHaskellPost post &lt;span class="fu"&gt;=&lt;/span&gt; any (&lt;span class="st"&gt;&amp;quot;Haskell&amp;quot;&lt;/span&gt; &lt;span class="ot"&gt;`isInfixOf`&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;  [ post &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;title&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;  , post &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;calendar &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;title&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" data-line-number="5"&gt;  ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この関数を使って &lt;code&gt;filter&lt;/code&gt; すれば良い．&lt;/p&gt;
&lt;h4 id="実行"&gt;実行&lt;/h4&gt;
&lt;p&gt;Selenium を &lt;code&gt;localhost:4444&lt;/code&gt; として何らかの方法で起動しておく．&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="fu"&gt;$&lt;/span&gt; stack ghci&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;set &lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dt"&gt;XOverloadedStrings&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; fmap (filter isHaskellPost) &lt;span class="fu"&gt;.&lt;/span&gt; getPosts &lt;span class="fu"&gt;$&lt;/span&gt; adventar &lt;span class="st"&gt;&amp;quot;2017&amp;quot;&lt;/span&gt; (mkDriver &lt;span class="st"&gt;&amp;quot;localhost&amp;quot;&lt;/span&gt; &lt;span class="dv"&gt;4444&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;get posts on http&lt;span class="fu"&gt;://&lt;/span&gt;adventar&lt;span class="fu"&gt;.&lt;/span&gt;org&lt;span class="fu"&gt;/&lt;/span&gt;&lt;span class="dv"&gt;1111&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;&lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;すっごい時間かかるよ(笑)&lt;/p&gt;
&lt;h3 id="qiita"&gt;Qiita&lt;/h3&gt;
&lt;p&gt;やることは基本同じなのでサクッと．&lt;/p&gt;
&lt;h4 id="カレンダーの-url-を集める"&gt;カレンダーの URL を集める&lt;/h4&gt;
&lt;p&gt;Qiita の場合，カレンダーの一覧は複数ページに分かれている(URL は &lt;code&gt;https://qiita.com/advent-calendar/2017/calendars?page=1&lt;/code&gt; って感じ)． 無限リストで試しにカレンダーの一覧を取得し，ひとつも取得できなければ止めるようにする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="ot"&gt;getUrls ::&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; [&lt;span class="dt"&gt;URL&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;getUrls _ [] &lt;span class="fu"&gt;=&lt;/span&gt; pure []&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;getUrls url (n&lt;span class="fu"&gt;:&lt;/span&gt;ns) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" data-line-number="4"&gt;  result &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; func n&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-5" data-line-number="5"&gt;  &lt;span class="kw"&gt;case&lt;/span&gt; result &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-6" data-line-number="6"&gt;    [] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; pure result&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-7" data-line-number="7"&gt;    _  &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; mappend result &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; getUrls url ns&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-8" data-line-number="8"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-9" data-line-number="9"&gt;    func index &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-10" data-line-number="10"&gt;      html &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; fetchHtml &lt;span class="fu"&gt;$&lt;/span&gt; calendarsUrl url index&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-11" data-line-number="11"&gt;      shelly &lt;span class="fu"&gt;$&lt;/span&gt; sleep &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-12" data-line-number="12"&gt;      return &lt;span class="fu"&gt;$&lt;/span&gt; fromMaybe [] (scrapeHtml calendarUrlsScraper html)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-14" data-line-number="14"&gt;&lt;span class="ot"&gt;calendarsUrl ::&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-15" data-line-number="15"&gt;calendarsUrl url index &lt;span class="fu"&gt;=&lt;/span&gt; mconcat [url, &lt;span class="st"&gt;&amp;quot;?page=&amp;quot;&lt;/span&gt;, pack &lt;span class="fu"&gt;$&lt;/span&gt; show index]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-16" data-line-number="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-17" data-line-number="17"&gt;&lt;span class="ot"&gt;calendarUrlsScraper ::&lt;/span&gt; &lt;span class="dt"&gt;Scraper&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt; [&lt;span class="dt"&gt;URL&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-18" data-line-number="18"&gt;calendarUrlsScraper &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-19" data-line-number="19"&gt;  chroots (&lt;span class="st"&gt;&amp;quot;table&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;@:&lt;/span&gt; [hasClass &lt;span class="st"&gt;&amp;quot;adventCalendarList&amp;quot;&lt;/span&gt;] &lt;span class="fu"&gt;//&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;tbody&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;//&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;tr&amp;quot;&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-20" data-line-number="20"&gt;    url &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; attr &lt;span class="st"&gt;&amp;quot;href&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-21" data-line-number="21"&gt;      (&lt;span class="st"&gt;&amp;quot;td&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;@:&lt;/span&gt; [hasClass &lt;span class="st"&gt;&amp;quot;adventCalendarList_calendarTitle&amp;quot;&lt;/span&gt;]) &lt;span class="fu"&gt;//&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-22" data-line-number="22"&gt;    return &lt;span class="fu"&gt;$&lt;/span&gt; append &lt;span class="st"&gt;&amp;quot;http://qiita.com&amp;quot;&lt;/span&gt; url&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;なんかもっといい方法ありそう．&lt;/p&gt;
&lt;h4 id="カレンダーを集める-1"&gt;カレンダーを集める&lt;/h4&gt;
&lt;p&gt;インスタンスを定義しよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Qiita&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Qiita&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToPosts&lt;/span&gt; &lt;span class="dt"&gt;Qiita&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;  getPosts (&lt;span class="dt"&gt;Qiita&lt;/span&gt; url) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;    urls &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getUrls url [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;    mconcat &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; mapM getPosts&amp;#39; urls&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;&lt;span class="ot"&gt;getPosts&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; [&lt;span class="dt"&gt;Post&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;getPosts&amp;#39; url &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-10" data-line-number="10"&gt;  html &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; fetchHtml url&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-11" data-line-number="11"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-12" data-line-number="12"&gt;    posts &lt;span class="fu"&gt;=&lt;/span&gt; fromMaybe [] &lt;span class="fu"&gt;$&lt;/span&gt; scrapeHtml postsScraper html&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-13" data-line-number="13"&gt;    calendar&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-14" data-line-number="14"&gt;        &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;title &lt;span class="fu"&gt;@=&lt;/span&gt; fromMaybe &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt; (scrapeHtml headerTitleScraper html)&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-15" data-line-number="15"&gt;       &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;url   &lt;span class="fu"&gt;@=&lt;/span&gt; url&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-16" data-line-number="16"&gt;       &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; emptyRecord&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-17" data-line-number="17"&gt;  TIO.putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;get posts on &amp;quot;&lt;/span&gt; &lt;span class="ot"&gt;`mappend`&lt;/span&gt; url&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-18" data-line-number="18"&gt;  shelly &lt;span class="fu"&gt;$&lt;/span&gt; sleep &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-19" data-line-number="19"&gt;  return &lt;span class="fu"&gt;$&lt;/span&gt; fmap (set &lt;span class="fu"&gt;#&lt;/span&gt;calendar calendar) posts&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-20" data-line-number="20"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-21" data-line-number="21"&gt;&lt;span class="ot"&gt;postsScraper ::&lt;/span&gt; &lt;span class="dt"&gt;Scraper&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt; [&lt;span class="dt"&gt;Post&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-22" data-line-number="22"&gt;postsScraper &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;長いのでスクレイパーは割愛(&lt;a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/f6d6a097c08e741239f576693e3d6b2b7ae21a29/src/AdventCalendar/Qiita/Scraper.hs"&gt;ココ&lt;/a&gt;にある)． &lt;code&gt;fetchHtml&lt;/code&gt; 関数は ADVENTAR のと同じ．&lt;/p&gt;
&lt;h4 id="記事のタイトルを取得"&gt;記事のタイトルを取得&lt;/h4&gt;
&lt;p&gt;ADVENTAR と違い，Qiita のカレンダーには各記事のタイトルが書いてない． さすがに「なんか書く」で Haskell 記事か否かを判断するのもなぁと思い，どーーーー考えても時間がかかるけど，記事をひとつひとつスクレイピングしてタイトルを取ってくることにした．&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="ot"&gt;getPosts&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;URL&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; [&lt;span class="dt"&gt;Post&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;getPosts&amp;#39; url &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-4" data-line-number="4"&gt;  TIO.putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;get posts on &amp;quot;&lt;/span&gt; &lt;span class="ot"&gt;`mappend`&lt;/span&gt; url&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-5" data-line-number="5"&gt;  shelly &lt;span class="fu"&gt;$&lt;/span&gt; sleep &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-6" data-line-number="6"&gt;  mapM updatePostTitle&amp;#39; &lt;span class="fu"&gt;$&lt;/span&gt; set &lt;span class="fu"&gt;#&lt;/span&gt;calendar calendar &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; posts&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-8" data-line-number="8"&gt;&lt;span class="ot"&gt;updatePostTitle ::&lt;/span&gt; &lt;span class="dt"&gt;Post&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Post&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-9" data-line-number="9"&gt;updatePostTitle post &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-10" data-line-number="10"&gt;html &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; fetchHtml&amp;#39; &lt;span class="fu"&gt;$&lt;/span&gt; post &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;url&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-11" data-line-number="11"&gt;&lt;span class="kw"&gt;let&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-12" data-line-number="12"&gt;  title &lt;span class="fu"&gt;=&lt;/span&gt; fromMaybe (post &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;title) &lt;span class="fu"&gt;$&lt;/span&gt; scrapeHtml headerTitleScraper html&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-13" data-line-number="13"&gt;return &lt;span class="fu"&gt;$&lt;/span&gt; post &lt;span class="fu"&gt;&amp;amp;&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;title &lt;span class="fu"&gt;.~&lt;/span&gt; title&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-14" data-line-number="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-15" data-line-number="15"&gt;&lt;span class="ot"&gt;updatePostTitle&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;Post&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Post&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-16" data-line-number="16"&gt;updatePostTitle&amp;#39; post &lt;span class="fu"&gt;=&lt;/span&gt; shelly (sleep &lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; updatePostTitle post&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;updatePostTitle'&lt;/code&gt; 関数で(1秒だけスリープしつつ)タイトルをスクレイピングして更新している．&lt;/p&gt;
&lt;h4 id="実行してみる"&gt;実行してみる&lt;/h4&gt;
&lt;p&gt;スマートコンストラクタを作って．&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" data-line-number="1"&gt;&lt;span class="ot"&gt;qiita ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Qiita&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-2" data-line-number="2"&gt;qiita year &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-3" data-line-number="3"&gt;  &lt;span class="dt"&gt;Qiita&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; mconcat [&lt;span class="st"&gt;&amp;quot;https://qiita.com/advent-calendar/&amp;quot;&lt;/span&gt;, year, &lt;span class="st"&gt;&amp;quot;/calendars&amp;quot;&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実行してみる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb18-1" data-line-number="1"&gt;&lt;span class="fu"&gt;$&lt;/span&gt; stack ghci&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-2" data-line-number="2"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;set &lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dt"&gt;XOverloadedStrings&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-3" data-line-number="3"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; fmap (filter isHaskellPost) &lt;span class="fu"&gt;.&lt;/span&gt; getPosts &lt;span class="fu"&gt;$&lt;/span&gt; qiita &lt;span class="st"&gt;&amp;quot;2017&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-4" data-line-number="4"&gt;&lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;悲しいことに，鬼のように時間がかかるのに…メモリダンプします… まぁわかってたけどね！&lt;/p&gt;
&lt;h3 id="ストリーミング"&gt;ストリーミング&lt;/h3&gt;
&lt;p&gt;こういうパフォーマンス的なことは自分は詳しくない． しかしこういうのはたぶん，要らないデータ(&lt;code&gt;filter&lt;/code&gt; して捨てるデータ)をいつ迄も保持してるのが悪いので(たぶん)，ストリーミングパッケージを使って効率よくリソース管理してもらおう．&lt;/p&gt;
&lt;p&gt;今回は Conduit を使う． 最初は Pipes を使ってみたけど，よくわからなくてやめた．&lt;/p&gt;
&lt;h2 id="section-5"&gt;&lt;/h2&gt;
&lt;p&gt;まずはインターフェースの型クラスを書き換える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb19-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt; (&lt;span class="dt"&gt;Source&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-3" data-line-number="3"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;ToPosts&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-4" data-line-number="4"&gt;&lt;span class="ot"&gt;  getPosts ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Source&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Post&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;あとはそれぞれのインスタンスを書き換えるだけ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb20-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToPosts&lt;/span&gt; &lt;span class="dt"&gt;Adventar&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-2" data-line-number="2"&gt;  getPosts (&lt;span class="dt"&gt;Adventar&lt;/span&gt; url conf) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-3" data-line-number="3"&gt;    urls &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lift &lt;span class="fu"&gt;$&lt;/span&gt; getUrls url&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-4" data-line-number="4"&gt;    yieldMany urls &lt;span class="fu"&gt;=$=&lt;/span&gt; concatMapMC (getPosts&amp;#39; conf)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb21-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToPosts&lt;/span&gt; &lt;span class="dt"&gt;Qiita&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-2" data-line-number="2"&gt;  getPosts (&lt;span class="dt"&gt;Qiita&lt;/span&gt; url) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-3" data-line-number="3"&gt;    urls &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lift &lt;span class="fu"&gt;$&lt;/span&gt; getUrls url [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-4" data-line-number="4"&gt;    yieldMany urls &lt;span class="fu"&gt;=$=&lt;/span&gt; concatMapMC getPosts&amp;#39;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使うときは以下のようにすればよい．&lt;/p&gt;
&lt;div class="sourceCode" id="cb22"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb22-1" data-line-number="1"&gt;&lt;span class="fu"&gt;$&lt;/span&gt; stack ghci&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-2" data-line-number="2"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;set &lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dt"&gt;XOverloadedStrings&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-3" data-line-number="3"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt; (($$), (=$=), sinkList)&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-4" data-line-number="4"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; getPosts (qiita &lt;span class="st"&gt;&amp;quot;2017&amp;quot;&lt;/span&gt;) &lt;span class="fu"&gt;$=&lt;/span&gt; filterC isHaskellPost &lt;span class="fu"&gt;$$&lt;/span&gt; sinkList&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="json-に書き出す"&gt;JSON に書き出す&lt;/h3&gt;
&lt;p&gt;前にやったものをそのままコピペした．&lt;/p&gt;
&lt;div class="sourceCode" id="cb23"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb23-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Aeson.Encode.Pretty&lt;/span&gt; (encodePrettyToTextBuilder)&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Text&lt;/span&gt; (&lt;span class="dt"&gt;Text&lt;/span&gt;, unpack)&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Text.Lazy.Builder&lt;/span&gt; (toLazyText)&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Data.Text.Lazy.IO&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;LT&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-6" data-line-number="6"&gt;&lt;span class="ot"&gt;writeJson ::&lt;/span&gt; &lt;span class="dt"&gt;ToJSON&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-7" data-line-number="7"&gt;writeJson jsonPath &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-8" data-line-number="8"&gt;  &lt;span class="dt"&gt;LT&lt;/span&gt;&lt;span class="fu"&gt;.&lt;/span&gt;writeFile (unpack jsonPath) &lt;span class="fu"&gt;.&lt;/span&gt; toLazyText &lt;span class="fu"&gt;.&lt;/span&gt; encodePrettyToTextBuilder&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拡張可能レコードの &lt;code&gt;ToJSON&lt;/code&gt; のインスタンス化の部分は割愛(&lt;a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/f6d6a097c08e741239f576693e3d6b2b7ae21a29/src/Data/Extensible/Instance/Aeson.hs"&gt;ココ&lt;/a&gt;にある)．&lt;/p&gt;
&lt;h3 id="コマンド化"&gt;コマンド化&lt;/h3&gt;
&lt;p&gt;CLI のオプション(引数)のパースには optparse-applicative パッケージを使う． スクレイピングには，次のようなオプションの型を考える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb24"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb24-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Cmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Fetch&lt;/span&gt; &lt;span class="dt"&gt;FetchOptions&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-4" data-line-number="4"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;FetchOptions&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-5" data-line-number="5"&gt;   &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;year&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-6" data-line-number="6"&gt;    , &lt;span class="st"&gt;&amp;quot;qiita&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-7" data-line-number="7"&gt;    , &lt;span class="st"&gt;&amp;quot;adventar&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-8" data-line-number="8"&gt;    , &lt;span class="st"&gt;&amp;quot;wdHost&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-9" data-line-number="9"&gt;    , &lt;span class="st"&gt;&amp;quot;wdPort&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-10" data-line-number="10"&gt;    , &lt;span class="st"&gt;&amp;quot;output&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-11" data-line-number="11"&gt;    ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;year&lt;/code&gt; はスクレイピングして欲しい年． &lt;code&gt;qiita&lt;/code&gt; や &lt;code&gt;adventar&lt;/code&gt; は &lt;code&gt;--qiita&lt;/code&gt; って感じのフラグで，フラグが真のものだけ集めてくる(両方偽の場合は，両方真と同じく両方集める)． &lt;code&gt;wdHost&lt;/code&gt; と &lt;code&gt;wdPort&lt;/code&gt; はヘッドレスブラウザへのオプションで，指定が無ければ &lt;code&gt;localhost:4444&lt;/code&gt; をデフォルト値にする． &lt;code&gt;output&lt;/code&gt; は &lt;code&gt;-o hoge.json&lt;/code&gt; みたいに出力先のファイルを指定する．&lt;/p&gt;
&lt;h2 id="section-6"&gt;&lt;/h2&gt;
&lt;p&gt;例の如く，拡張可能レコードなので，&lt;code&gt;(&amp;lt;@=&amp;gt;)&lt;/code&gt; 演算子を使ってパーサーを組み立てていく．&lt;/p&gt;
&lt;div class="sourceCode" id="cb25"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb25-1" data-line-number="1"&gt;&lt;span class="ot"&gt;cmdParser ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;Cmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-2" data-line-number="2"&gt;cmdParser &lt;span class="fu"&gt;=&lt;/span&gt; subparser &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-3" data-line-number="3"&gt;     command &lt;span class="st"&gt;&amp;quot;fetch&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-4" data-line-number="4"&gt;       (&lt;span class="dt"&gt;Fetch&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; fetchOptsParser &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;fetch posts on advent calendar to json file.&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-5" data-line-number="5"&gt;  &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; metavar &lt;span class="st"&gt;&amp;quot;( fetch )&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-6" data-line-number="6"&gt;  &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; help &lt;span class="st"&gt;&amp;quot;choice subcommand&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-8" data-line-number="8"&gt;&lt;span class="ot"&gt;fetchOptsParser ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;FetchOptions&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-9" data-line-number="9"&gt;fetchOptsParser &lt;span class="fu"&gt;=&lt;/span&gt; hsequence&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-10" data-line-number="10"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;year     &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; yearParser&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-11" data-line-number="11"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;qiita    &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; qiitaFlagParser&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-12" data-line-number="12"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;adventar &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; adventarFlagParser&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-13" data-line-number="13"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;wdHost   &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; wdHostParser&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-14" data-line-number="14"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;wdPort   &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; wdPortParser&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-15" data-line-number="15"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;output   &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; outputParser&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-16" data-line-number="16"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;細かいやつは割愛(&lt;a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/f6d6a097c08e741239f576693e3d6b2b7ae21a29/app/Options.hs"&gt;ココ&lt;/a&gt;を見て)．&lt;/p&gt;
&lt;h2 id="section-7"&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; 関数も長いので割愛(&lt;a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/f6d6a097c08e741239f576693e3d6b2b7ae21a29/app/Main.hs"&gt;ココ&lt;/a&gt;を見て)．&lt;/p&gt;
&lt;p&gt;こんな感じに実行する．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack exec -- advent-calendar fetch 2017 --qiita -o &amp;quot;&amp;quot;./out/qiita.json&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;スクレイピングの結果は GitHub の&lt;a href="https://github.com/matsubara0507/haskell-advent-calendar/tree/f6d6a097c08e741239f576693e3d6b2b7ae21a29/out/2017"&gt;ココ&lt;/a&gt;に置いてある．&lt;/p&gt;
&lt;h3 id="マークダウンに変換"&gt;マークダウンに変換&lt;/h3&gt;
&lt;p&gt;最後にマークダウンへ変換する部分を書く． 次のようなサブコマンドを追加する想定だ．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack exec -- advent-calendar markdown &amp;quot;./out/qiita.json&amp;quot; &amp;quot;./out/adventar.json&amp;quot; -o &amp;quot;./out/posts.md&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そのために次のような型とパーサーを定義した．&lt;/p&gt;
&lt;div class="sourceCode" id="cb28"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb28-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Cmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Fetch&lt;/span&gt; &lt;span class="dt"&gt;FetchOptions&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Markdown&lt;/span&gt; &lt;span class="dt"&gt;MarkdownOptions&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-5" data-line-number="5"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;MarkdownOptions&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-6" data-line-number="6"&gt;   &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;inputs&amp;quot; &amp;gt;: [Text]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-7" data-line-number="7"&gt;    , &lt;span class="st"&gt;&amp;quot;output&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-8" data-line-number="8"&gt;    , &lt;span class="st"&gt;&amp;quot;noCategory&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-9" data-line-number="9"&gt;    ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-11" data-line-number="11"&gt;&lt;span class="ot"&gt;cmdParser ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;Cmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-12" data-line-number="12"&gt;cmdParser &lt;span class="fu"&gt;=&lt;/span&gt; subparser &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-13" data-line-number="13"&gt;     command &lt;span class="st"&gt;&amp;quot;fetch&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-14" data-line-number="14"&gt;       (&lt;span class="dt"&gt;Fetch&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; fetchOptsParser &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;fetch posts on advent calendar to json file.&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-15" data-line-number="15"&gt;  &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; command &lt;span class="st"&gt;&amp;quot;markdown&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-16" data-line-number="16"&gt;       (&lt;span class="dt"&gt;Markdown&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; mdOptsParser &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;convert markdown from posts json file.&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-17" data-line-number="17"&gt;  &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; metavar &lt;span class="st"&gt;&amp;quot;( fetch | markdown )&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-18" data-line-number="18"&gt;  &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; help &lt;span class="st"&gt;&amp;quot;choice subcommand&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-19" data-line-number="19"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-20" data-line-number="20"&gt;&lt;span class="ot"&gt;mdOptsParser ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;MarkdownOptions&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-21" data-line-number="21"&gt;mdOptsParser &lt;span class="fu"&gt;=&lt;/span&gt; hsequence&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-22" data-line-number="22"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;inputs     &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; inputsParser&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-23" data-line-number="23"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;output     &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; outputParser&amp;#39;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-24" data-line-number="24"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;noCategory &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; noCategoryParser&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-25" data-line-number="25"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-26" data-line-number="26"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-27" data-line-number="27"&gt;&lt;span class="ot"&gt;inputsParser ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; [&lt;span class="dt"&gt;Text&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-28" data-line-number="28"&gt;inputsParser &lt;span class="fu"&gt;=&lt;/span&gt; some &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-29" data-line-number="29"&gt;  textArgument (metavar &lt;span class="st"&gt;&amp;quot;inputs&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; help &lt;span class="st"&gt;&amp;quot;Input json file paths&amp;quot;&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;some&lt;/code&gt; を使うことで，ひとつ以上の入力ファイルのパスを与える部分(&lt;code&gt;markdown &amp;quot;./out/qiita.json&amp;quot; &amp;quot;./out/adventar.json&amp;quot;&lt;/code&gt;)のパーサーを簡単に書ける．&lt;/p&gt;
&lt;h2 id="section-8"&gt;&lt;/h2&gt;
&lt;p&gt;マークダウンへの変換部分はこんな感じ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb29"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb29-1" data-line-number="1"&gt;&lt;span class="ot"&gt;toMarkdown ::&lt;/span&gt; &lt;span class="dt"&gt;Post&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="dt"&gt;Text&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-2" data-line-number="2"&gt;toMarkdown post &lt;span class="fu"&gt;=&lt;/span&gt; mconcat &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-3" data-line-number="3"&gt;  [ [ &lt;span class="st"&gt;&amp;quot;**[&amp;quot;&lt;/span&gt;, post &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;title, &lt;span class="st"&gt;&amp;quot;](&amp;quot;&lt;/span&gt;, post &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;url, &lt;span class="st"&gt;&amp;quot;)**  &amp;quot;&lt;/span&gt; ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-4" data-line-number="4"&gt;  , [ &lt;span class="st"&gt;&amp;quot; by &amp;quot;&lt;/span&gt;, post &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;auther&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-5" data-line-number="5"&gt;    , &lt;span class="st"&gt;&amp;quot; on [&amp;quot;&lt;/span&gt;, post &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;calendar &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;title, &lt;span class="st"&gt;&amp;quot;](&amp;quot;&lt;/span&gt;, post &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;calendar &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;url, &lt;span class="st"&gt;&amp;quot;) &amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-6" data-line-number="6"&gt;    , post &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-7" data-line-number="7"&gt;    ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-8" data-line-number="8"&gt;  ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この関数の結果 &lt;code&gt;[Text]&lt;/code&gt; を &lt;code&gt;unlines&lt;/code&gt; してファイルに書き出せばよい． ちなみに，Haskell-jp のブログは，末尾に空白2つで改行となり，空行で HTML にも空行が入るようになっている．&lt;/p&gt;
&lt;h4 id="出力結果"&gt;出力結果&lt;/h4&gt;
&lt;p&gt;は &lt;a href="https://github.com/haskell-jp/blog/blob/02a2b1c68cd75a15d72eedd3148fc803c103a0b7/preprocessed-site/posts/2017/advent-calendar-2017.md#%E3%83%9D%E3%82%A8%E3%83%A0"&gt;Haskell-jp ブログのソースコード&lt;/a&gt;(もちろん前半部分は手書き)を見ればいいと思うよ．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;結局，&lt;strong&gt;全ての記事を集めてくるのに半日近くかかった(笑)&lt;/strong&gt; 来年は投票機能とか，少しずつ集めたりとかできるといいよね．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://haskell.jp/blog/posts/2018/unordered-containers-hash-dos.html</id><title type="text">hashdos脆弱性とunordered-containers</title><updated>2018-01-21T00:00:00Z</updated><author><name>Haskell-jp</name></author><link href="https://haskell.jp/blog/posts/2018/unordered-containers-hash-dos.html"/><summary type="html">&lt;article&gt;
    &lt;div class="container"&gt;
        &lt;div class="row"&gt;
            &lt;div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10"&gt;
                &lt;ul class="social-buttons"&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a href="https://twitter.com/share" class="twitter-share-button"&gt;Tweet&lt;/a&gt;
                        &lt;script&gt;!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;script type="text/javascript"&gt;
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        &lt;/script&gt;
                        &lt;script type="text/javascript" src="//www.redditstatic.com/button/button1.js"&gt;&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"&gt;&lt;/a&gt;
                        &lt;script type="text/javascript"&gt;!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"&gt;
              &lt;hr /&gt;
&lt;p&gt;あらゆるソフトウェアに脆弱性は存在し得ます。&lt;br /&gt;
&lt;span class="ascii"&gt;Haskell&lt;/span&gt;は高度な型システムを駆使することで、脆弱性を根本的に回避したプログラムを作ることを可能にします&lt;small&gt;（脆弱性を防ぐためだけのものではないですが、興味のある人は&lt;a href="http://www.kotha.net/ghcguide_ja/7.6.2/safe-haskell.html"&gt;&lt;span class="ascii"&gt;Safe Haskell&lt;/span&gt;&lt;/a&gt;についても調べてみるといいでしょう）&lt;/small&gt;。&lt;br /&gt;
しかし、だからといって、型を設計する段階で脆弱性を回避できるよう気をつけなければいけないことには変わりませんし、&lt;span class="ascii"&gt;GHC&lt;/span&gt;が生成した実行ファイル、使用するライブラリーに絶対に脆弱性がないとは言えません。&lt;br /&gt;
現状、&lt;span class="ascii"&gt;Haskell&lt;/span&gt;はほかの著名なプログラミング言語ほど使用されていないためか、あまり脆弱性が報告されることはありません&lt;small&gt;（&lt;span class="ascii"&gt;libc&lt;/span&gt;など、ほかの言語の処理系も依存しているようなライブラリーの脆弱性は別として）&lt;/small&gt;。&lt;br /&gt;
今回は、そんな中でも&lt;a href="https://hackage.haskell.org/package/unordered-containers"&gt;&lt;span class="ascii"&gt;unordered-containers&lt;/span&gt;というパッケージ&lt;/a&gt;について、&lt;a href="https://github.com/tibbe/unordered-containers/blob/60ced060304840ed0bf368249ed6eb4e43d4cefc/docs/developer-guide.md#security"&gt;ドキュメントにも書かれている&lt;/a&gt;ため&lt;strong&gt;おそらく直ることがないであろう脆弱性&lt;/strong&gt;と、その回避方法について紹介します。&lt;br /&gt;
&lt;span class="ascii"&gt;hashdos&lt;/span&gt;脆弱性自体は結構有名ですし、ドキュメントに書いてあることなので、ご存知の方には何を今更感があるかと思いますが、検索した限りこの問題について日本語で説明した記事は見当たらなかったので、ここで紹介します。&lt;/p&gt;
&lt;h1 id="そもそもunordered-containersって"&gt;そもそも&lt;span class="ascii"&gt;unordered-containers&lt;/span&gt;って？&lt;/h1&gt;
&lt;p&gt;脆弱性の前に&lt;span class="ascii"&gt;unordered-containers&lt;/span&gt;パッケージについて簡単に紹介しましょう。&lt;br /&gt;
&lt;a href="https://hackage.haskell.org/package/unordered-containers"&gt;&lt;span class="ascii"&gt;unordered-containers&lt;/span&gt;パッケージ&lt;/a&gt;は、&lt;span class="ascii"&gt;GHC&lt;/span&gt;に標準で付いている&lt;a href="https://hackage.haskell.org/package/containers"&gt;&lt;span class="ascii"&gt;containers&lt;/span&gt;パッケージ&lt;/a&gt;よりも高速な連想配列（&lt;a href="https://hackage.haskell.org/package/unordered-containers-0.2.8.0/docs/Data-HashMap-Lazy.html"&gt;&lt;code&gt;HashMap&lt;/code&gt;型&lt;/a&gt;）や集合（&lt;a href="https://hackage.haskell.org/package/unordered-containers-0.2.8.0/docs/Data-HashSet.html"&gt;&lt;code&gt;HashSet&lt;/code&gt;型&lt;/a&gt;）を提供してくれます。&lt;br /&gt;
&lt;a href="https://www.stackage.org/lts-10.3/package/unordered-containers-0.2.8.0"&gt;&lt;span class="ascii"&gt;Stackage&lt;/span&gt;の&lt;span class="ascii"&gt;LTS Haskell 10.3&lt;/span&gt;ではなんと&lt;span class="ascii"&gt;970&lt;/span&gt;ものパッケージに依存されている&lt;/a&gt;、超大人気汎用パッケージです。&lt;/p&gt;
&lt;h2 id="どうやって高速化しているの"&gt;どうやって高速化しているの？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;という名前が示しているとおり、キーとなる値のハッシュ値を計算・利用することで高速化しています。&lt;br /&gt;
しかし、&lt;span class="ascii"&gt;Java&lt;/span&gt;言語などほかの言語によくある&lt;code&gt;HashMap&lt;/code&gt;とは大きく異なり、内部ではハッシュテーブルを使用していません。&lt;br /&gt;
&lt;a href="http://itpro.nikkeibp.co.jp/article/COLUMN/20091104/340002/?rt=nocnt"&gt;本物のプログラマは&lt;span class="ascii"&gt;Haskell&lt;/span&gt;を使う &lt;span class="ascii"&gt;-&lt;/span&gt; 第&lt;span class="ascii"&gt;35&lt;/span&gt;回　キーを使って値を参照する&lt;span class="ascii"&gt;Map&lt;/span&gt;型：&lt;span class="ascii"&gt;ITpro&lt;/span&gt;&lt;/a&gt;でも説明しているとおり、ハッシュテーブルはミュータブルな配列を内部で使用していることから、イミュータブルなデータ構造を使用して行う関数型プログラミングとは、相性が悪いのです&lt;small&gt;（&lt;code&gt;ST&lt;/code&gt;モナドや&lt;code&gt;IO&lt;/code&gt;モナドを利用した&lt;a href="https://hackage.haskell.org/package/hashtables"&gt;&lt;span class="ascii"&gt;hashtables&lt;/span&gt;パッケージ&lt;/a&gt;などを使えば、限られた範囲内でハッシュテーブルを使うこともできます）&lt;/small&gt;。&lt;/p&gt;
&lt;p&gt;ハッシュテーブルを使用しない代わりに、&lt;span class="ascii"&gt;unordered-containers&lt;/span&gt;では内部で&lt;a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie"&gt;&lt;span class="ascii"&gt;Hash array mapped trie&lt;/span&gt;&lt;/a&gt;という特殊な木を使っています。&lt;br /&gt;
どのような構造かは、&lt;a href="http://keens.github.io/slide/HAMT/"&gt;&lt;span class="ascii"&gt;HAMT ~&lt;/span&gt; イミュータブルで高速なハッシュマップ &lt;span class="ascii"&gt;~ |&lt;/span&gt; κ&lt;span class="ascii"&gt;een&lt;/span&gt;の&lt;span class="ascii"&gt;Happy Hac&lt;/span&gt;κ&lt;span class="ascii"&gt;ing Blog&lt;/span&gt;&lt;/a&gt;に詳しく書かれています。&lt;br /&gt;
こちらのスライドは&lt;span class="ascii"&gt;Scala&lt;/span&gt;での実装の話ですが、基本的には&lt;span class="ascii"&gt;unordered-containers&lt;/span&gt;パッケージの&lt;code&gt;HashMap&lt;/code&gt;も同じはずです。&lt;/p&gt;
&lt;p&gt;大雑把に言うと、&lt;span class="ascii"&gt;Hash array mapped trie&lt;/span&gt;を使った&lt;code&gt;HashMap&lt;/code&gt;では、ハッシュテーブルと同様に、キーとなる値を&lt;strong&gt;ハッシュ関数で一旦固定長の整数に変換する&lt;/strong&gt;ことで、キーが存在しているかどうかの確認を高速化しています。そのため、&lt;span class="ascii"&gt;containers&lt;/span&gt;パッケージよりも高速な処理ができるのです。&lt;br /&gt;
&lt;span class="ascii"&gt;containers&lt;/span&gt;パッケージの&lt;code&gt;Map&lt;/code&gt;ではキーの存在を確認する際、キー全体を既存のキーと比較する必要があるため、特に長い文字列をキーとする場合は、処理が遅くなりがちだったのです。&lt;/p&gt;
&lt;h1 id="hashdos脆弱性とは"&gt;&lt;span class="ascii"&gt;hashdos&lt;/span&gt;脆弱性とは？&lt;/h1&gt;
&lt;p&gt;&lt;span class="ascii"&gt;hashdos&lt;/span&gt;脆弱性は&lt;a href="https://blog.tokumaru.org/2011/12/webdoshashdos.html"&gt;&lt;span class="ascii"&gt;2011&lt;/span&gt;年頃&lt;span class="ascii"&gt;Ruby&lt;/span&gt;や&lt;span class="ascii"&gt;PHP&lt;/span&gt;、&lt;span class="ascii"&gt;Perl&lt;/span&gt;など多くのプログラミング言語が影響を受けるとされた&lt;/a&gt;、著名な脆弱性です。&lt;br /&gt;
ここでも簡単に仕組みを説明しましょう。&lt;/p&gt;
&lt;p&gt;前節で説明したとおり、&lt;span class="ascii"&gt;Hash array mapped trie&lt;/span&gt;もハッシュテーブルも、必ずキーを一旦固定長の整数に変換します。&lt;br /&gt;
文字列など、ハッシュ関数を適用されるキーとなる値は、当然固定長の整数よりも幅広い値を取り得るので、違う文字列同士でも、同じハッシュ値をとることがあります。&lt;br /&gt;
この、違う値であるはずのキーが同じハッシュ値をとってしまった状態を「ハッシュ値の衝突」と呼びます。&lt;br /&gt;
ハッシュ値の衝突が発生した場合、ハッシュテーブルや&lt;span class="ascii"&gt;Hash array mapped trie&lt;/span&gt;といったハッシュ値を利用した連想配列は、（単純な）配列やリストなど、やむを得ず逐次探索が必要なデータ構造を内部で使用しなければならなくなります。&lt;/p&gt;
&lt;p&gt;&lt;span class="ascii"&gt;hashdos&lt;/span&gt;脆弱性はこの性質を利用した&lt;span class="ascii"&gt;DoS&lt;/span&gt;攻撃です。&lt;br /&gt;
攻撃者は、あらかじめ対象のプログラムで使っているハッシュ関数が、「必ず同じハッシュ値」を返すキー&lt;span class="ascii"&gt;(&lt;/span&gt;大抵文字列でしょう）を大量に用意して、それを対象のプログラムに入力として与えることで、簡単に&lt;span class="ascii"&gt;DoS&lt;/span&gt;攻撃を仕掛けることができるのです。&lt;br /&gt;
&lt;a href="https://blog.tokumaru.org/2011/12/webdoshashdos.html"&gt;先ほど触れた徳丸先生の記事&lt;/a&gt;では、&lt;span class="ascii"&gt;PHP&lt;/span&gt;のアプリケーションに対してわずか&lt;span class="ascii"&gt;500KB&lt;/span&gt;の&lt;span class="ascii"&gt;form-data&lt;/span&gt;を送るだけで&lt;span class="ascii"&gt;CPU&lt;/span&gt;時間を&lt;span class="ascii"&gt;1&lt;/span&gt;分も消費させることができたそうですから、その威力はすさまじいものと言えるでしょう。&lt;/p&gt;
&lt;h1 id="なぜ直さないのか"&gt;なぜ直さないのか？&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/tibbe/unordered-containers/blob/60ced060304840ed0bf368249ed6eb4e43d4cefc/docs/developer-guide.md#security"&gt;&lt;span class="ascii"&gt;unordered-containers&lt;/span&gt;の&lt;span class="ascii"&gt;Developer Guide&lt;/span&gt;&lt;/a&gt;には、次のように書かれています。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class="ascii"&gt;There&lt;/span&gt;’&lt;span class="ascii"&gt;s an uncomfortable trade-off with regards to security threats posed by e.g. denial of service attacks. Always using more secure hash function, like SipHash, would provide security by default. However, those functions would make the performance of the data structures no better than that of ordered containers, which defeats the purpose of this package.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要するに、「セキュリティー上問題はあるけど、&lt;span class="ascii"&gt;SipHash&lt;/span&gt;のような安全なハッシュ関数を使ったら&lt;span class="ascii"&gt;containers&lt;/span&gt;パッケージよりも速度が出なかった。それではこのパッケージの意味がない」ということです。&lt;br /&gt;
&lt;span class="ascii"&gt;containers&lt;/span&gt;パッケージよりも高速な連想配列を作るために&lt;span class="ascii"&gt;unordered-containers&lt;/span&gt;パッケージを作ったのだから、それより遅くなっては存在価値がなくなってしまうのです。&lt;br /&gt;
従って、ユーザーが任意にキーを入力できるようなプログラムでは、&lt;span class="ascii"&gt;unordered-containers&lt;/span&gt;ではなく、&lt;span class="ascii"&gt;containers&lt;/span&gt;を使え、ということです。&lt;br /&gt;
このことは&lt;span class="ascii"&gt;unordered-containers&lt;/span&gt;が使用している&lt;a href="https://hackage.haskell.org/package/hashable-1.2.6.1/docs/Data-Hashable.html#g:1"&gt;&lt;span class="ascii"&gt;hashable&lt;/span&gt;のドキュメント&lt;/a&gt;にも書かれています。ある意味ノーガード戦法ですね。&lt;/p&gt;
&lt;h1 id="回避方法"&gt;回避方法&lt;/h1&gt;
&lt;p&gt;前節で触れたとおりですが、&lt;strong&gt;ユーザーが任意にキーを入力できるようなプログラム&lt;/strong&gt;では、&lt;span class="ascii"&gt;unordered-containers&lt;/span&gt;パッケージの&lt;code&gt;HashMap&lt;/code&gt;や&lt;code&gt;HashSet&lt;/code&gt;ではなく、&lt;span class="ascii"&gt;containers&lt;/span&gt;パッケージの&lt;code&gt;Map&lt;/code&gt;や&lt;code&gt;Set&lt;/code&gt;を使いましょう。&lt;br /&gt;
&lt;span class="ascii"&gt;containers&lt;/span&gt;パッケージにある&lt;code&gt;Map&lt;/code&gt;や&lt;code&gt;Set&lt;/code&gt;はハッシュ関数を一切使っていないので、ハッシュ値の衝突も起こらず、内部で逐次探索が必要なデータ構造を使ってもいません。&lt;br /&gt;
なので&lt;span class="ascii"&gt;hashdos&lt;/span&gt;攻撃に遭うことはないのです。&lt;/p&gt;
&lt;p&gt;ただし、実際のところ、&lt;a href="https://www.stackage.org/lts-10.3/package/unordered-containers-0.2.8.0"&gt;&lt;span class="ascii"&gt;Stackage&lt;/span&gt;の&lt;span class="ascii"&gt;LTS Haskell 10.3&lt;/span&gt;で&lt;span class="ascii"&gt;970&lt;/span&gt;ものパッケージに依存されている&lt;/a&gt;&lt;span class="ascii"&gt;unordered-containers&lt;/span&gt;です。&lt;br /&gt;
その中には&lt;span class="ascii"&gt;JSON&lt;/span&gt;のパーサーである&lt;span class="ascii"&gt;aeson&lt;/span&gt;も含まれているので、もしかしたら現状回避するのは非常に困難なのかもしれません。😱&lt;br /&gt;
次回は、この問題について試しに攻撃用のコードを書いて速度の低下をチェックして報告する話を書くかもしれません…。😰&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div id="post-navigation" class="row" style="margin-top: 20px;"&gt;
            &lt;div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4"&gt;
                
                &lt;i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"&gt;&lt;/i&gt;
                &lt;a href="/posts/2018/ghc-proposal-and-patch.html"&gt;GHCへの変更提案とパッチ送付の手順例&lt;/a&gt;
                
            &lt;/div&gt;
            &lt;div class="col-lg-2 col-md-2 col-xs-4 text-center"&gt;
                &lt;a href="/"&gt;トップに戻る&lt;/a&gt;
            &lt;/div&gt;
            &lt;div class="col-lg-3 col-md-4 col-xs-4"&gt;
                
                &lt;a href="/posts/2017/advent-calendar-2017.html" style="margin-left: auto;"&gt;Haskell Advent Calendar 2017 まとめ&lt;/a&gt;
                &lt;i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"&gt;&lt;/i&gt;
                
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/article&gt;

</summary></entry><entry><id>http://ilyaletre.hatenablog.com/entry/2018/01/03/185920</id><title type="text">Haskellで抽象構文木 (AST) にメタデータを付与する</title><updated>2018-01-05T17:40:33+09:00</updated><author><name>ilyaletre</name></author><link href="http://ilyaletre.hatenablog.com/entry/2018/01/03/185920"/><summary type="html">2018-01-04 追記: ここで全部語り尽くされている気がしたので、Labelling AST Nodes with locations なにもこんなブログ読むことはないのかもしれない。 megaparsecを使って構文解析器を書いている。 構文解析やっているとASTにソースファイルの位置情報とかをメタデータとして乗せたくなるが、 どんな感じで実装するのか調べた。 僕自身はどのアプローチをとるのか決まっていない。 問題 やりたいこと megaparsec, parsecなどのコンビネータライブラリはジェネレータ系のalex + happyと比べると幾分まともなエラーメッセージを吐くようにな…</summary></entry><entry><id>https://haskell.jp/blog/posts/2017/advent-calendar-2017.html</id><title type="text">Haskell Advent Calendar 2017 まとめ</title><updated>2017-12-31T00:00:00Z</updated><author><name>Haskell-jp</name></author><link href="https://haskell.jp/blog/posts/2017/advent-calendar-2017.html"/><summary type="html">&lt;article&gt;
    &lt;div class="container"&gt;
        &lt;div class="row"&gt;
            &lt;div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10"&gt;
                &lt;ul class="social-buttons"&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a href="https://twitter.com/share" class="twitter-share-button"&gt;Tweet&lt;/a&gt;
                        &lt;script&gt;!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;script type="text/javascript"&gt;
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        &lt;/script&gt;
                        &lt;script type="text/javascript" src="//www.redditstatic.com/button/button1.js"&gt;&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"&gt;&lt;/a&gt;
                        &lt;script type="text/javascript"&gt;!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"&gt;
              &lt;hr /&gt;
&lt;p&gt;これは &lt;a href="https://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar&lt;/span&gt; その&lt;span class="ascii"&gt;4&lt;/span&gt;&lt;/a&gt; の&lt;span class="ascii"&gt;12&lt;/span&gt;日目の記事です。&lt;/p&gt;
&lt;p&gt;なんで&lt;span class="ascii"&gt;12&lt;/span&gt;日目の記事で「まとめ」をやっているのかって？ &lt;span class="ascii"&gt;25&lt;/span&gt;日を過ぎてから余ってた日付に登録しただけですよ。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://qiita.com/advent-calendar/2017/calendars"&gt;&lt;span class="ascii"&gt;Qiita&lt;/span&gt;&lt;/a&gt;と&lt;a href="https://adventar.org/calendars?year=2017"&gt;&lt;span class="ascii"&gt;ADVENTAR&lt;/span&gt;&lt;/a&gt;のアドベントカレンダーで投稿された、&lt;span class="ascii"&gt;Haskell&lt;/span&gt;に関する記事を集めてみました。 いちおう機械的に集めたので、それなりに拾えてると思いますが、もし「この記事が無いよ」とか、逆に「&lt;span class="ascii"&gt;Haskell&lt;/span&gt;ちゃうやんこの記事」ってのがあったら、&lt;a href="https://github.com/haskell-jp/blog/edit/master/preprocessed-site/posts/2017/advent-calendar-2017.md"&gt;ここから編集して&lt;/a&gt;&lt;span class="ascii"&gt;PR&lt;/span&gt;でも送ってください。&lt;/p&gt;
&lt;p&gt;ちなみに「&lt;a href="https://scrapbox.io/miyamoen/Elm_Advent_Calendar_2017_%E3%81%BE%E3%81%A8%E3%82%81"&gt;&lt;span class="ascii"&gt;Elm Advent Calendar 2017&lt;/span&gt; まとめ&lt;/a&gt;」という記事が面白かったので、その&lt;span class="ascii"&gt;Haskell&lt;/span&gt;版オマージュ&lt;span class="ascii"&gt;(&lt;/span&gt;パクリ&lt;span class="ascii"&gt;)&lt;/span&gt;です。&lt;/p&gt;
&lt;h2 id="haskell-advent-calendar"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class="ascii"&gt;Qiita&lt;/span&gt;の方では&lt;span class="ascii"&gt;4&lt;/span&gt;つもできましたね。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まぁしかし、残念ながらどのカレンダーも埋まってないため&lt;a href="https://qiita.com/advent-calendar/2017/ranking/subscriptions"&gt;ランキング&lt;/a&gt;圏外となってしまいましたが&lt;span class="ascii"&gt;(&lt;/span&gt;笑&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;加えて何故か、&lt;span class="ascii"&gt;25&lt;/span&gt;日が過ぎてからその&lt;span class="ascii"&gt;5&lt;/span&gt;のカレンダーができるという、なかなか面白い事案が発生しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/advent-calendar/2017/haskell5"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;5) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記のカレンダーの記事以外も含めて、全部で&lt;span class="ascii"&gt;104&lt;/span&gt;記事もありました。 みんなすごいですね。&lt;/p&gt;
&lt;h2 id="記事を集めた"&gt;記事を集めた&lt;/h2&gt;
&lt;p&gt;超雑にスクレイパーを書いて&lt;span class="ascii"&gt;Qiita&lt;/span&gt;と&lt;span class="ascii"&gt;ADVENTAR&lt;/span&gt;のカレンダーをスクレイピングしてきました。 プログラムは以下のリポジトリにあります&lt;span class="ascii"&gt;(&lt;/span&gt;もちろん&lt;span class="ascii"&gt;Haskell&lt;/span&gt;で作ったよ&lt;span class="ascii"&gt;)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/matsubara0507/haskell-advent-calendar"&gt;&lt;span class="ascii"&gt;matsubara0507/advent-calendar - GitHub&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;カレンダーのタイトルか、記事のタイトルに「&lt;span class="ascii"&gt;Haskell&lt;/span&gt;」って単語が入っているやつだけ集めてます。 このプログラムの解説っぽい記事はそのうち自分のとこの記事として挙げる気がする&lt;span class="ascii"&gt;(&lt;/span&gt;たぶん&lt;span class="ascii"&gt;)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id="記事たち"&gt;記事たち&lt;/h2&gt;
&lt;p&gt;分類は温もりのある手作業でやってます。 自然言語処理系が出来れば機械的に分類できたかもしれませんが…&lt;/p&gt;
&lt;p&gt;分類違くね？というモノがあれば、&lt;a href="https://github.com/haskell-jp/blog/edit/master/preprocessed-site/posts/2017/advent-calendar-2017.md"&gt;ここから編集して&lt;/a&gt;&lt;span class="ascii"&gt;PR&lt;/span&gt;でも送ってください。&lt;/p&gt;
&lt;p&gt;それでは良いお年を。&lt;/p&gt;
&lt;h3 id="ポエム"&gt;ポエム&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://kakkun61.hatenablog.com/entry/2017/12/25/%E3%81%AA%E3%81%9C_Haskell_%E3%81%8C%E5%A5%BD%E3%81%8D%E3%81%AA%E3%81%AE%E3%81%8B"&gt;なぜ &lt;span class="ascii"&gt;Haskell&lt;/span&gt; が好きなのか &lt;span class="ascii"&gt;-&lt;/span&gt; 趣味はデバッグ……&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by kakkun61 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/06&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/Mizunashi_Mana/items/e82214dfae2765c6839a"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;副作用ポエム &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by Mizunashi_Mana on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/21&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/ababup1192/items/b15cdace30b7fef3338c"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;を勉強して感動したこと・難しいと思ってること &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by ababup1192 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/04&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="入門してみた"&gt;入門してみた&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://gist.github.com/sys9kdr/2484ed09f5cb7ea86beae8f5222d9a3c"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;入門しようとして環境構築で失敗。 &lt;span class="ascii"&gt;· GitHub&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by sys9kdr on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/05&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/lagenorhynque/items/f8b14ff70a26cfd27976"&gt;&lt;span class="ascii"&gt;Clojurian&lt;/span&gt;が&lt;span class="ascii"&gt;Haskell&lt;/span&gt;で&lt;span class="ascii"&gt;Web API&lt;/span&gt;開発に入門してみた &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by lagenorhynque on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/19&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/hitsujisanmeme/items/e14972cfd349c1149d58"&gt;美術の人が考える &lt;span class="ascii"&gt;Haskell - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by hitsujisanmeme on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/14&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/brackss1/items/9f9466f160391dc53bba"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;入門者がライブラリを触っちゃう&lt;span class="ascii"&gt;!? - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by brackss1 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/22&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/ryosukue/items/cf14d817a7067dfd2094"&gt;&lt;span class="ascii"&gt;Ubuntu&lt;/span&gt;、&lt;span class="ascii"&gt;Haskell&lt;/span&gt;で&lt;span class="ascii"&gt;web&lt;/span&gt;アプリ手始め &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by ryosukue on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/nuco"&gt;&lt;span class="ascii"&gt;Nuco Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/23&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/3nan/items/b89b7383ddb2bac5dda1"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;をちょこっと紹介（フィボナッチ数列を書いてみる） &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by 3nan on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/tecotec"&gt;&lt;span class="ascii"&gt;TECOTEC Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/23&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="ノウハウ"&gt;ノウハウ&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.ncaq.net/2017/12/02/00/00/00/"&gt;私の&lt;span class="ascii"&gt;Haskell&lt;/span&gt;コーディングスタイルガイド&lt;span class="ascii"&gt;,&lt;/span&gt;改行出来るポイントを紹介 &lt;span class="ascii"&gt;- ncaq&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by ncaq on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/02&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.ncaq.net/2017/12/03/00/00/00/"&gt;ゲーム販売&lt;span class="ascii"&gt;web&lt;/span&gt;アプリケーション&lt;span class="ascii"&gt;SYAKERAKE&lt;/span&gt;を支える技術&lt;span class="ascii"&gt;,Haskell&lt;/span&gt;と&lt;span class="ascii"&gt;Yesod&lt;/span&gt;で作られています &lt;span class="ascii"&gt;- ncaq&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by ncaq on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/03&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.ncaq.net/2017/12/04/00/00/00/"&gt;&lt;span class="ascii"&gt;Stackage Server&lt;/span&gt;のちょっとした便利な使い方&lt;span class="ascii"&gt;,Hoogle&lt;/span&gt;をブラウザのカスタム検索エンジンに追加しましょう&lt;span class="ascii"&gt;,&lt;/span&gt;よく使うパッケージをブックマークする時は&lt;span class="ascii"&gt;PackageR&lt;/span&gt;の&lt;span class="ascii"&gt;URL&lt;/span&gt;にしましょう &lt;span class="ascii"&gt;- ncaq&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by ncaq on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/04&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://d.hatena.ne.jp/kazu-yamamoto/20171212/1513050147"&gt;&lt;span class="ascii"&gt;go&lt;/span&gt;な関数&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by kazu_yamamoto on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://fumieval.hatenablog.com/entry/2017/12/19/203500"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;の&lt;span class="ascii"&gt;ABC(Haskell Advent Calendar 6th) -&lt;/span&gt; モナドとわたしとコモナド&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by fumieval on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/06&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://haskell.jp/blog/posts/2017/windows-gotchas.html"&gt;&lt;span class="ascii"&gt;Windows&lt;/span&gt;で&lt;span class="ascii"&gt;Haskell&lt;/span&gt;を扱う時によく遭遇するエラーと対処法 &lt;span class="ascii"&gt;- Haskell-jp&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by igrep on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/14&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="解説"&gt;解説&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://syocy.hatenablog.com/entry/a-tour-of-go-in-haskell"&gt;&lt;span class="ascii"&gt;A Tour of Go in Haskell&lt;/span&gt;を作ったのと、&lt;span class="ascii"&gt;Go&lt;/span&gt;と&lt;span class="ascii"&gt;Haskell&lt;/span&gt;の比較 &lt;span class="ascii"&gt;- syocy&lt;/span&gt;’&lt;span class="ascii"&gt;s diary&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by syocy on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/03&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/cyclone_t/items/8443ed5d4a77f87b1f1b"&gt;&lt;span class="ascii"&gt;Servant&lt;/span&gt;のハンドラに&lt;span class="ascii"&gt;ReaderT&lt;/span&gt;を適用する &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by cyclone_t on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/15&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/wgag/items/11a6e667011d530832e8"&gt;スーパーモナドについて &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by wgag on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://tech.recruit-mp.co.jp/dev-tools/post-13981/"&gt;&lt;span class="ascii"&gt;CircleCI2.0&lt;/span&gt;で&lt;span class="ascii"&gt;Haskell&lt;/span&gt;のテストを実行する – &lt;span class="ascii"&gt;PSYENCE:MEDIA&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by yukiasai on&lt;/span&gt; &lt;a href="http://adventar.org/calendars/2360"&gt;&lt;span class="ascii"&gt;RECRUIT MARKETING PARTNERS Advent Calendar 2017 - Adventar&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/13&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/yukiasai/items/248294a871d40c0dcef6"&gt;&lt;span class="ascii"&gt;Dokku&lt;/span&gt;環境を構築して&lt;span class="ascii"&gt;Haskell&lt;/span&gt;のアプリケーションをデプロイする &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by yukiasai on&lt;/span&gt; &lt;a href="http://adventar.org/calendars/2324"&gt;&lt;span class="ascii"&gt;Recruit Engineers Advent Calendar 2017 - Adventar&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/07&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="周辺ツールについて"&gt;周辺ツールについて&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/usamik26/items/672ed3c4451402bfc275"&gt;&lt;span class="ascii"&gt;Haskell Stack&lt;/span&gt; とは何をするツールなのか &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by usamik26 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://haskell.e-bigmoon.com/posts/2017-12-20-stack-ls-command.html"&gt;&lt;span class="ascii"&gt;stack ls&lt;/span&gt; コマンドが追加されます&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by waddlaw on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/08&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://haskell.e-bigmoon.com/posts/2017-12-24-stack163.html"&gt;&lt;span class="ascii"&gt;stack v1.6.3&lt;/span&gt; がリリースされました。&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by waddlaw on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/09&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/ogata-k/items/23d70250ec42359b6bb5"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;や周辺ツールについてのリンク集 &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by ogata-k on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/15&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/ogata-k/items/2b21326b2b7351bfc28c"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;の&lt;span class="ascii"&gt;stack&lt;/span&gt;によるプロジェクトについて &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by ogata-k on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/16&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://haskell.e-bigmoon.com/posts/2017-12-27-haddock-grid-table.html"&gt;&lt;span class="ascii"&gt;haddock&lt;/span&gt; に &lt;span class="ascii"&gt;Grid Table&lt;/span&gt; 記法が追加されました&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by waddlaw on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell5"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;5) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/02&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://haskell.e-bigmoon.com/posts/2017-12-23-stack161.html"&gt;カスタムスナップショットの紹介&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by waddlaw on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/14&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://myuon.github.io/posts/haskell-project-setup/"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;プロジェクトを始めるにあたって &lt;span class="ascii"&gt;- The curse of&lt;/span&gt; λ&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by myuon_myon on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/myuon_myon_cs"&gt;一人&lt;span class="ascii"&gt;Computer Science Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/15&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="ライブラリ紹介"&gt;ライブラリ紹介&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/jabaraster/items/e8ebbe6d25b535947aba"&gt;&lt;span class="ascii"&gt;servant+persistent&lt;/span&gt;を利用する &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by jabaraster on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/07&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/makoraru/items/596729de09d6aeb81e5a"&gt;&lt;span class="ascii"&gt;Yampa&lt;/span&gt;で&lt;span class="ascii"&gt;Functional Reactive&lt;/span&gt;な認知行動療法ボット &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by makoraru on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/13&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://nnwww.github.io/blog/post/haskell_ml/"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;で機械学習を実装しようと思った過去の自分へ&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by _Nnwww on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/23&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/cyclone_t/items/52ad44cfbb4603e123f3"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;・&lt;span class="ascii"&gt;Servant+Persistent/Esqueleto&lt;/span&gt;で作る実用&lt;span class="ascii"&gt;WebAPI (1) Servant&lt;/span&gt;の基本 &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by cyclone_t on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/11&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://matsubara0507.github.io/posts/2017-12-09-extensible-effects-step-by-step.html"&gt;&lt;span class="ascii"&gt;Extensible Effects&lt;/span&gt; ステップ・バイ・ステップ&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by matsubara0507 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/09&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/Mizunashi_Mana/items/115855bf2af9b9970198"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;のパーサライブラリまとめ &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by Mizunashi_Mana on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/11&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.zaneli.com/blog/20171213"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;入門者&lt;span class="ascii"&gt;LT&lt;/span&gt;会で自作ライブラリ&lt;span class="ascii"&gt;network-voicetext&lt;/span&gt;の話をしてきた &lt;span class="ascii"&gt;|&lt;/span&gt; ザネリは列車を見送った&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by zaneli@github on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/13&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/satosystems/items/32bf104a041c8cc13809"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt; と &lt;span class="ascii"&gt;SQLite - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by satosystems on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/16&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/masahiro_sakai/items/6a989d5b898a08f17821"&gt;部分構造の共有を観測する&lt;span class="ascii"&gt;data-reify - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by masahiro_sakai on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/21&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="作ってみた"&gt;作ってみた&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://matsubara0507.github.io/posts/2017-12-13-elm-and-haskell-for-elmer.html"&gt;&lt;span class="ascii"&gt;Elm&lt;/span&gt; と &lt;span class="ascii"&gt;Haskell&lt;/span&gt; で作る &lt;span class="ascii"&gt;ToDo&lt;/span&gt; アプリ&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by matsubara0507 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/elm"&gt;&lt;span class="ascii"&gt;Elm Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/13&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://abc10946.hatenablog.com/entry/2017/12/18/014203"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;に入門して&lt;span class="ascii"&gt;1&lt;/span&gt;年位経ったのでライフゲームを作ってみた話 &lt;span class="ascii"&gt;- abc10946&lt;/span&gt;の日記&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by ABC10946 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/18&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://d.hatena.ne.jp/wvogel00/20171222/1513924995"&gt;仕事で&lt;span class="ascii"&gt;Haskell&lt;/span&gt;を使いたいなら外堀から&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by hxf_vogel on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/22&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://blog.nakaji.me/slack-api-bloodhound-servant/"&gt;&lt;span class="ascii"&gt;slack-api + bloodhound + servant&lt;/span&gt; で&lt;span class="ascii"&gt;bot+&lt;/span&gt;αを作る&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by nakaji-dayo on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/07&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://secret-garden.hatenablog.com/entry/2017/12/16/000000"&gt;【&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017&lt;/span&gt;】&lt;span class="ascii"&gt;Vim&lt;/span&gt; から &lt;span class="ascii"&gt;Hoogle&lt;/span&gt; の検索が出来るプラグインをつくった【&lt;span class="ascii"&gt;16&lt;/span&gt;日目】 &lt;span class="ascii"&gt;- Secret Garden(Instrumental)&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by pink_bangbi on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/16&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/rounddelta/items/807866bdaa81c3057ac0"&gt;お天気&lt;span class="ascii"&gt;Bot&lt;/span&gt; で理解する &lt;span class="ascii"&gt;Haskell&lt;/span&gt; の便利パッケージ &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by rounddelta on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/25&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/arowM/items/e59442120ad3c1071c57"&gt;&lt;span class="ascii"&gt;Haskell ochintin-daicho&lt;/span&gt; で年末調整プログラミング &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by arowM on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/lotz/items/1aa6cf18aa193f40c647"&gt;作って学ぶ&lt;span class="ascii"&gt;Bitcoin&lt;/span&gt;！ゼロから作る&lt;span class="ascii"&gt;SPV&lt;/span&gt;ウォレット &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by lotz on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/18&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://tune.hateblo.jp/entry/2017/12/27/031803"&gt;優秀な秘書を雇いました&lt;span class="ascii"&gt;!!! - Creatable a =&amp;gt; a -&amp;gt; IO b&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by tokiwoousaka@github on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/satosystems/items/c1c0feef87345a9df69d"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt; における遅延ファイル読み込みとリソースリーク &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by satosystems on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/23&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://haskell.jp/blog/posts/2017/typesafe-precure2.html"&gt;タイプセーフプリキュア！を支える技術 その&lt;span class="ascii"&gt;2 - Haskell-jp&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by igrep on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/24&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.ncaq.net/2017/12/19/00/00/00/"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;による&lt;span class="ascii"&gt;web&lt;/span&gt;スクレイピングの方法を&lt;span class="ascii"&gt;dic-nico-intersection-pixiv&lt;/span&gt;を例に書く &lt;span class="ascii"&gt;- ncaq&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by&lt;/span&gt; エヌユル &lt;span class="ascii"&gt;on&lt;/span&gt; &lt;a href="http://adventar.org/calendars/2105"&gt;&lt;span class="ascii"&gt;Web&lt;/span&gt;スクレイピング &lt;span class="ascii"&gt;Advent Calendar 2017 - Adventar&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/19&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://matsubara0507.github.io/posts/2017-12-02-re-adventar-slack-bot-part1.html"&gt;&lt;span class="ascii"&gt;Re:&lt;/span&gt; ゼロから作る &lt;span class="ascii"&gt;ADVENTAR&lt;/span&gt; の &lt;span class="ascii"&gt;Slack Bot (Haskell&lt;/span&gt; 編&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by&lt;/span&gt; ひげ &lt;span class="ascii"&gt;on&lt;/span&gt; &lt;a href="http://adventar.org/calendars/2300"&gt;群馬大学電子計算機研究会 &lt;span class="ascii"&gt;IGGG Advent Calendar 2017 - Adventar&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/02&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="処理系"&gt;処理系&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://ilyaletre.hatenablog.com/entry/2017/12/10/195016"&gt;&lt;span class="ascii"&gt;GHC&lt;/span&gt;の中間言語&lt;span class="ascii"&gt;Core&lt;/span&gt;への脱糖を覗き見る &lt;span class="ascii"&gt;- Hash&lt;/span&gt; λ &lt;span class="ascii"&gt;Bye&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by ilyaletre on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/11&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://fujiy.hatenablog.com/entry/type-inference-1"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;の型システムを書く&lt;span class="ascii"&gt;(1) -&lt;/span&gt; 純粋技術メモ&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by fujiy on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/03&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/takoeight0821/items/9a1c3eb5b0f292026596"&gt;&lt;span class="ascii"&gt;GHC&lt;/span&gt;での中置演算子のパース &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by takoeight0821 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/06&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://uhideyuki.sakura.ne.jp/studs/index.cgi/ja/HindleyMilnerInHaskell"&gt;型システムを学ぼう！&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by unnohideyuki on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/15&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="言語機能"&gt;言語機能&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://matsubara0507.github.io/posts/2017-12-12-backpack-memo.html"&gt;&lt;span class="ascii"&gt;Haskell Backpack&lt;/span&gt; 覚え書き&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by matsubara0507 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/aiya000/items/b802531c58c161cd245f"&gt;にこ、希と一緒に学ぶ&lt;span class="ascii"&gt;Haskell&lt;/span&gt;（番外）「あまり知られていない&lt;span class="ascii"&gt;GHC&lt;/span&gt;拡張の紹介」 &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by aiya000 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/21&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/ruicc/items/e2879c44eba77b1e7170"&gt;&lt;span class="ascii"&gt;Levity polymorphism&lt;/span&gt;について軽く &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by ruicc on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/02&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/ryoppy/items/7156d587da2e6ae7e605"&gt;&lt;span class="ascii"&gt;Kind&lt;/span&gt;について &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by ryoppy on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/11&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://khibino.hatenadiary.jp/entry/2017/12/18/081814"&gt;&lt;span class="ascii"&gt;OverloadedLabels&lt;/span&gt; と &lt;span class="ascii"&gt;Haskell Relational Record - khibino blog&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by khibino on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/18&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/thimura/items/0d289c231f9aceac61dc"&gt;&lt;span class="ascii"&gt;GHC 8.2&lt;/span&gt; 以前で &lt;span class="ascii"&gt;FFI&lt;/span&gt; を使う際に注意すること &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by thimura on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/19&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="型"&gt;型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/junjihashimoto@github/items/31f245f5e0138e5fac7e"&gt;依存型の紹介と応用としての&lt;span class="ascii"&gt;Clash&lt;/span&gt;の紹介 &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by junjihashimoto@github on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/19&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/aiya000/items/81e8424c8a3ee23586a6"&gt;ことり、穂乃果と一緒に学ぶ&lt;span class="ascii"&gt;Haskell&lt;/span&gt;（入門）その&lt;span class="ascii"&gt;6&lt;/span&gt;「高階データ型」 &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by aiya000 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/24&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/mod_poppo/items/50ad2c0ee66171cc1ee9"&gt;型を実行時に作る：怖くないリフレクション &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by mod_poppo on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/19&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/HirotoShioi/items/5474119ba3682448c109"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;における型クラス制約の役割 &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by HirotoShioi on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell5"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;5) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/04&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="base"&gt;&lt;span class="ascii"&gt;Base&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.ncaq.net/2017/12/01/00/00/01/"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;の&lt;span class="ascii"&gt;State&lt;/span&gt;の必要性が&lt;span class="ascii"&gt;,&lt;/span&gt;プログラミング言語の処理系を書いた時にわかったので&lt;span class="ascii"&gt;,State&lt;/span&gt;の良さを語ります &lt;span class="ascii"&gt;- ncaq&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by ncaq on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/grainrigi/items/f45b586b4013ffc3814e"&gt;&lt;span class="ascii"&gt;Haskell - $&lt;/span&gt;の仕組みを覗いてみよう &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by grainrigi on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/08&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://blog.b123400.net/functor/"&gt;&lt;span class="ascii"&gt;Mapping things&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by b123400 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/elipmoc101/items/4590210c9946ee2fd4c5"&gt;&lt;span class="ascii"&gt;Maybe&lt;/span&gt;自作から学ぶ&lt;span class="ascii"&gt;Haskell&lt;/span&gt;！ &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by elipmoc101 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/16&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://keiorogiken.wordpress.com/2017/12/24/list%E3%81%A7%E9%81%8A%E3%81%B6/"&gt;&lt;span class="ascii"&gt;List&lt;/span&gt;で遊ぶ &lt;span class="ascii"&gt;|&lt;/span&gt; 慶應義塾大学ロボット技術研究会&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by mt_caret on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/Lugendre/items/6b4a8c8a9c85fcdcb292"&gt;&lt;span class="ascii"&gt;Arrow&lt;/span&gt;を理解する &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by Lugendre on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/08&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="アルゴリズムとデータ構造"&gt;アルゴリズムとデータ構造&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/ryohji/items/d8bdba1648978c308cdd"&gt;探索問題を &lt;span class="ascii"&gt;Haskell&lt;/span&gt; で解く &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by ryohji on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/09&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/v97ug/items/d6dd50a2b6b84a9e4d41"&gt;巡回セールスマン問題を遺伝的アルゴリズムとデータ構造を使って&lt;span class="ascii"&gt;Haskell&lt;/span&gt;で解く！ &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by v97ug on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/15&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/as_capabl/items/39e55e7a035dea4dc93a"&gt;いつから&lt;span class="ascii"&gt;Haskell&lt;/span&gt;の&lt;span class="ascii"&gt;5&lt;/span&gt;行クイックソートが遅いと錯覚していた？ &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by as_capabl on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/rst76/items/a7dd81b522a09d1b9986"&gt;キューの効率的な実装 または私は如何にして&lt;span class="ascii"&gt;Haskell&lt;/span&gt;を止めて&lt;span class="ascii"&gt;F#&lt;/span&gt;を愛するようになったか &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by rst76 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/21&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://autotaker.hatenablog.com/entry/2017/12/21/125153"&gt;永続リアルタイムキューの&lt;span class="ascii"&gt;Haskell&lt;/span&gt;実装と計算量解析 &lt;span class="ascii"&gt;- autotaker&lt;/span&gt;’&lt;span class="ascii"&gt;s blog&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by autotaker1984 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/22&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/Aruneko/items/dee20161358e7c39e27a"&gt;&lt;span class="ascii"&gt;Zipper&lt;/span&gt;に挑む &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by Aruneko on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/02&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/nobsun/items/27fe53516cbb90ba02e2"&gt;&lt;span class="ascii"&gt;Tree:&lt;/span&gt; 親子関係の付け替え &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by nobsun on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/07&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://zodi-g12.hatenablog.com/entry/2017/12/06/133951"&gt;コラッツの問題を&lt;span class="ascii"&gt;Haskell&lt;/span&gt;で書いてみた &lt;span class="ascii"&gt;- Zodiac&lt;/span&gt;の黙示録&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by zodi_G12 on&lt;/span&gt; &lt;a href="http://adventar.org/calendars/2377"&gt;&lt;span class="ascii"&gt;IQ&lt;/span&gt;が&lt;span class="ascii"&gt;1 Advent Calendar 2017 - Adventar&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/06&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="数学科学"&gt;数学・科学&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/tezca686/items/855236ccdda584ee8ebb"&gt;&lt;span class="ascii"&gt;[Haskell]&lt;/span&gt; とびだせ！&lt;span class="ascii"&gt;Hask&lt;/span&gt;圏 &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by tezca686 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/14&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/makoraru/items/768089b2aab1dde47593"&gt;区間代数と無限小と無限大 &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by makoraru on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell3"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;3) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/17&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/as_capabl/items/2031fe28e577e77dc269"&gt;しりとりの圏の回答、または定理証明&lt;span class="ascii"&gt;Haskell&lt;/span&gt;を少しだけ &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by as_capabl on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/04&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/hiratara/items/6265b5d4791144bee33b"&gt;しりとりの圏の実装&lt;span class="ascii"&gt;(&lt;/span&gt;未完&lt;span class="ascii"&gt;) - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by hiratara on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/05&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/kyamaz/items/67ec5c7d39e62c1de91d"&gt;量子コンピューターにはモナドがよく似合う &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by kyamaz on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/17&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/makoraru/items/ab891a60d4dfe4bbf649"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;と層 &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by makoraru on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/NaOHaq/items/ba490cc1e1ab890cb399"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;上で有限体を使って遊ぶ &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by NaOHaq on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/22&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/cutsea110/items/69889a99d30b627bc04a"&gt;&lt;span class="ascii"&gt;somehow-morphisms on fixed point written in Haskell - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by cutsea110 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/kyamaz/items/e49b07e05e871a22246c"&gt;量子プログラミングは&lt;span class="ascii"&gt;Haskell&lt;/span&gt;で &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by kyamaz on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/quantum"&gt;量子コンピュータ &lt;span class="ascii"&gt;Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/17&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="docker"&gt;&lt;span class="ascii"&gt;Docker&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/t10471/items/4afa598e1be5d6c7cc1f"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;でも&lt;span class="ascii"&gt;Go&lt;/span&gt;みたいにシングルバイナリでアプリケーションをデプロイしたい &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by t10471 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell2"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;2) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/09&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/algas/items/fde155abbc9d8ae3f8c9"&gt;&lt;span class="ascii"&gt;Haskell on Docker&lt;/span&gt; で &lt;span class="ascii"&gt;Portable CLI&lt;/span&gt; を作ろう &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by algas on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/05&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="eta"&gt;&lt;span class="ascii"&gt;Eta&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/aiya000/items/881d5f7e04b1178e7764"&gt;&lt;span class="ascii"&gt;Eta&lt;/span&gt;で表現されるデータ型としての&lt;span class="ascii"&gt;Java&lt;/span&gt;クラスとその継承関係 &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by aiya000 on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/25&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/aiya000/items/7dc0cb8694de0675088e"&gt;&lt;span class="ascii"&gt;Haskell (Eta)&lt;/span&gt; で&lt;span class="ascii"&gt;JavaFX&lt;/span&gt;の&lt;span class="ascii"&gt;EDSL&lt;/span&gt;を作る雰囲気を醸し出す &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by aiya000 on&lt;/span&gt; &lt;a href="http://adventar.org/calendars/2546"&gt;プロ生ちゃん &lt;span class="ascii"&gt;Advent Calendar 2017 - Adventar&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/25&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="書籍紹介"&gt;書籍紹介&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/waddlaw/items/dd926462d398c4cbd019"&gt;これから &lt;span class="ascii"&gt;Haskell&lt;/span&gt; を学ぶ人のための書籍紹介 &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by waddlaw on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/Aruneko/items/e72f7c6ee49159751cba"&gt;&lt;span class="ascii"&gt;2017&lt;/span&gt;年に「すごい&lt;span class="ascii"&gt;Haskell&lt;/span&gt;たのしく学ぼう」を読む &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by Aruneko on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/13&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/YoshikuniJujo/items/0708f108bf53a216a61a"&gt;拙書「&lt;span class="ascii"&gt;Haskell&lt;/span&gt; 教養としての関数型プログラミング」の紹介 &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by YoshikuniJujo on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/24&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://mt-caret.github.io/blog/posts/2017-12-01-book01.html"&gt;&lt;span class="ascii"&gt;mt_caret.log -&lt;/span&gt; 本&lt;span class="ascii"&gt;1&lt;/span&gt; “&lt;span class="ascii"&gt;Haskell Programming from first principles&lt;/span&gt;”&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by mt_caret on&lt;/span&gt; &lt;a href="http://adventar.org/calendars/2433"&gt;本 &lt;span class="ascii"&gt;Advent Calendar 2017 - Adventar&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/01&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="翻訳記事"&gt;翻訳記事&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/Pythonissam/items/ace180b1b78876f1c190"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt; で暗号学的ハッシュを扱う &lt;span class="ascii"&gt;(&lt;/span&gt;和訳&lt;span class="ascii"&gt;) - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by rounddelta on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/02&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/rounddelta/items/d767f36d544427a9c60d"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt; のアプリケーション向けに軽量の &lt;span class="ascii"&gt;Docker&lt;/span&gt;イメージ を作る &lt;span class="ascii"&gt;(&lt;/span&gt;和訳&lt;span class="ascii"&gt;) - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by rounddelta on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/03&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/rounddelta/items/8b7d2a200a932e761fa3"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt; 初心者へのアドバイス &lt;span class="ascii"&gt;(&lt;/span&gt;和訳&lt;span class="ascii"&gt;) - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by rounddelta on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/04&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/rounddelta/items/31b835b493abf5be3549"&gt;将来も使えるテストスイート &lt;span class="ascii"&gt;(&lt;/span&gt;和訳&lt;span class="ascii"&gt;) - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by rounddelta on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/05&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/rounddelta/items/27c12237d9ef1c5569ba"&gt;&lt;span class="ascii"&gt;VS Code&lt;/span&gt; で &lt;span class="ascii"&gt;Ghcid&lt;/span&gt; を使う &lt;span class="ascii"&gt;(&lt;/span&gt;和訳&lt;span class="ascii"&gt;) - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by rounddelta on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/06&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/rounddelta/items/4584f5486c1061c93f0b"&gt;&lt;span class="ascii"&gt;HLint&lt;/span&gt; のルールを理解する &lt;span class="ascii"&gt;(&lt;/span&gt;和訳&lt;span class="ascii"&gt;) - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by rounddelta on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/07&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/Pythonissam/items/41f8121795f5d8954802"&gt;&lt;span class="ascii"&gt;SPJ&lt;/span&gt; の憂鬱 &lt;span class="ascii"&gt;(&lt;/span&gt;和訳&lt;span class="ascii"&gt;) - Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by rounddelta on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/17&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://qiita.com/reotasosan/items/d9fdfab10e24eabfefda"&gt;&lt;span class="ascii"&gt;SPJ&lt;/span&gt;と&lt;span class="ascii"&gt;Haskell&lt;/span&gt;のエコシステム（和訳） &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by reotasosan on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/18&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://haskell.e-bigmoon.com/posts/2017-12-27-haskell-performance-debugging"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt; のパフォーマンスをデバッグする&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;span class="ascii"&gt;by waddlaw on&lt;/span&gt; &lt;a href="http://qiita.com/advent-calendar/2017/haskell5"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;5) Advent Calendar 2017 - Qiita&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;12/01&lt;/span&gt;&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div id="post-navigation" class="row" style="margin-top: 20px;"&gt;
            &lt;div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4"&gt;
                
                &lt;i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"&gt;&lt;/i&gt;
                &lt;a href="/posts/2018/unordered-containers-hash-dos.html"&gt;hashdos脆弱性とunordered-containers&lt;/a&gt;
                
            &lt;/div&gt;
            &lt;div class="col-lg-2 col-md-2 col-xs-4 text-center"&gt;
                &lt;a href="/"&gt;トップに戻る&lt;/a&gt;
            &lt;/div&gt;
            &lt;div class="col-lg-3 col-md-4 col-xs-4"&gt;
                
                &lt;a href="/posts/2017/windows-gotchas.html" style="margin-left: auto;"&gt;WindowsでHaskellを扱う時によく遭遇するエラーと対処法&lt;/a&gt;
                &lt;i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"&gt;&lt;/i&gt;
                
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/article&gt;

</summary></entry><entry><id>https://haskell.jp/blog/posts/2017/windows-gotchas.html</id><title type="text">WindowsでHaskellを扱う時によく遭遇するエラーと対処法</title><updated>2017-12-25T00:00:00Z</updated><author><name>Haskell-jp</name></author><link href="https://haskell.jp/blog/posts/2017/windows-gotchas.html"/><summary type="html">&lt;article&gt;
    &lt;div class="container"&gt;
        &lt;div class="row"&gt;
            &lt;div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10"&gt;
                &lt;ul class="social-buttons"&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a href="https://twitter.com/share" class="twitter-share-button"&gt;Tweet&lt;/a&gt;
                        &lt;script&gt;!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;script type="text/javascript"&gt;
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        &lt;/script&gt;
                        &lt;script type="text/javascript" src="//www.redditstatic.com/button/button1.js"&gt;&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"&gt;&lt;/a&gt;
                        &lt;script type="text/javascript"&gt;!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"&gt;
              &lt;hr /&gt;
&lt;p&gt;この記事は、&lt;a href="https://qiita.com/advent-calendar/2017/haskell4"&gt;&lt;span class="ascii"&gt;Haskell (&lt;/span&gt;その&lt;span class="ascii"&gt;4) Advent Calendar 2017&lt;/span&gt;&lt;/a&gt;&lt;span class="ascii"&gt;14&lt;/span&gt;日目の記事です。&lt;br /&gt;
枠が空いていたので埋めるために登録しました。&lt;br /&gt;
長くかかった割には実験自体は失敗気味な、&lt;a href="https://haskell.jp/blog/posts/2017/typesafe-precure2.html"&gt;昨日のこちらの記事&lt;/a&gt;よりは有用な情報じゃないかと思います。&lt;br /&gt;
ほかの言語でもありそうな話ですしね。&lt;/p&gt;
&lt;p&gt;すごく簡潔にまとめるとこの間の下記のツイートに収まるのですが、もう少し丁寧に補足するために書きます。&lt;/p&gt;
&lt;blockquote class="twitter-tweet" data-lang="ja"&gt;
&lt;p lang="ja" dir="ltr"&gt;
学んだことをまとめると&lt;br&gt;&lt;span class="ascii"&gt;- Invalid character&lt;/span&gt;と言われたら&lt;span class="ascii"&gt;chcp 65001&lt;/span&gt;しよう&lt;br&gt;&lt;span class="ascii"&gt;- Permission Denied&lt;/span&gt;と言われたらビルドし直そう&lt;br&gt;&lt;span class="ascii"&gt;-&lt;/span&gt; 日本語のパスが混ざらないよう気をつけよう&lt;br&gt;&lt;span class="ascii"&gt;- C&lt;/span&gt;のライブラリーはものによる&lt;br&gt;ですか。多分 &lt;a href="https://twitter.com/hashtag/haskell?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;&lt;span class="ascii"&gt;#haskell&lt;/span&gt;&lt;/a&gt; 以外でも有益な話。
&lt;/p&gt;
— &lt;span class="ascii"&gt;Yuji Yamamoto:&lt;/span&gt; 山本悠滋 &lt;span class="ascii"&gt;(&lt;/span&gt;&lt;span class="citation" data-cites="igrep"&gt;&lt;span class="ascii"&gt;@igrep&lt;/span&gt;&lt;/span&gt;&lt;span class="ascii"&gt;)&lt;/span&gt; &lt;a href="https://twitter.com/igrep/status/938056578934042626?ref_src=twsrc%5Etfw"&gt;&lt;span class="ascii"&gt;2017&lt;/span&gt;年&lt;span class="ascii"&gt;12&lt;/span&gt;月&lt;span class="ascii"&gt;5&lt;/span&gt;日&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h1 id="invalid-characterと言われたらchcp-65001しよう"&gt;&lt;span class="ascii"&gt;Invalid character&lt;/span&gt;と言われたら&lt;span class="ascii"&gt;chcp 65001&lt;/span&gt;しよう&lt;/h1&gt;
&lt;p&gt;恐らく一番高確率で遭遇する &lt;span class="ascii"&gt;&amp;amp;&lt;/span&gt; 知らないと回避できないのがこれ。&lt;br /&gt;
あ、ほらまた&lt;span class="ascii"&gt;hakyll&lt;/span&gt;でビルドしたら起きた！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; stack exec -- site rebuild
...
  [ERROR] preprocessed-site\posts/2017/01-first.md: hGetContents: invalid argument (invalid byte sequence)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class="ascii"&gt;GHC&lt;/span&gt;がファイルを読み書きする時に使う&lt;a href="https://www.stackage.org/haddock/lts-10.0/base-4.10.1.0/System-IO.html#t:Handle"&gt;&lt;code&gt;Handle&lt;/code&gt;&lt;/a&gt;というオブジェクトには、文字コードの情報が含まれています。&lt;/p&gt;
&lt;p&gt;これは&lt;span class="ascii"&gt;Ruby&lt;/span&gt;の&lt;a href="https://docs.ruby-lang.org/ja/latest/class/IO.html"&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt;や&lt;span class="ascii"&gt;Perl&lt;/span&gt;のファイルハンドラーにあるような仕組みと大体似ていて、&lt;code&gt;Handle&lt;/code&gt;といったデータの「入り口」を表すオブジェクトに文字コードを紐付けることで、外から入ってくる文字列の文字コードを確実に内部の統一された文字コードに変換する変換できるようにしてくれます。&lt;br /&gt;
&lt;span class="ascii"&gt;Haskell&lt;/span&gt;の&lt;code&gt;Char&lt;/code&gt;型の場合は&lt;span class="ascii"&gt;UTF-32&lt;/span&gt;（この場合その言い方でよかったっけ？）のはずです。&lt;/p&gt;
&lt;p&gt;この&lt;code&gt;Handle&lt;/code&gt;に紐付ける文字コード、当然のごとくデフォルトでは&lt;span class="ascii"&gt;OS&lt;/span&gt;のロケール設定に従って設定されるようになってまして、日本語版の&lt;span class="ascii"&gt;Windows&lt;/span&gt;ではそう、&lt;span class="ascii"&gt;Windows-31J&lt;/span&gt;（またの名を&lt;span class="ascii"&gt;CP932&lt;/span&gt;）ですね。&lt;br /&gt;
でも今はもうすぐ&lt;span class="ascii"&gt;2018&lt;/span&gt;年。あなたが「メモ帳」でプログラムを書く人でもない限り、新しく作るファイルの大半は&lt;span class="ascii"&gt;UTF-8&lt;/span&gt;でしょう。&lt;br /&gt;
&lt;span class="ascii"&gt;UTF-8&lt;/span&gt;と&lt;span class="ascii"&gt;Windows-31J&lt;/span&gt;は全然違う体系の文字コードなので、&lt;span class="ascii"&gt;UTF-8&lt;/span&gt;なファイルを&lt;span class="ascii"&gt;Windows-31J&lt;/span&gt;のファイルとして読もうとしてもうまくいかないわけです。&lt;br /&gt;
冒頭にあげた&lt;code&gt;invalid byte sequence&lt;/code&gt;というエラーはまさにそうした場合に起こるエラーです。&lt;br /&gt;
ファイルの読み書きだけでなく標準入出力でもしばしば発生するので覚えておいてください。&lt;/p&gt;
&lt;h2 id="対策"&gt;対策&lt;/h2&gt;
&lt;h3 id="ユーザーとして出くわした場合"&gt;ユーザーとして出くわした場合&lt;/h3&gt;
&lt;p&gt;多くの場合、このエラーは以下のコマンドをあらかじめ実行しておけば回避できます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; chcp 65001
&amp;gt; stack exec -- site rebuild
... 動くはず！&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これは、現在開いているコマンドプロンプトで一時的に文字コードを切り替えるコマンドです。&lt;br /&gt;
&lt;code&gt;65001&lt;/code&gt;という数字が&lt;span class="ascii"&gt;UTF-8&lt;/span&gt;を指しているようです。&lt;br /&gt;
もとに戻したい場合は&lt;code&gt;chcp 932&lt;/code&gt;と実行しましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; chcp 932&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;どうやら「&lt;span class="ascii"&gt;CP932&lt;/span&gt;」の「&lt;span class="ascii"&gt;932&lt;/span&gt;」はここで出てくる「&lt;span class="ascii"&gt;932&lt;/span&gt;」と同じものを指しているようですね！&lt;/p&gt;
&lt;p&gt;どういう仕様なのか分かりませんが、このコマンド、&lt;span class="ascii"&gt;MSYS2&lt;/span&gt;の&lt;span class="ascii"&gt;bash&lt;/span&gt;でも使用できます。&lt;br /&gt;
ただし&lt;code&gt;chcp&lt;/code&gt;コマンドは&lt;code&gt;C:\Windows\System32\&lt;/code&gt;という、&lt;span class="ascii"&gt;MSYS2&lt;/span&gt;ユーザーにとってはあまり&lt;code&gt;PATH&lt;/code&gt;に入れたくない場所に入っています。&lt;br /&gt;
このディレクトリーには、&lt;code&gt;find.exe&lt;/code&gt;など、&lt;span class="ascii"&gt;Unix&lt;/span&gt;な方が好んで使うコマンドと同じ名前の非互換なコマンドがゴロゴロ転がっているのです！&lt;/p&gt;
&lt;p&gt;なので私は&lt;span class="ascii"&gt;MSYS2&lt;/span&gt;を使う時は&lt;code&gt;C:\Windows\System32\&lt;/code&gt;は&lt;code&gt;PATH&lt;/code&gt;から抜いています。&lt;br /&gt;
私と同じような方は下記のようにフルパスで実行しましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/c/Windows/System32/chcp.com 932&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="それでもダメな場合あるいはライブラリーや開発者として出くわした場合"&gt;それでもダメな場合、あるいはライブラリーや開発者として出くわした場合&lt;/h3&gt;
&lt;p&gt;残念ながら、&lt;code&gt;chcp 65001&lt;/code&gt;してもこのエラーが消えないことはあります&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;。&lt;br /&gt;
私の推測なんですが、どうも&lt;code&gt;chcp 65001&lt;/code&gt;は&lt;code&gt;chcp 65001&lt;/code&gt;したコマンドプロンプト（とか&lt;span class="ascii"&gt;bash&lt;/span&gt;）の孫プロセス（つまり、あなたが入力したコマンドの子プロセス）には届かないことがあるようです。&lt;/p&gt;
&lt;p&gt;そんなときは、実際にエラーが起きているコマンドの開発元にバグ報告するか、自分で直してみましょう。&lt;br /&gt;
バグ報告する場合は、「&lt;code&gt;chcp 932&lt;/code&gt;してから実行してみて」とお願いすると、バグ報告を受けた開発者も再現しやすくて助かるかも知れません（残念ながら私はやったことがありません）。&lt;br /&gt;
自分で直す場合、いろいろ方法はありますが、対象の&lt;code&gt;Handle&lt;/code&gt;オブジェクトの文字コードを変えることで対処するのが、一番直接的で確実でしょう。&lt;/p&gt;
&lt;p&gt;この問題は&lt;code&gt;Handle&lt;/code&gt;に設定された文字コードと実際にやりとりされる文字列の文字コードに食い違いが発生しているため起こるものなのですから、適切な文字コードに変えてしまえばいいのです。&lt;br /&gt;
状況にもよりますがエラーが起きた&lt;code&gt;Handle&lt;/code&gt;が普通の&lt;span class="ascii"&gt;UTF-8&lt;/span&gt;なファイルを読み書きするものである場合、下記のようにすれば、問題は回避できるはずです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;System.IO&lt;/span&gt; (hSetEncoding)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;GHC.IO.Encoding&lt;/span&gt; (utf8)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;hSetEncoding handle utf8&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;それから、&lt;a href="https://github.com/haskell/haddock/pull/566"&gt;実際に私が&lt;span class="ascii"&gt;haddock&lt;/span&gt;のバグを直した時&lt;/a&gt;を例に標準出力（または標準エラー出力）でこのエラーが発生した時の対応も紹介しておきます。&lt;br /&gt;
コードだけ貼り付けると、下記のようにすれば少なくともエラーが起こらないようにすることはできます（&lt;a href="https://github.com/haskell/haddock/pull/566/commits/855118ee45e323fd9b2ee32103c7ba3eb1fbe4f2"&gt;このコミット&lt;/a&gt;とほぼ同じ内容です）。&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE CPP #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;System.IO&lt;/span&gt; (hSetEncoding, stdout)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;&lt;span class="ot"&gt;#if defined(mingw32_HOST_OS)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;GHC.IO.Encoding.CodePage&lt;/span&gt; (mkLocaleEncoding)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;GHC.IO.Encoding.Failure&lt;/span&gt; (&lt;span class="dt"&gt;CodingFailureMode&lt;/span&gt;(&lt;span class="dt"&gt;TransliterateCodingFailure&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;&lt;span class="ot"&gt;#endif&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-10" data-line-number="10"&gt;&lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-12" data-line-number="12"&gt;&lt;span class="ot"&gt;#if defined(mingw32_HOST_OS)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-13" data-line-number="13"&gt;  liftIO &lt;span class="fu"&gt;$&lt;/span&gt; hSetEncoding stdout &lt;span class="fu"&gt;$&lt;/span&gt; mkLocaleEncoding &lt;span class="dt"&gt;TransliterateCodingFailure&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-14" data-line-number="14"&gt;&lt;span class="ot"&gt;#endif&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="ascii"&gt;Windows&lt;/span&gt;でしか使用できないモジュールを&lt;code&gt;import&lt;/code&gt;している関係上、&lt;span class="ascii"&gt;CPP&lt;/span&gt;のマクロが混ざって読みにくいですが、重要な部分だけ切り出すと、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hSetEncoding stdout $ mkLocaleEncoding TransliterateCodingFailure&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;とすればよいのです。&lt;/p&gt;
&lt;p&gt;一つ一つ解説しましょう。&lt;br /&gt;
まず&lt;code&gt;hSetEncoding&lt;/code&gt;は先ほども触れたとおり指定した&lt;code&gt;Handle&lt;/code&gt;の文字コードを変更する関数です。&lt;br /&gt;
そして&lt;code&gt;stdout&lt;/code&gt;は名前の通り標準出力を表す&lt;code&gt;Handle&lt;/code&gt;です。&lt;br /&gt;
最後の&lt;code&gt;mkLocaleEncoding TransliterateCodingFailure&lt;/code&gt;ですが、これは&lt;span class="ascii"&gt;Windows&lt;/span&gt;で設定された文字コード（この場合&lt;code&gt;chcp&lt;/code&gt;された文字コードと同じ）に対して、「もし（&lt;span class="ascii"&gt;Unicode&lt;/span&gt;から、あるいは&lt;span class="ascii"&gt;Unicode&lt;/span&gt;に）変換できない文字があった場合、エラーにせず、それっぽい文字に変換する」という設定にすることができます。&lt;/p&gt;
&lt;p&gt;結果、&lt;code&gt;chcp 932&lt;/code&gt;な状態で&lt;span class="ascii"&gt;GHC&lt;/span&gt;のエラーメッセージにも使われる&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;↓この文字
• No instance for (Transformation Nagisa CardCommune_Mepple)
↑&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;が、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;? No instance for (Transformation Nagisa CardCommune_Mepple)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のように、クエスチョンマークに変換されるようになります。そう、&lt;span class="ascii"&gt;Windows&lt;/span&gt;で&lt;span class="ascii"&gt;GHC&lt;/span&gt;をお使いの方は一度は目にした「&lt;span class="ascii"&gt;?&lt;/span&gt;」ではないでしょうか😅&lt;br /&gt;
つまり&lt;span class="ascii"&gt;GHC&lt;/span&gt;はデフォルトで&lt;code&gt;mkLocaleEncoding TransliterateCodingFailure&lt;/code&gt;しているものと推測されます。&lt;br /&gt;
いずれにせよ、エラーが起きないだけマシですね。&lt;/p&gt;
&lt;p&gt;更に補足すると、&lt;span class="ascii"&gt;GHC&lt;/span&gt;の文字コードについてより詳しい情報は、&lt;a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-IO-Encoding.html"&gt;&lt;span class="ascii"&gt;GHC.IO.Encoding&lt;/span&gt;のドキュメント&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;h1 id="permission-deniedと言われたらビルドし直そう"&gt;&lt;span class="ascii"&gt;Permission Denied&lt;/span&gt;と言われたらビルドし直そう&lt;/h1&gt;
&lt;p&gt;雑なまとめと言いつつ最初の一つ目が長くなってしまいましたが、ここからは簡単に言います。&lt;br /&gt;
&lt;span class="ascii"&gt;Windows&lt;/span&gt;で&lt;code&gt;stack build&lt;/code&gt;なり&lt;code&gt;ghc&lt;/code&gt;なり&lt;code&gt;elm-make&lt;/code&gt;なりとにかくいろいろ動かしていると、「&lt;span class="ascii"&gt;Permission Denied&lt;/span&gt;」と言ったエラー（あるいはこれと似たようなメッセージのエラー）に出遭います。&lt;br /&gt;
正直に言って私は原因はサッパリ分かってないのですが、このエラーは大抵の場合何度も同じコマンドを実行すれば再現しませんでした。&lt;br /&gt;
一度や二度ではめげず、繰り返すのがポイントです 😅&lt;br /&gt;
問題が起きているディレクトリーをウィルス対策ソフトのスキャン対象から外してみるとか、&lt;span class="ascii"&gt;Dropbox&lt;/span&gt;の同期を一時的に止めてみる、といったこともやってみるといいかもしれません。&lt;/p&gt;
&lt;p&gt;あ、あと、「&lt;span class="ascii"&gt;Directory not empty&lt;/span&gt;」みたいなのもあったかな。これは同類のはずです。&lt;/p&gt;
&lt;h1 id="cのライブラリーは-まぁ頑張れ"&gt;&lt;span class="ascii"&gt;C&lt;/span&gt;のライブラリーは… まぁ、頑張れ。&lt;/h1&gt;
&lt;p&gt;&lt;span class="ascii"&gt;Pure Haskell&lt;/span&gt;なライブラリーであれば大体&lt;span class="ascii"&gt;OK&lt;/span&gt;なんですが、残念ながら&lt;span class="ascii"&gt;C&lt;/span&gt;のライブラリー（&lt;code&gt;lib***&lt;/code&gt;みたいな名前でよく&lt;span class="ascii"&gt;OS&lt;/span&gt;のパッケージマネージャーに登録されているやつですね）に依存したライブラリーは、&lt;span class="ascii"&gt;Windows&lt;/span&gt;でインストールするのは結構トラブることが多いです。&lt;br /&gt;
まぁ、これは&lt;span class="ascii"&gt;Haskell&lt;/span&gt;に限った話ではないでしょう。&lt;/p&gt;
&lt;p&gt;対応方法は私が知る限り完全にケースバイケースなので、ここでは知っている対応例をいくつか挙げておきましょう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="ascii"&gt;HDBC-sqlite3:&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/igrep/items/d947ab871eb5b20b57e4"&gt;&lt;span class="ascii"&gt;Windows&lt;/span&gt;版&lt;span class="ascii"&gt;stack&lt;/span&gt;でも&lt;span class="ascii"&gt;HDBC-sqlite3&lt;/span&gt;をビルドする &lt;span class="ascii"&gt;- Qiita&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hiratara.hatenadiary.jp/entry/2017/01/29/110100"&gt;&lt;span class="ascii"&gt;MSYS2&lt;/span&gt;で&lt;span class="ascii"&gt;HDBC-sqlite3&lt;/span&gt;をコンパイル &lt;span class="ascii"&gt;-&lt;/span&gt; 北海道苫小牧市出身の初老&lt;span class="ascii"&gt;PG&lt;/span&gt;が書くブログ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://teratail.com/questions/102462"&gt;&lt;span class="ascii"&gt;Haskell - Haskell&lt;/span&gt;にて&lt;span class="ascii"&gt;stack&lt;/span&gt;で&lt;span class="ascii"&gt;iconv&lt;/span&gt;パッケージを利用する方法【&lt;span class="ascii"&gt;Windows&lt;/span&gt;環境】&lt;span class="ascii"&gt;(102462)&lt;/span&gt;｜&lt;span class="ascii"&gt;teratail&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上です！&lt;br /&gt;
それでは&lt;span class="ascii"&gt;2018&lt;/span&gt;年も&lt;span class="ascii"&gt;Haskell on Windows 10&lt;/span&gt;で&lt;span class="ascii"&gt;Happy Hacking!! WSL&lt;/span&gt;なんて知らないぜ！🏁🏁🏁&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;敢えて脚注に書きますが、&lt;a href="http://eta-lang.org/"&gt;&lt;span class="ascii"&gt;Eta&lt;/span&gt;&lt;/a&gt;のコンパイラーをビルドしている時（のはず）、&lt;code&gt;chcp 65001&lt;/code&gt;でもダメで&lt;code&gt;chcp 20127&lt;/code&gt;ならうまくいったことがあります。&lt;br /&gt;
&lt;code&gt;chcp 20127&lt;/code&gt;は&lt;span class="ascii"&gt;US-ASCII&lt;/span&gt;に切り替えるためのコマンドですが、やっぱり&lt;span class="ascii"&gt;Eta&lt;/span&gt;の開発者の手元（？）ではそうなっているからなのでしょうか…？&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div id="post-navigation" class="row" style="margin-top: 20px;"&gt;
            &lt;div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4"&gt;
                
                &lt;i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"&gt;&lt;/i&gt;
                &lt;a href="/posts/2017/advent-calendar-2017.html"&gt;Haskell Advent Calendar 2017 まとめ&lt;/a&gt;
                
            &lt;/div&gt;
            &lt;div class="col-lg-2 col-md-2 col-xs-4 text-center"&gt;
                &lt;a href="/"&gt;トップに戻る&lt;/a&gt;
            &lt;/div&gt;
            &lt;div class="col-lg-3 col-md-4 col-xs-4"&gt;
                
                &lt;a href="/posts/2017/typesafe-precure2.html" style="margin-left: auto;"&gt;タイプセーフプリキュア！を支える技術 その2&lt;/a&gt;
                &lt;i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"&gt;&lt;/i&gt;
                
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/article&gt;

</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/12/24/202404</id><title type="text">ガバガバAltJSを作った(言語実装 Advent Calendar 2017)</title><updated>2017-12-24T20:27:10+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/12/24/202404"/><summary type="html">qiita.com JavaScriptを書いていると、頻出する継続渡しのリフレインにうんざりさせられる。 foo.bar(function(result){ qux.baz(function(data){ hoge(function(r){ ... }); }); }); そこで、腕試しに継続モナドをベースにしたAltJS、jatkoを作った。フィンランド語で「継続」という意味だ(継続戦争から知った人も多いだろう)。しかし、なんの考えもなしに653行Haskellを書いた結果ガバガバな言語になってしまった。 Hello, world Haskellにだいぶ近いのでなんとなく読めるはず。 in…</summary></entry><entry><id>https://haskell.jp/blog/posts/2017/typesafe-precure2.html</id><title type="text">タイプセーフプリキュア！を支える技術 その2</title><updated>2017-12-24T00:00:00Z</updated><author><name>Haskell-jp</name></author><link href="https://haskell.jp/blog/posts/2017/typesafe-precure2.html"/><summary type="html">&lt;article&gt;
    &lt;div class="container"&gt;
        &lt;div class="row"&gt;
            &lt;div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10"&gt;
                &lt;ul class="social-buttons"&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a href="https://twitter.com/share" class="twitter-share-button"&gt;Tweet&lt;/a&gt;
                        &lt;script&gt;!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;script type="text/javascript"&gt;
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        &lt;/script&gt;
                        &lt;script type="text/javascript" src="//www.redditstatic.com/button/button1.js"&gt;&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"&gt;&lt;/a&gt;
                        &lt;script type="text/javascript"&gt;!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"&gt;
              &lt;hr /&gt;
&lt;p&gt;このエントリーは&lt;a href="https://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;24&lt;/span&gt;日目の記事兼&lt;a href="https://adventar.org/calendars/2118"&gt;プリキュア &lt;span class="ascii"&gt;Advent Calendar 2017&lt;/span&gt;&lt;/a&gt; &lt;span class="ascii"&gt;24&lt;/span&gt;日目の記事です。&lt;br /&gt;
毎度の手口ですが、二つの&lt;span class="ascii"&gt;Advent Calendar&lt;/span&gt;に同時に投稿しています。&lt;/p&gt;
&lt;p&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;とプリキュアの&lt;span class="ascii"&gt;Advent Calendar&lt;/span&gt;ということで、去年に引き続き「&lt;a href="https://github.com/igrep/typesafe-precure/"&gt;タイプセーフプリキュア！&lt;/a&gt;」について、開発する上で見つかった問題と、その解決方法について紹介します &lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;。&lt;br /&gt;
なお、「タイプセーフプリキュア！」そのものの日本語の紹介については、&lt;a href="https://qiita.com/igrep/items/5496fa405fae00b5a737"&gt;私の去年の&lt;span class="ascii"&gt;Haskell Advent Calendar&lt;/span&gt;の記事&lt;/a&gt;や&lt;a href="http://the.igreque.info/posts/2016/06-type-safe-precure.html"&gt;同じく去年のプリキュア &lt;span class="ascii"&gt;Advent Calendar&lt;/span&gt;の記事&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;h1 id="問題提起"&gt;問題提起&lt;/h1&gt;
&lt;p&gt;例えば、あなたはたくさんの仲間と、たくさんのサブコマンドがある&lt;span class="ascii"&gt;CLI&lt;/span&gt;アプリを作っていたとします。&lt;br /&gt;
コードの規約上、サブコマンド一つにつき一つのモジュールで、決まった関数&lt;small&gt;（&lt;span class="ascii"&gt;Haskell&lt;/span&gt;であれば&lt;code&gt;[String] -&amp;gt; IO ()&lt;/code&gt;みたいな型の関数でしょうか）&lt;/small&gt;を定義するものとします。&lt;br /&gt;
そうした場合、必ずどこかのモジュールで、各モジュールで定義したサブコマンドを表す関数を列挙する必要があるでしょう。&lt;br /&gt;
その場合、次のような問題が生じることがあります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;サブコマンド（を表す関数）を追加したとき、サブコマンドを列挙しているモジュールに、追加し忘れる。&lt;/li&gt;
&lt;li&gt;複数の開発者がそれぞれのブランチで、新たに作成したサブコマンドを列挙しているモジュールに追加すると、マージする際にコンフリクトがしばしば発生する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、&lt;span class="ascii"&gt;DRY&lt;/span&gt;原則を徹底するならば「サブコマンドの名前を、サブコマンド自身の定義と列挙しているモジュールとで繰り返さない」というアイディアに基づき、こうした関数の列挙を避ける、という考え方もあるでしょう。&lt;br /&gt;
そのように作ることで、&lt;strong&gt;モジュールに関わる情報&lt;small&gt;（どのような定義で、どのように使用されるのか）&lt;/small&gt;をなるべくモジュールのファイルのみに集約&lt;/strong&gt;させることができ、モジュールに関する情報が分散してしまうのを軽減することができます。&lt;/p&gt;
&lt;p&gt;つまり、今回実現したいことは、複数のファイルに散らばった特定の関数やデータ型の定義を、自動で一カ所にまとめて再利用する、ということです。&lt;br /&gt;
この記事で何度も使うことになるので「&lt;strong&gt;定義を自動でまとめる問題&lt;/strong&gt;」と呼ぶことにします。&lt;br /&gt;
これを&lt;span class="ascii"&gt;GHC&lt;/span&gt;の各種機能を利用して、&lt;span class="ascii"&gt;Haskell&lt;/span&gt;で実現させる方法を考えましょう。&lt;/p&gt;
&lt;h1 id="ほかの言語での例"&gt;ほかの言語での例&lt;/h1&gt;
&lt;p&gt;こうした処理を&lt;span class="ascii"&gt;Haskell&lt;/span&gt;以外のプログラミング言語で行う場合、例えば下記のような機能を使うことになるでしょう。&lt;br /&gt;
参考のために、私がこれまでに出会ったものを紹介します。&lt;/p&gt;
&lt;h2 id="typesafe-precure2_case-ruby"&gt;&lt;span class="ascii"&gt;Ruby&lt;/span&gt;での場合&lt;/h2&gt;
&lt;p&gt;前職時代、私は実際にこの「定義を自動でまとめる問題」に出くわしたのですが、&lt;span class="ascii"&gt;Ruby&lt;/span&gt;を使っていたため、下記のように&lt;a href="https://docs.ruby-lang.org/ja/2.4.0/method/Module/i/included.html"&gt;&lt;span class="ascii"&gt;Module#included&lt;/span&gt;&lt;/a&gt;という、対象のモジュールを&lt;code&gt;include&lt;/code&gt;&lt;small&gt;（モジュールが提供する機能の継承）&lt;/small&gt;したときに呼ばれる、特別なメタプログラミング用のメソッドを使って解決しておりました。&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode ruby"&gt;&lt;code class="sourceCode ruby"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;ListedAsSubCommand&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;  &lt;span class="ot"&gt;@listed&lt;/span&gt; = []&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;  &lt;span class="co"&gt;# このモジュールを include するたびに呼ばれるメソッド。&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;  &lt;span class="co"&gt;# 引数として、include した Class オブジェクト（または Module オブジェクト）を受け取る&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; included klass&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;    &lt;span class="co"&gt;# include した Class オブジェクトをリストに追加して記録する&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;    &lt;span class="ot"&gt;@listed&lt;/span&gt;.push klass&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;  &lt;span class="kw"&gt;class&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class="dv"&gt;self&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;    &lt;span class="ot"&gt;attr_reader&lt;/span&gt; &lt;span class="st"&gt;:listed&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" data-line-number="14"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" data-line-number="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-17" data-line-number="17"&gt;&lt;span class="co"&gt;# path/to/commands/foo/sub_command_a.rb&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-18" data-line-number="18"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;SubCommandA&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-19" data-line-number="19"&gt;  include &lt;span class="dt"&gt;ListedAsSubCommand&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-20" data-line-number="20"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-21" data-line-number="21"&gt;  &lt;span class="co"&gt;# SubCommandA の定義 ...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-22" data-line-number="22"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-23" data-line-number="23"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-24" data-line-number="24"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-25" data-line-number="25"&gt;&lt;span class="co"&gt;# path/to/commands/bar/sub_command_b.rb&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-26" data-line-number="26"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;SubCommandB&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-27" data-line-number="27"&gt;  include &lt;span class="dt"&gt;ListedAsSubCommand&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-28" data-line-number="28"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-29" data-line-number="29"&gt;  &lt;span class="co"&gt;# SubCommandB の定義 ...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-30" data-line-number="30"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このように書くことで、&lt;code&gt;ListedAsSubCommand.listed&lt;/code&gt;というプロパティから、&lt;code&gt;ListedAsSubCommand&lt;/code&gt;を&lt;code&gt;include&lt;/code&gt;した&lt;code&gt;Class&lt;/code&gt;オブジェクトのリストが取得できます。&lt;br /&gt;
実際に使用するときは、下記のように、対象のクラスが定義されているファイルを含んだディレクトリーからまとめて&lt;code&gt;require&lt;/code&gt;した上で、&lt;code&gt;ListedAsSubCommand.listed&lt;/code&gt;にアクセスする事になるでしょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode ruby"&gt;&lt;code class="sourceCode ruby"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="co"&gt;# ListedAsSubCommand.includedが実行されるのは対象のクラスが&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="co"&gt;# 定義されたときなので、この時点では空のリスト。&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="dt"&gt;ListedAsSubCommand&lt;/span&gt;.listed &lt;span class="co"&gt;#=&amp;gt; []&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="co"&gt;# Dir.glob メソッドで、指定したディレクトリーから&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;&lt;span class="co"&gt;# 再帰的にファイルを取り出し、require で読み込む。&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;&lt;span class="dt"&gt;Dir&lt;/span&gt;.glob(&lt;span class="st"&gt;&amp;#39;path/to/commands/**/*.rb&amp;#39;&lt;/span&gt;) &lt;span class="kw"&gt;do&lt;/span&gt;|file|&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;  require file&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;&lt;span class="co"&gt;# require されたファイルの中でクラスの定義が実行されるので、&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;&lt;span class="co"&gt;# 定義したクラスがリストに追加される&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;&lt;span class="dt"&gt;ListedAsSubCommand&lt;/span&gt;.listed &lt;span class="co"&gt;#=&amp;gt; [SubCommandA, SubCommandB, ...]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="javaでの場合"&gt;&lt;span class="ascii"&gt;Java&lt;/span&gt;での場合&lt;/h2&gt;
&lt;p&gt;&lt;span class="ascii"&gt;Java&lt;/span&gt;で「定義を自動でまとめる問題」を解決する場合も、&lt;span class="ascii"&gt;Ruby&lt;/span&gt;と同様に、何らかの形でメタプログラミング用の仕組みを利用することになるかと思います。&lt;br /&gt;
とりわけ、&lt;span class="ascii"&gt;Java&lt;/span&gt;においては、この問題の解決に特化しているライブラリーの機能が存在している点が興味深いでしょう。&lt;span class="ascii"&gt;Spring&lt;/span&gt;の「コンポーネントスキャン」です。&lt;/p&gt;
&lt;p&gt;&lt;span class="ascii"&gt;Spring&lt;/span&gt;をはじめとする&lt;span class="ascii"&gt;DI&lt;/span&gt;フレームワークでは、各クラスにおいて依存するオブジェクト&lt;small&gt;（正確にはそのインターフェース）&lt;/small&gt;を宣言した際、必ず何らかの形で、「どのインターフェースにどのオブジェクトを紐付けるか」を宣言することになります。いわゆる&lt;span class="ascii"&gt;Application Context&lt;/span&gt;を書いた&lt;span class="ascii"&gt;XML&lt;/span&gt;であったり、&lt;code&gt;@Configuration&lt;/code&gt;アノテーションが着いたクラスがそれに当たります。&lt;br /&gt;
結果、モジュール&lt;small&gt;（実際には&lt;span class="ascii"&gt;Java&lt;/span&gt;なのでクラス）&lt;/small&gt;に関する情報、すなわちどのクラスのどのフィールドに、どのオブジェクトを注入するか、といった情報はすべてモジュールのファイルとは独立して管理することになり、&lt;span class="ascii"&gt;DRY&lt;/span&gt;ではなくなってしまいます。 まさに「定義を自動でまとめる問題」の典型と言えますね。&lt;/p&gt;
&lt;p&gt;それに対して&lt;span class="ascii"&gt;Spring&lt;/span&gt;の「コンポーネントスキャン」では、下記のように設定することで、「どのインターフェースにどのオブジェクトを紐付けるか」といった情報を、すべて自動で設定してしまうことができます。&lt;br /&gt;
下記はコンポーネントスキャンを&lt;code&gt;@Configuration&lt;/code&gt;アノテーションが着いた&lt;span class="ascii"&gt;Java&lt;/span&gt;のクラスで設定した場合のサンプルコードです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode java"&gt;&lt;code class="sourceCode java"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="at"&gt;@Configuration&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="at"&gt;@ComponentScan&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;example.base.package.containing.components&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="kw"&gt;public&lt;/span&gt; &lt;span class="kw"&gt;class&lt;/span&gt; AppConfig {&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;@Configuration&lt;/code&gt;アノテーションを付与した&lt;span class="ascii"&gt;Java&lt;/span&gt;のクラスに、更に&lt;code&gt;@ComponentScan&lt;/code&gt;というアノテーションを付与すると、&lt;span class="ascii"&gt;Spring&lt;/span&gt;は、&lt;code&gt;@ComponentScan&lt;/code&gt;アノテーションの引数として渡した名前空間以下に存在する、すべての&lt;code&gt;@Component&lt;/code&gt;というアノテーションが着いたクラスのオブジェクトを、自動的にほかの&lt;code&gt;@Component&lt;/code&gt;が着いたクラスのフィールドとして設定できるようにします&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode java"&gt;&lt;code class="sourceCode java"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="at"&gt;@Component&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;span class="kw"&gt;public&lt;/span&gt; &lt;span class="kw"&gt;class&lt;/span&gt; SomeComponent {&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;  &lt;span class="co"&gt;// ...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このようにコンポーネントスキャンを使うことで、&lt;code&gt;@ComponentScan&lt;/code&gt;されたクラスのオブジェクトは自動で依存するオブジェクトとして紐付けられるようになります。&lt;br /&gt;
従来&lt;code&gt;foo-context.xml&lt;/code&gt;みたいな名前のファイルに、どのオブジェクトのどのフィールドにどのオブジェクトを紐付けるか、といった情報を一つ一つ書いていたのを、ほとんど書かなくて済むようになりました。&lt;/p&gt;
&lt;h1 id="typesafe-precure2_requirement"&gt;解決に必要なもの&lt;/h1&gt;
&lt;p&gt;さて、私が経験した二つの言語における「定義を自動でまとめる問題」の解決方法を見てきたところで、この問題を解決するのに共通して必要なことを列挙しましょう。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class="ascii"&gt;(1)&lt;/span&gt; 対象となる「まとめたい定義（モジュールや関数、型など）」が書かれているファイルが、どのディレクトリー以下にあるか設定する&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;「定義を自動でまとめる問題」に取り組むに当たり、最低限必要となるのが、この設定です。&lt;br /&gt;
まさかファイルシステムにあるすべてのソースコードから「まとめたい定義」を探すわけにも行きませんし、プロジェクトのディレクトリーすべてを処理するのも、柔軟性に欠けた解決方法でしょう。そこで通例「定義を自動でまとめる問題」に対応する際は、「まとめたい定義（モジュールや関数、型など）」が書かれているファイルがどのディレクトリー以下にあるか、を何らかの形で書くことになります。&lt;/p&gt;
&lt;p&gt;前述の&lt;span class="ascii"&gt;Ruby&lt;/span&gt;による例の場合、この情報は下記の&lt;code&gt;Dir.glob&lt;/code&gt;メソッドに渡した引数に当たります。&lt;br /&gt;
&lt;code&gt;'path/to/commands/**/*.rb'&lt;/code&gt; という文字列のうち、 &lt;code&gt;path/to/commands/&lt;/code&gt; の部分ですね。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode ruby"&gt;&lt;code class="sourceCode ruby"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="dt"&gt;Dir&lt;/span&gt;.glob(&lt;span class="st"&gt;&amp;#39;path/to/commands/**/*.rb&amp;#39;&lt;/span&gt;) &lt;span class="kw"&gt;do&lt;/span&gt;|file|&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;  require file&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="ascii"&gt;Java&lt;/span&gt;における&lt;span class="ascii"&gt;Spring&lt;/span&gt;のコンポーネントスキャンの場合、&lt;code&gt;@ComponentScan&lt;/code&gt;アノテーションに渡した引数が該当します。&lt;br /&gt;
厳密には、&lt;code&gt;@ComponentScan&lt;/code&gt;アノテーションに渡す引数はディレクトリーのパスではなく&lt;code&gt;Java&lt;/code&gt;のパッケージの名前ですが、&lt;span class="ascii"&gt;Java&lt;/span&gt;ではパッケージはクラスパス以下のディレクトリーと一対一で対応するよう作る必要があるので、事実上ディレクトリーのパスを渡していると言えるでしょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode java"&gt;&lt;code class="sourceCode java"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="at"&gt;@Configuration&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="at"&gt;@ComponentScan&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;example.base.package.containing.components&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;span class="kw"&gt;public&lt;/span&gt; &lt;span class="kw"&gt;class&lt;/span&gt; AppConfig {&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class="ascii"&gt;(2)&lt;/span&gt; 「まとめたい定義（モジュールや関数、型など）」が書かれたファイルに、なんらかの印をつける&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;「定義を自動でまとめる問題」では、「どの定義を自動でまとめるか」さえ指定できればよいので、理屈の上では前述の「&lt;span class="ascii"&gt;(1)&lt;/span&gt; 対象となる『まとめたい定義（モジュールや関数、型など）』が書かれているファイルが、どのディレクトリー以下にあるか設定する」さえできれば、後はディレクトリー以下のファイルをすべて自動でまとめられるはずです。 しかし、それだけでは次の問題が生じてしまう恐れがあります。&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;「自動でまとめられるファイル」がどのように使用されるか理解しにくくなる。
&lt;ul&gt;
&lt;li&gt;「自動でまとめられるファイル」に書かれた定義は、多くの場合、明確に使用される箇所で言及されなくなってしまいます。結果、そのファイルを読んだだけでは、書かれている定義がどこでどう使われているのか、そもそも本当に使われているのかどうかすら分からなくってしまいます。プロジェクトに新しく参加する人は、相応の学習が必要になってしまうでしょう。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;細かい例外を設定しにくい。
&lt;ul&gt;
&lt;li&gt;「まとめたい定義が書かれたファイル」を含むディレクトリーの中に、まとめる対象としたくないファイルを作る、ということがやりにくくなってしまいます。&lt;/li&gt;
&lt;li&gt;例えばサブコマンドの例で言えば、&lt;code&gt;Commands&lt;/code&gt;というディレクトリー以下に複数のサブコマンド（まとめられる対象）を置いたとき、各サブコマンドで共有されるユーティリティー関数も&lt;code&gt;Commands&lt;/code&gt;ディレクトリー以下に置きたくなるかも知れません。もちろん状況に応じてほかのディレクトリーに置く手段も検討すべきですが、そうしたユーティリティー関数の入ったファイルは自動でまとめて欲しくないでしょう。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;そうした問題を軽減するために、「定義を自動でまとめる問題」に対応する際は、必ず「『まとめたい定義（モジュールや関数、型など）』が書かれたファイルに、なんらかの印をつける」ことを検討した方がいいと思います。&lt;/p&gt;
&lt;p&gt;前述の&lt;span class="ascii"&gt;Ruby&lt;/span&gt;による例で言えば、これは&lt;code&gt;include ListedAsSubCommand&lt;/code&gt;という、&lt;code&gt;included&lt;/code&gt;メソッドを実装した&lt;code&gt;ListedAsSubCommand&lt;/code&gt;モジュールを&lt;code&gt;include&lt;/code&gt;することが該当します。&lt;br /&gt;
&lt;span class="ascii"&gt;Java&lt;/span&gt;の&lt;span class="ascii"&gt;Spring&lt;/span&gt;のコンポーネントスキャンの場合、まさしく&lt;code&gt;@Component&lt;/code&gt;アノテーションがそれに当たるでしょう。&lt;/p&gt;
&lt;p&gt;これらの印が着いたファイルを読む場合、この「印」を手がかりにして、コードベースを検索したり定義ジャンプしたり、&lt;span class="ascii"&gt;Spring&lt;/span&gt;の場合はインターネットを検索したりすることで、「印」の役割を知り、そのファイルがどう使われるのか調べることができるのです。&lt;/p&gt;
&lt;h1 id="typesafe-precure2_warnings"&gt;注意点&lt;/h1&gt;
&lt;p&gt;いよいよ次の節で「定義を自動でまとめる問題」を&lt;span class="ascii"&gt;Haskell&lt;/span&gt;で解決した例を紹介いたしますが、その前にこの問題を解決することによって生じる、副作用について強調しておきましょう。 私の観測範囲内でですが、今までこの問題に対応した例を見たことがないのは、そうした副作用による悪影響が大きいと感じている人が多数派だからなのかも知れません。&lt;/p&gt;
&lt;p&gt;それは、前節でも触れましたが、「『自動でまとめられるファイル』がどのように使用されるか理解しにくくなる」ということです。&lt;br /&gt;
この問題は、確かに「『まとめたい定義（モジュールや関数、型など）』が書かれたファイルに、なんらかの印をつける」ことである程度緩和可能な問題ではありますが、それでも強く意識するべきでしょう。&lt;br /&gt;
「自動でまとめられるファイル」を初めて読んだ人が、&lt;code&gt;include ListedAsSubCommand&lt;/code&gt;や&lt;code&gt;@Component&lt;/code&gt;という印に気づければよいのですが、そうでない場合、使用箇所を求めてコードベースをさまようことになってしまいます。&lt;br /&gt;
事前に「印」の存在を知らせておくに越したことはありません。&lt;/p&gt;
&lt;p&gt;それから、「『まとめたい定義（モジュールや関数、型など）』が書かれたファイルに、なんらかの印をつける」ことを選択した場合、「まとめたい定義が書かれたファイル」を新しく追加したいとき、ファイルにその「印」を書き忘れてしまうことがある点も、覚えておくべきでしょう。&lt;br /&gt;
当初この「定義を自動でまとめる問題」を提起した際、自動でまとめなかった場合のデメリットしてあげた、&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;サブコマンド（を表す関数）を追加したとき、サブコマンドを列挙しているモジュールに、追加し忘れる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;という問題と本質的に同じです。&lt;br /&gt;
自動でまとめずに手で定義を列挙した場合と比べて、編集するファイルが少ない分、忘れる可能性は低いかもしれません。&lt;br /&gt;
ひな形に「印」を含めれば、さらに忘れる確率を下げることができるでしょう。手で一つのファイルに定義を列挙していた場合、そうした工夫はできません。&lt;br /&gt;
ですが、いずれにしても忘れてしまうリスクがあることは変わらないでしょう。&lt;/p&gt;
&lt;p&gt;以上の通り、結局のところ、「定義を自動でまとめる」よう設定するか、単純にまとめたい定義を手で列挙するかどうかは、そうしたトレードオフを考慮しつつ落ち着いて考えるのを推奨します。&lt;br /&gt;
これから紹介する方法を採用する際も、ここであげた注意点については忘れないでください。&lt;/p&gt;
&lt;h1 id="haskellでの解決事例---タイプセーフプリキュアにおけるcure-index.jsonの実装"&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;での解決事例 &lt;span class="ascii"&gt;-&lt;/span&gt; 「タイプセーフプリキュア！」における&lt;code&gt;cure-index.json&lt;/code&gt;の実装&lt;/h1&gt;
&lt;p&gt;「&lt;a href="https://github.com/igrep/typesafe-precure/"&gt;タイプセーフプリキュア！&lt;/a&gt;」&lt;small&gt;（パッケージとしての名前は&lt;a href="https://hackage.haskell.org/package/typesafe-precure"&gt;&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;&lt;/a&gt;なので、以下「&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;」と呼びます）&lt;/small&gt;では、最近の更新により、コンパイル時に「&lt;a href="https://github.com/igrep/typesafe-precure/blob/master/gen/cure-index.json"&gt;&lt;span class="ascii"&gt;cure-index.json&lt;/span&gt;&lt;/a&gt;」と、「&lt;a href="https://github.com/igrep/typesafe-precure/blob/master/gen/pretty-cure-index.json"&gt;&lt;span class="ascii"&gt;pretty-cure-index.json&lt;/span&gt;&lt;/a&gt;」いうファイルを生成するようになりました。&lt;br /&gt;
次のような内容のファイルです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode json"&gt;&lt;code class="sourceCode json"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="fu"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;    &lt;span class="dt"&gt;&amp;quot;specialItems&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="ot"&gt;[&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;        &lt;span class="fu"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;            &lt;span class="dt"&gt;&amp;quot;nameEn&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Sweets Pact&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;            &lt;span class="dt"&gt;&amp;quot;attachments&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="ot"&gt;[&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" data-line-number="6"&gt;                &lt;span class="st"&gt;&amp;quot;Animal Sweets&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-7" data-line-number="7"&gt;            &lt;span class="ot"&gt;]&lt;/span&gt;&lt;span class="fu"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-8" data-line-number="8"&gt;            &lt;span class="dt"&gt;&amp;quot;nameJa&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;スイーツパクト&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-9" data-line-number="9"&gt;            &lt;span class="dt"&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;SweetsPact&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-10" data-line-number="10"&gt;        &lt;span class="fu"&gt;}&lt;/span&gt;&lt;span class="ot"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-11" data-line-number="11"&gt;        &lt;span class="er"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-12" data-line-number="12"&gt;    &lt;span class="ot"&gt;]&lt;/span&gt;&lt;span class="fu"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-13" data-line-number="13"&gt;    &lt;span class="dt"&gt;&amp;quot;transformees&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="ot"&gt;[&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-14" data-line-number="14"&gt;        &lt;span class="fu"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-15" data-line-number="15"&gt;            &lt;span class="dt"&gt;&amp;quot;nameEn&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Cure Whip&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-16" data-line-number="16"&gt;            &lt;span class="dt"&gt;&amp;quot;variationEn&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-17" data-line-number="17"&gt;            &lt;span class="dt"&gt;&amp;quot;nameJa&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;キュアホイップ&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-18" data-line-number="18"&gt;            &lt;span class="dt"&gt;&amp;quot;variationJa&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-19" data-line-number="19"&gt;            &lt;span class="dt"&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;CureWhip&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-20" data-line-number="20"&gt;            &lt;span class="dt"&gt;&amp;quot;introducesHerselfAs&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;ショートケーキ！元気と笑顔を！レッツ・ラ・まぜまぜ！キュアホイップ！できあがり！&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-21" data-line-number="21"&gt;        &lt;span class="fu"&gt;}&lt;/span&gt;&lt;span class="ot"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-22" data-line-number="22"&gt;        &lt;span class="er"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-23" data-line-number="23"&gt;    &lt;span class="ot"&gt;]&lt;/span&gt;&lt;span class="fu"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-24" data-line-number="24"&gt;    &lt;span class="dt"&gt;&amp;quot;girls&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="ot"&gt;[&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-25" data-line-number="25"&gt;        &lt;span class="fu"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-26" data-line-number="26"&gt;            &lt;span class="dt"&gt;&amp;quot;nameEn&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Ichika Usami&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-27" data-line-number="27"&gt;            &lt;span class="dt"&gt;&amp;quot;nameJa&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;宇佐美 いちか&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-28" data-line-number="28"&gt;            &lt;span class="dt"&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Ichika&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-29" data-line-number="29"&gt;        &lt;span class="fu"&gt;}&lt;/span&gt;&lt;span class="ot"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-30" data-line-number="30"&gt;        &lt;span class="er"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-31" data-line-number="31"&gt;    &lt;span class="ot"&gt;]&lt;/span&gt;&lt;span class="fu"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-32" data-line-number="32"&gt;    &lt;span class="er"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-33" data-line-number="33"&gt;&lt;span class="fu"&gt;}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これは、変身アイテムからプリキュア、プリキュアに変身する前の女の子、それから浄化技や変身時の台詞まで、&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;で定義されているあらゆる情報をまとめた&lt;span class="ascii"&gt;JSON&lt;/span&gt;です。&lt;br /&gt;
まさしく、プリキュアの定義を自動でまとめた「インデックス」となっております &lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;。&lt;br /&gt;
ただし、残念ながら現時点では「キラキラ☆プリキュアアラモード」に収録されたプリキュアの情報しか、&lt;code&gt;cure-index.json&lt;/code&gt;には記録されていません&lt;small&gt;（理由は後で説明します）&lt;/small&gt;。&lt;/p&gt;
&lt;p&gt;名前の通り、&lt;span class="ascii"&gt;pretty-&lt;/span&gt;&lt;code&gt;cure-index.json&lt;/code&gt;には&lt;code&gt;cure-index.json&lt;/code&gt;をプリティープリントした&lt;span class="ascii"&gt;JSON&lt;/span&gt;が記録されています。&lt;br /&gt;
下記のように&lt;code&gt;curl&lt;/code&gt;して確かめてみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;curl&lt;/span&gt; -sL https://github.com/igrep/typesafe-precure/raw/master/gen/cure-index.json&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;{&lt;span class="st"&gt;&amp;quot;girls&amp;quot;&lt;/span&gt;:[{&lt;span class="st"&gt;&amp;quot;id&amp;quot;&lt;/span&gt;:&lt;span class="st"&gt;&amp;quot;Ichika&amp;quot;&lt;/span&gt;,&lt;span class="st"&gt;&amp;quot;nameEn&amp;quot;&lt;/span&gt;:&lt;span class="st"&gt;&amp;quot;Ichika Usami&amp;quot;&lt;/span&gt;,&lt;span class="st"&gt;&amp;quot;nameJa&amp;quot;&lt;/span&gt;:&lt;span class="st"&gt;&amp;quot;宇佐美 いちか&amp;quot;&lt;/span&gt;},{&lt;span class="st"&gt;&amp;quot;id&amp;quot;&lt;/span&gt;:&lt;span class="st"&gt;&amp;quot;Himari&amp;quot;&lt;/span&gt;,&lt;span class="st"&gt;&amp;quot;nameEn&amp;quot;&lt;/span&gt;:&lt;span class="st"&gt;&amp;quot;Himari Arisugawa&amp;quot;&lt;/span&gt;,&lt;span class="st"&gt;&amp;quot;nameJa&amp;quot;&lt;/span&gt;:&lt;span class="st"&gt;&amp;quot;有栖川 ひまり&amp;quot;&lt;/span&gt;}&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;&lt;span class="ex"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;$ &lt;span class="ex"&gt;curl&lt;/span&gt; -sL https://github.com/igrep/typesafe-precure/raw/master/gen/pretty-cure-index.json&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;&lt;span class="kw"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;    &lt;span class="st"&gt;&amp;quot;specialItems&amp;quot;&lt;/span&gt;:&lt;span class="bu"&gt; [&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;        {&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;            &lt;span class="st"&gt;&amp;quot;nameEn&amp;quot;&lt;/span&gt;: &lt;span class="st"&gt;&amp;quot;Sweets Pact&amp;quot;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" data-line-number="9"&gt;...&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;さて、この&lt;code&gt;cure-index.json&lt;/code&gt;、繰り返しになりますが、&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;で定義されている、すべてのプリキュアの情報をまとめた&lt;span class="ascii"&gt;JSON&lt;/span&gt;となっております。&lt;br /&gt;
ライブラリーとしての&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;では、これらの情報は一つ一つが&lt;span class="ascii"&gt;Haskell&lt;/span&gt;の型として定義&lt;span class="ascii"&gt;[^detail-typesafe-precure]&lt;/span&gt;されており、&lt;code&gt;cure-index.json&lt;/code&gt;は、それらの情報をコンパイル時に「自動でまとめる」ことで作成されます。決して、&lt;span class="ascii"&gt;JSON&lt;/span&gt;から&lt;span class="ascii"&gt;Haskell&lt;/span&gt;の型を作っているわけではありません。&lt;br /&gt;
詳細は冒頭にも挙げましたが、&lt;a href="https://qiita.com/igrep/items/5496fa405fae00b5a737"&gt;私の去年の&lt;span class="ascii"&gt;Haskell Advent Calendar&lt;/span&gt;の記事&lt;/a&gt;や&lt;a href="http://the.igreque.info/posts/2016/06-type-safe-precure.html"&gt;同年のプリキュア &lt;span class="ascii"&gt;Advent Calendar&lt;/span&gt;の記事&lt;/a&gt;をご覧ください。&lt;br /&gt;
ここではそれを実現するために使用した、&lt;span class="ascii"&gt;Haskell&lt;/span&gt;で「定義を自動でまとめる」方法を紹介しましょう。&lt;/p&gt;
&lt;h2 id="使用したghcについて"&gt;使用した&lt;span class="ascii"&gt;GHC&lt;/span&gt;について&lt;/h2&gt;
&lt;p&gt;…と、その前に、今回&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;のビルドに使用した&lt;span class="ascii"&gt;GHC&lt;/span&gt;のバージョンを述べておきましょう。&lt;/p&gt;
&lt;p&gt;&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;は現在&lt;span class="ascii"&gt;(ver. 0.5.0.1)&lt;/span&gt;の時点において、通常&lt;span class="ascii"&gt;GHC 8.0.2&lt;/span&gt;でビルドされています。&lt;br /&gt;
特に&lt;span class="ascii"&gt;CI&lt;/span&gt;での確認はしていませんが、&lt;span class="ascii"&gt;GHC 7.10&lt;/span&gt;でもビルドできるはずです。&lt;br /&gt;
従って、使用している&lt;span class="ascii"&gt;template-haskell&lt;/span&gt;パッケージは&lt;a href="https://hackage.haskell.org/package/template-haskell-2.10.0.0"&gt;&lt;span class="ascii"&gt;2.10.0.0&lt;/span&gt;&lt;/a&gt;から&lt;a href="https://hackage.haskell.org/package/template-haskell-2.11.1.0"&gt;&lt;span class="ascii"&gt;2.11.1.0&lt;/span&gt;&lt;/a&gt;となっています。&lt;/p&gt;
&lt;p&gt;この記事で紹介する機能は、&lt;span class="ascii"&gt;GHC&lt;/span&gt;&lt;small&gt;（と、&lt;span class="ascii"&gt;GHC&lt;/span&gt;に標準添付される&lt;span class="ascii"&gt;template-haskell&lt;/span&gt;パッケージ）&lt;/small&gt;のバージョンによって、大きく変わる場合があります。&lt;br /&gt;
今回は「できない」としたことも、将来の&lt;span class="ascii"&gt;GHC&lt;/span&gt;ではできるようになっている（あるいは運悪くその逆もある）かもしれません。&lt;br /&gt;
あらかじめご了承ください。&lt;/p&gt;
&lt;p&gt;なお、各バージョンの&lt;span class="ascii"&gt;GHC&lt;/span&gt;に標準添付されているパッケージのバージョンについては、&lt;a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory"&gt;&lt;span class="ascii"&gt;Commentary/Libraries/VersionHistory&lt;/span&gt; – &lt;span class="ascii"&gt;GHC&lt;/span&gt;&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;h2 id="annでまとめたい型が書かれたモジュールに印を着ける"&gt;&lt;span class="ascii"&gt;ANN&lt;/span&gt;で「まとめたい型」が書かれたモジュールに「印」を着ける&lt;/h2&gt;
&lt;p&gt;まず、「『まとめたい定義（モジュールや関数、型など）』が書かれたファイルに、なんらかの印をつける」方法を考えましょう。&lt;br /&gt;
実は&lt;span class="ascii"&gt;Haskell(GHC)&lt;/span&gt;にもアノテーションがあります&lt;small&gt;（&lt;span class="ascii"&gt;Java&lt;/span&gt;のアノテーションと使い勝手が異なりますが）&lt;/small&gt;。&lt;br /&gt;
&lt;code&gt;ANN&lt;/code&gt;という&lt;a href="https://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-18800012"&gt;&lt;span class="ascii"&gt;GHC&lt;/span&gt;のプラグマ&lt;/a&gt;（&lt;code&gt;{-# ... #-}&lt;/code&gt; という形式で表される、特別なコメント）を使用すると、下記のように、モジュールや型、名前が付いた値に対して、アノテーションを加えることができます&lt;small&gt;（例は&lt;a href="https://qiita.com/philopon/items/85210cc8f23ae04ba6ec"&gt;アンッ&lt;span class="ascii"&gt;!!!&lt;/span&gt;アンッ&lt;span class="ascii"&gt;!!!! - Qiita&lt;/span&gt;&lt;/a&gt;から拝借しました）&lt;/small&gt;。&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Foo&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# ANN module (&amp;quot;annotation&amp;quot; :: String) #-}&lt;/span&gt; &lt;span class="co"&gt;-- モジュールに対する注釈。importの前には書けないっぽい。不便……&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Foo&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Foo&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;&lt;span class="ot"&gt;{-# ANN type Foo (2 :: Int) #-}&lt;/span&gt; &lt;span class="co"&gt;-- 型に対する注釈&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;&lt;span class="ot"&gt;{-# ANN type Foo (5 :: Int) #-}&lt;/span&gt; &lt;span class="co"&gt;-- 注釈を同じ/違う型で複数個付ける事も出来る&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;&lt;span class="ot"&gt;{-# ANN type Foo (2.4 :: Double) #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-9" data-line-number="9"&gt;&lt;span class="ot"&gt;foo ::&lt;/span&gt; &lt;span class="dt"&gt;Foo&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-10" data-line-number="10"&gt;foo &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Foo&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-11" data-line-number="11"&gt;&lt;span class="ot"&gt;{-# ANN foo (3 + 2 * 6 :: Int) #-}&lt;/span&gt; &lt;span class="co"&gt;-- 値に対する注釈。注釈の中で計算する事も可能&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記の通り、&lt;span class="ascii"&gt;GHC&lt;/span&gt;の&lt;code&gt;ANN&lt;/code&gt;は、&lt;span class="ascii"&gt;Java&lt;/span&gt;のアノテーションと異なり、アノテーション専用のインターフェースを作って引数を補足情報として渡す、というような形式ではありません&lt;small&gt;（そもそも&lt;span class="ascii"&gt;Haskell&lt;/span&gt;にはインターフェースなんてありませんしね）&lt;/small&gt;。&lt;br /&gt;
&lt;code&gt;Data&lt;/code&gt;型クラスのインスタンスである型の値であれば、なんでもアノテーションとして設定できます。&lt;/p&gt;
&lt;p&gt;その&lt;code&gt;Data&lt;/code&gt;型クラスのインスタンスですが、&lt;code&gt;base&lt;/code&gt;パッケージに含まれている多くの型に加え、&lt;code&gt;DeriveDataTypeable&lt;/code&gt;という&lt;span class="ascii"&gt;GHC&lt;/span&gt;の言語拡張を使えば、オリジナルの型も簡単にそのインスタンスにすることができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DeriveDataTypeable #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Data&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;SomeOriginalType&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;  &lt;span class="dt"&gt;SomeOriginalValue&lt;/span&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="dt"&gt;Data&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この、&lt;code&gt;Data&lt;/code&gt;型クラスを使えば、実行時に型の構造を取得したりすることができます。&lt;br /&gt;
とはいえ、ここでは単純に&lt;code&gt;{-# LANGUAGE DeriveDataTypeable #-}&lt;/code&gt;と&lt;code&gt;deriving Data&lt;/code&gt;を「おまじない」として使うだけで差し支えありません。&lt;br /&gt;
詳しく知りたい方は&lt;a href="https://github.com/shiatsumat/wiwinwlh-jp/wiki/%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%82%AF%E3%82%B9"&gt;「&lt;span class="ascii"&gt;What I Wish I Knew When Learning Haskell&lt;/span&gt; 日本語訳」の「ジェネリクス」の章&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;p&gt;さて&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;では、この&lt;code&gt;Data&lt;/code&gt;型クラスと&lt;code&gt;ANN&lt;/code&gt;プラグマを利用した次のようなアプローチで、各モジュールに対し、プリキュアやプリキュアに関する情報を「印」として付与しました。&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/igrep/typesafe-precure/blob/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/src/ACME/PreCure/Index/Types.hs"&gt;&lt;code&gt;ACME.PreCure.Index.Types&lt;/code&gt;&lt;/a&gt;というモジュールに、型の名前やインスタンスの定義を自動生成したり、それを&lt;span class="ascii"&gt;JSON&lt;/span&gt;に変換したりするのに使う、中間データのための型を作る。&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Girl&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;  &lt;span class="dt"&gt;Girl&lt;/span&gt; {&lt;span class="ot"&gt; girlId ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;,&lt;span class="ot"&gt; girlNameEn ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;,&lt;span class="ot"&gt; girlNameJa ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; }&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;    &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Eq&lt;/span&gt;, &lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Data&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;この、各種中間データ用の型を&lt;code&gt;Data&lt;/code&gt;型クラスのインスタンスとすることで、「まとめたい定義」が含まれたモジュールに、その中間データ用の値を&lt;code&gt;ANN&lt;/code&gt;プラグマで付与できるようにする。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;名前が&lt;code&gt;ACME.PreCure.Textbook.*.Profiles&lt;/code&gt;という形式のモジュール&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;small&gt;（&lt;a href="https://github.com/igrep/typesafe-precure/blob/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/src/ACME/PreCure/Textbook/KirakiraALaMode/Profiles.hs"&gt;「キラキラ☆プリキュアアラモード」での例&lt;/a&gt;）&lt;/small&gt;で、中間データの値&lt;small&gt;（つまり各プリキュアや変身アイテムなどについての情報）&lt;/small&gt;を定義する。&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="ot"&gt;girls ::&lt;/span&gt; [&lt;span class="dt"&gt;Girl&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;girls &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;  [ mkGirl &lt;span class="st"&gt;&amp;quot;Ichika Usami&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;宇佐美 いちか&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;  , mkGirl &lt;span class="st"&gt;&amp;quot;Himari Arisugawa&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;有栖川 ひまり&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" data-line-number="5"&gt;  , mkGirl &lt;span class="st"&gt;&amp;quot;Aoi Tategami&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;立神 あおい&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" data-line-number="6"&gt;  , mkGirl &lt;span class="st"&gt;&amp;quot;Yukari Kotozume&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;琴爪 ゆかり&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" data-line-number="7"&gt;  , mkGirl &lt;span class="st"&gt;&amp;quot;Akira Kenjo&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;剣城 あきら&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-8" data-line-number="8"&gt;  , mkGirl &lt;span class="st"&gt;&amp;quot;Ciel Kirahoshi&amp;quot;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;キラ星 シエル&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-9" data-line-number="9"&gt;  ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;small&gt;&lt;span class="ascii"&gt;1.&lt;/span&gt; &lt;code&gt;ACME.PreCure.Textbook.*.Profiles&lt;/code&gt;で定義した中間データを、&lt;code&gt;ACME.PreCure.Textbook.KirakiraALaMode.Types&lt;/code&gt;という形式のモジュールに対して&lt;code&gt;ANN&lt;/code&gt;プラグマで付与する（同じく&lt;a href="https://github.com/igrep/typesafe-precure/blob/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/src/ACME/PreCure/Textbook/KirakiraALaMode/Types.hs"&gt;「キラキラ☆プリキュアアラモード」での例&lt;/a&gt;）&lt;/small&gt;。&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;ACME.PreCure.Textbook.KirakiraALaMode.Types&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;ACME.PreCure.Textbook.KirakiraALaMode.Profiles&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;&lt;span class="ot"&gt;{-# ANN module girls #-}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="stage-restrictionを避けるためにモジュールを分ける"&gt;&lt;span class="ascii"&gt;Stage Restriction&lt;/span&gt;を避けるためにモジュールを分ける&lt;/h3&gt;
&lt;p&gt;先の手順で引用したコードをご覧になった方は、こんなことを疑問に思ったかも知れません。&lt;br /&gt;
中間データの値を定義するモジュールと、&lt;code&gt;ANN&lt;/code&gt;で中間データの値を付与するモジュールとを分ける必要があるのか、と。&lt;br /&gt;
上記の例で言えば、一つのモジュール&lt;span class="ascii"&gt;(&lt;/span&gt;&lt;code&gt;ACME.PreCure.Textbook.KirakiraALaMode.Types&lt;/code&gt;&lt;span class="ascii"&gt;)&lt;/span&gt;で&lt;code&gt;girls&lt;/code&gt;を定義しつつ&lt;code&gt;ANN&lt;/code&gt;で付与すればよいのではないか、ということです。&lt;br /&gt;
あるいは&lt;code&gt;girls&lt;/code&gt;という名前をつけずに、&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# ANN module&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;&lt;span class="ot"&gt;    [ mkGirl &amp;quot;Ichika Usami&amp;quot; &amp;quot;宇佐美 いちか&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;&lt;span class="ot"&gt;    , mkGirl &amp;quot;Himari Arisugawa&amp;quot; &amp;quot;有栖川 ひまり&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" data-line-number="4"&gt;&lt;span class="ot"&gt;    , mkGirl &amp;quot;Aoi Tategami&amp;quot; &amp;quot;立神 あおい&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-5" data-line-number="5"&gt;&lt;span class="ot"&gt;    , mkGirl &amp;quot;Yukari Kotozume&amp;quot; &amp;quot;琴爪 ゆかり&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-6" data-line-number="6"&gt;&lt;span class="ot"&gt;    , mkGirl &amp;quot;Akira Kenjo&amp;quot; &amp;quot;剣城 あきら&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-7" data-line-number="7"&gt;&lt;span class="ot"&gt;    , mkGirl &amp;quot;Ciel Kirahoshi&amp;quot; &amp;quot;キラ星 シエル&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-8" data-line-number="8"&gt;&lt;span class="ot"&gt;    ]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-9" data-line-number="9"&gt;&lt;span class="ot"&gt;#-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-10" data-line-number="10"&gt;&lt;span class="co"&gt;-- 注: このコードは試していないので文法が合っているか自信がないです。&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;というような書き方はできないのか、ということです。&lt;/p&gt;
&lt;p&gt;中間データの値を&lt;code&gt;ANN&lt;/code&gt;で使うだけならそれで問題ないのですが、&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;の場合、中間データの値からプリキュアや変身アイテムを表す型と、その型クラスのインスタンスを定義する必要があります。&lt;br /&gt;
なので、先ほどのコード例にあった&lt;code&gt;ACME.PreCure.Textbook.KirakiraALaMode.Profiles&lt;/code&gt;というモジュールでは、実際には&lt;code&gt;{-# ANN module girls #-}&lt;/code&gt;の行の後に、&lt;code&gt;girls&lt;/code&gt;から、プリキュアに変身する女の子（を表す型）や、それに対して型クラスのインスタンスを宣言する&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;のコードが続いています。&lt;br /&gt;
下記の&lt;code&gt;$(declareGirls girls)&lt;/code&gt;という行がそれです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;ACME.PreCure.Textbook.KirakiraALaMode.Types&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;ACME.PreCure.Textbook.KirakiraALaMode.Profiles&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;&lt;span class="ot"&gt;{-# ANN module girls #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;&lt;span class="fu"&gt;$&lt;/span&gt;(declareGirls girls)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;詳細は冒頭でも挙げた&lt;a href="https://qiita.com/igrep/items/5496fa405fae00b5a737"&gt;私の去年の&lt;span class="ascii"&gt;Haskell Advent Calendar&lt;/span&gt;の記事&lt;/a&gt;などをご覧いただきたいのですが、&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;では、それぞれのプリキュアや、プリキュアに変身する女の子、変身に必要なアイテムなどを、すべて&lt;strong&gt;個別の型&lt;/strong&gt;として定義しています。&lt;br /&gt;
そのため、中間データの値は&lt;span class="ascii"&gt;JSON&lt;/span&gt;としてまとめるだけでなく、個別の型として定義する必要もあったのです。&lt;br /&gt;
その結果、中間データの値は必ず名前をつけて使い回さないといけなくなるのです。&lt;/p&gt;
&lt;p&gt;そして、&lt;code&gt;ANN&lt;/code&gt;や&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;において値に名前をつけて使い回す場合、「&lt;span class="ascii"&gt;Stage Restriction&lt;/span&gt;」というやっかいな制限が顔を出してきます。&lt;br /&gt;
これは、「&lt;code&gt;ANN&lt;/code&gt;で値を付与する式や、トップレベルの宣言などを生成する&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;のコードでは、&lt;strong&gt;ほかのモジュールから&lt;code&gt;import&lt;/code&gt;された名前しか&lt;/strong&gt;参照できない」という制限です&lt;small&gt;（詳しくは「&lt;a href="http://haskell.g.hatena.ne.jp/mr_konn/20111218/1324220725"&gt;できる！&lt;span class="ascii"&gt;Template Haskell (&lt;/span&gt;完&lt;span class="ascii"&gt;)&lt;/span&gt;&lt;/a&gt;」をご覧ください）&lt;/small&gt;。&lt;br /&gt;
これがあるために、中間データの値を含めた名前（上記のコードの場合&lt;code&gt;girl&lt;/code&gt;）は、&lt;code&gt;ANN&lt;/code&gt;や&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;で参照するモジュールとは一旦別のモジュールとして定義して、&lt;code&gt;import&lt;/code&gt;して再利用するしかありません。&lt;/p&gt;
&lt;p&gt;本来、「定義を自動でまとめる問題」に対応する目的の中には「モジュールに関わる情報（どのような定義で、どのように使用されるのか）をなるべくモジュールのファイルのみに集約させる」というものがありましたが、外部のファイルに書くボイラープレートが増えてしまい、この観点ではイマイチな実装になってしまいました。&lt;br /&gt;
この点については、後の節でよりよい方法を検討しましょう。&lt;/p&gt;
&lt;h2 id="autoexporterでまとめたい型が書かれているモジュールがどのディレクトリー以下にあるか設定する"&gt;&lt;span class="ascii"&gt;autoexporter&lt;/span&gt;で「まとめたい型」が書かれているモジュールが、どのディレクトリー以下にあるか設定する&lt;/h2&gt;
&lt;p&gt;前節までで紹介した方法により、&lt;code&gt;ANN&lt;/code&gt;プラグマを使うことでプリキュアの情報が書かれたモジュールに、プリキュアの情報を「自動でまとめる」ための「印」を着けることができました。&lt;br /&gt;
続いて、&lt;code&gt;ANN&lt;/code&gt;プラグマで「印」を着けたモジュールがどこにあるかを指定して、&lt;span class="ascii"&gt;GHC&lt;/span&gt;に自動で回収させる方法を述べましょう。 「&lt;a href="#typesafe-precure2_requirement"&gt;解決に必要なもの&lt;/a&gt;」の節で説明した、「対象となる『まとめたい定義（モジュールや関数、型など）』が書かれているファイルが、どのディレクトリー以下にあるか設定する」部分に当たります。&lt;/p&gt;
&lt;p&gt;次の節で説明しますが、&lt;code&gt;ANN&lt;/code&gt;プラグマで付与した情報は、「&lt;a href="https://qiita.com/philopon/items/85210cc8f23ae04ba6ec#template-haskell%E3%81%8B%E3%82%89"&gt;アンッ&lt;span class="ascii"&gt;!!!&lt;/span&gt;アンッ&lt;span class="ascii"&gt;!!!!&lt;/span&gt;」でも説明されている&lt;/a&gt;とおり&lt;code&gt;reifyAnnotations&lt;/code&gt;という&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;の関数を使えば取得することができますが、該当のモジュールを何らかの方法で集めなくてはなりません。&lt;br /&gt;
私が調べた限り、少なくとも&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;を使う限りは、&lt;code&gt;import&lt;/code&gt;しているモジュールから収集する方法しか見つかりませんでした。&lt;br /&gt;
&lt;a href="https://hackage.haskell.org/package/template-haskell-2.12.0.0/docs/Language-Haskell-TH.html"&gt;&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;のライブラリーのドキュメント&lt;/a&gt;では、&lt;code&gt;reifyAnnotations&lt;/code&gt;するのに必要な、&lt;code&gt;Module&lt;/code&gt;型の値を取得する方法として、&lt;code&gt;thisModule&lt;/code&gt;を使って&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;のコードを実行しているモジュールから取得するか、&lt;code&gt;reifyModule&lt;/code&gt;関数を使って&lt;code&gt;thisModule&lt;/code&gt;から&lt;code&gt;thisModule&lt;/code&gt;が&lt;code&gt;import&lt;/code&gt;しているモジュールから取得するしか紹介されていないためです。&lt;/p&gt;
&lt;p&gt;しかし、現状の&lt;span class="ascii"&gt;GHC&lt;/span&gt;では&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;をもってしても、指定したディレクトリー以下のモジュールを自動で&lt;code&gt;import&lt;/code&gt;するということはできません。&lt;br /&gt;
あまりユーザーに自由を与えてしまうと、却って混乱が生じる恐れがあるので敢えて実装していないのでしょう。&lt;br /&gt;
とは言え、だからといって「印」を着けたモジュールを一つずつ手で&lt;code&gt;import&lt;/code&gt;して列挙してしまっては、「定義を自動でまとめる問題」を解決できたとは言えなくなってしまいます。&lt;br /&gt;
そこで、今回は実践でもよく使われる、さらなる「裏技」を用いることにしました。&lt;br /&gt;
本節の見出しでネタバレしてしまっていますが、&lt;a href="https://hackage.haskell.org/package/autoexporter"&gt;&lt;code&gt;autoexporter&lt;/code&gt;&lt;/a&gt;というプログラムと、&lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#ghc-flag--F"&gt;&lt;span class="ascii"&gt;GHC&lt;/span&gt;のカスタムプリプロセッサーのためのオプション&lt;/a&gt;を使います。&lt;/p&gt;
&lt;p&gt;&lt;span class="ascii"&gt;autoexporter&lt;/span&gt;は、ドキュメントに書いてあるとおり、&lt;span class="ascii"&gt;GHC&lt;/span&gt;のカスタムプリプロセッサーのためのオプション&lt;span class="ascii"&gt;(&lt;/span&gt;&lt;code&gt;-F -pgmF&lt;/code&gt;&lt;span class="ascii"&gt;)&lt;/span&gt;、さらには&lt;a href="https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/pragmas.html#options-pragma"&gt;&lt;code&gt;OPTIONS_GHC&lt;/code&gt;プラグマ&lt;/a&gt;組み合わせて、次のように使うことを想定して作られています。&lt;br /&gt;
以下は、&lt;a href="https://github.com/igrep/typesafe-precure/blob/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/src/ACME/PreCure/Textbook.hs"&gt;&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;の&lt;code&gt;ACME/PreCure/Textbook.hs&lt;/code&gt;というファイル&lt;/a&gt;からの抜粋です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# OPTIONS_GHC -F -pgmF autoexporter #-}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;と、いっても&lt;span class="ascii"&gt;1&lt;/span&gt;行だけですが😅&lt;/p&gt;
&lt;p&gt;一つずつ解説しましょう。&lt;br /&gt;
まず&lt;code&gt;OPTIONS_GHC&lt;/code&gt;プラグマですが、文字通りこれは&lt;code&gt;ghc&lt;/code&gt;コマンドに渡すオプションを、ファイル単位で指定するためのものです&lt;small&gt;（もちろんすべてのオプションをファイル単位で指定できるわけではありません）&lt;/small&gt;。&lt;br /&gt;
つまり、上記の場合&lt;code&gt;-F -pgmF autoexporter&lt;/code&gt;というオプションが、&lt;code&gt;ACME/PreCure/Textbook.hs&lt;/code&gt;というファイルでのみ有効になります。&lt;/p&gt;
&lt;p&gt;続いて&lt;code&gt;-F&lt;/code&gt;オプションですが、これは「カスタムプリプロセッサー」という機能を有効にするためのものです。&lt;br /&gt;
これを有効にすると、有効にしたファイルを、続く&lt;code&gt;-pgmF&lt;/code&gt;オプションで指定したプログラムで変換するようになります。&lt;br /&gt;
具体的には、&lt;code&gt;-pgmF&lt;/code&gt;オプションで指定したプログラムに、&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;変換前のファイル名、&lt;/li&gt;
&lt;li&gt;変換前のソースコードを含むファイルの名前&lt;small&gt;（恐らく、一時ディレクトリーにコピーした、変換前のファイル名とは異なる名前と思われます）&lt;/small&gt;、&lt;/li&gt;
&lt;li&gt;変換後のソースコードを書き込むファイル名&lt;small&gt;（これも一時ディレクトリーにあるファイル名なのでしょう）&lt;/small&gt;、&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;という&lt;span class="ascii"&gt;3&lt;/span&gt;つのコマンドライン引数を渡して、&lt;code&gt;-pgmF&lt;/code&gt;オプションで指定したプログラムを実行します。&lt;br /&gt;
&lt;code&gt;-pgmF&lt;/code&gt;で指定したプログラムが、&lt;span class="ascii"&gt;3&lt;/span&gt;つめの引数として渡した名前のファイルに変換後のソースコードを書き込むことで、&lt;code&gt;-F&lt;/code&gt;を有効にしたファイルを、変換後のソースコードでそっくりそのまま差し替えます。&lt;br /&gt;
結果、&lt;code&gt;-pgmF&lt;/code&gt;オプションで指定したプログラムは、自由に任意の&lt;span class="ascii"&gt;Haskell&lt;/span&gt;のソースを生成できるようになります。まさにソースコードの自動生成にぴったりな機能と言えるでしょう。&lt;/p&gt;
&lt;p&gt;ちなみにこの機能、&lt;a href="https://hackage.haskell.org/package/hspec-discover"&gt;&lt;code&gt;hspec-discover&lt;/code&gt;&lt;/a&gt;などのパッケージでも使用されています。テストコードを複数のファイルに分けて書く場合はほぼ必ず使われるものなので、みなさんも「おまじない」として使用したことがあるでしょう&lt;small&gt;（&lt;code&gt;-F -pgmF&lt;/code&gt;なんて文字列、ググラビリティーも低いですしね。）&lt;/small&gt;。&lt;br /&gt;
そういえばこれもテストコードの「定義を自動でまとめる問題」を解決したものでしたね！&lt;/p&gt;
&lt;p&gt;話がそれましたが、&lt;code&gt;autoexporter&lt;/code&gt;はこのカスタムプリプロセッサーを利用することで、次のようなソースコードを自動生成します。&lt;br /&gt;
&lt;code&gt;autoexporter&lt;/code&gt;のドキュメントにも同じことが書かれていますが、ここでも&lt;code&gt;ACME/PreCure/Textbook.hs&lt;/code&gt;を例に説明しましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" data-line-number="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;ACME.PreCure.Textbook&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-2" data-line-number="2"&gt;  ( &lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;ACME.PreCure.Textbook.First&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-3" data-line-number="3"&gt;  , &lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;ACME.PreCure.Textbook.MaxHeart&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-4" data-line-number="4"&gt;  &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-5" data-line-number="5"&gt;  , &lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;ACME.PreCure.Textbook.KirakiraALaMode&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-6" data-line-number="6"&gt;  ) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-8" data-line-number="8"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;ACME.PreCure.Textbook.First&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-9" data-line-number="9"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;ACME.PreCure.Textbook.MaxHeart&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-10" data-line-number="10"&gt;&lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-11" data-line-number="11"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;ACME.PreCure.Textbook.KirakiraALaMode&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;そう、（プリキュアが好きで）賢明な&lt;span class="ascii"&gt;Haskeller&lt;/span&gt;のみなさんならお気づきでしょう。&lt;a href="https://github.com/igrep/typesafe-precure/tree/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/src/ACME/PreCure/Textbook"&gt;&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;の&lt;code&gt;ACME/PreCure/Textbook/&lt;/code&gt;ディレクトリー&lt;/a&gt;に含まれている、（プリキュアの各シリーズを表す）すべてのモジュールを&lt;code&gt;import&lt;/code&gt;して、再エクスポートしているのです！&lt;/p&gt;
&lt;p&gt;つまり、&lt;code&gt;autoexporter&lt;/code&gt;はこのような、「責務を分割するためにモジュールを細かく分けたい、でもユーザーには一つのモジュールを&lt;code&gt;import&lt;/code&gt;しただけで使えるようにしたい」というライブラリー開発者のニーズに応えるため、よく行われているモジュールの書き方を自動で行うための便利コマンドなのです。&lt;/p&gt;
&lt;p&gt;紹介が長くなりましたが、&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;ではこの&lt;code&gt;autoexporter&lt;/code&gt;を次のように使うことで、「まとめたい型（プリキュアや変身アイテムなどの情報）」が書かれているモジュールを集めています。&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;前述の&lt;code&gt;ACME.PreCure.Textbook&lt;/code&gt;モジュールで&lt;code&gt;autoexporter&lt;/code&gt;を使うことで、&lt;code&gt;ACME.PreCure.Textbook&lt;/code&gt;以下にある、「まとめたい型（プリキュアや変身アイテムなどの情報）」が書かれているモジュールをすべて自動的に再エクスポートする。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/igrep/typesafe-precure/blob/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/src/ACME/PreCure/Index.hs"&gt;&lt;code&gt;ACME.PreCure.Index&lt;/code&gt;&lt;/a&gt;モジュールが&lt;code&gt;ACME.PreCure.Textbook&lt;/code&gt;モジュールを&lt;code&gt;import&lt;/code&gt;することで、実際に&lt;code&gt;cure-index.json&lt;/code&gt;などの書き出しを行う&lt;code&gt;ACME.PreCure.Index&lt;/code&gt;モジュールが、&lt;code&gt;ACME.PreCure.Textbook&lt;/code&gt;が再エクスポートしたすべてのモジュールを利用できるようになる。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;実際のところ&lt;code&gt;OPTIONS_GHC -F&lt;/code&gt;をもっとうまく使えば、&lt;code&gt;ACME.PreCure.Textbook&lt;/code&gt;以下にあるモジュールを自動ですべて&lt;code&gt;import&lt;/code&gt;するモジュールと、それを利用して&lt;code&gt;cure-index.json&lt;/code&gt;などの書き出しを行うモジュールを、分けずに一つのモジュールで済ますこともできたでしょう。&lt;br /&gt;
今回は敢えて&lt;code&gt;autoexporter&lt;/code&gt;を再利用することで、&lt;code&gt;ACME.PreCure.Textbook&lt;/code&gt;以下にあるモジュールをすべて回収する処理を書かずに任せることにしました。&lt;br /&gt;
この件については後ほど再検討しましょう。&lt;/p&gt;
&lt;h2 id="annプラグマで付与した定義情報からjsonを書き出す"&gt;&lt;code&gt;ANN&lt;/code&gt;プラグマで付与した定義情報から、&lt;span class="ascii"&gt;JSON&lt;/span&gt;を書き出す&lt;/h2&gt;
&lt;p&gt;いよいよ、&lt;code&gt;autoexporter&lt;/code&gt;を駆使して集めたモジュールから、&lt;code&gt;ANN&lt;/code&gt;で付与したプリキュアの情報を取り出し、&lt;span class="ascii"&gt;JSON&lt;/span&gt;に変換して書き出しましょう。&lt;br /&gt;
詳細は&lt;a href="https://github.com/igrep/typesafe-precure/blob/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/src/ACME/PreCure/Index.hs"&gt;&lt;code&gt;ACME.PreCure.Index&lt;/code&gt;&lt;/a&gt;モジュールや、&lt;a href="https://github.com/igrep/typesafe-precure/blob/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/src/ACME/PreCure/Index/Lib.hs"&gt;&lt;code&gt;ACME.PreCure.Index.Lib&lt;/code&gt;&lt;/a&gt;モジュールのソースコードをご覧いただきたいのですが、ここでは簡単にアルゴリズムを解説します。&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;「現在のモジュール（&lt;code&gt;ACME.PreCure.Index&lt;/code&gt;）」を取得する。&lt;/li&gt;
&lt;li&gt;「現在のモジュール」が&lt;code&gt;import&lt;/code&gt;しているモジュールから、&lt;code&gt;ACME.PreCure.Textbook&lt;/code&gt;モジュールを見つけて、取り出す（&lt;a href="https://github.com/igrep/typesafe-precure/blob/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/src/ACME/PreCure/Index.hs#L38-L39"&gt;具体的には&lt;span class="ascii"&gt;38&lt;/span&gt;行目から&lt;span class="ascii"&gt;39&lt;/span&gt;行目&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;取得した&lt;code&gt;ACME.PreCure.Textbook&lt;/code&gt;モジュールが&lt;code&gt;import&lt;/code&gt;している、プリキュアの情報を集めたモジュール（&lt;code&gt;ANN&lt;/code&gt;プラグマでプリキュアの情報を付与したモジュール）をすべて取り出す（&lt;a href="https://github.com/igrep/typesafe-precure/blob/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/src/ACME/PreCure/Index.hs#L42-L45"&gt;具体的には&lt;span class="ascii"&gt;42&lt;/span&gt;行目から&lt;span class="ascii"&gt;45&lt;/span&gt;行目&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;「プリキュアの情報を集めたモジュール」すべてから、&lt;code&gt;ANN&lt;/code&gt;プラグマで付与されているプリキュアや変身アイテムなどの情報を集めて、種類ごとに一つのリストとしてまとめる（&lt;a href="https://github.com/igrep/typesafe-precure/blob/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/src/ACME/PreCure/Index.hs#L48-L60"&gt;具体的には&lt;span class="ascii"&gt;48&lt;/span&gt;行目から&lt;span class="ascii"&gt;60&lt;/span&gt;行目&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;収集してできた&lt;code&gt;Index&lt;/code&gt;という型の値を、それぞれ&lt;span class="ascii"&gt;JSON&lt;/span&gt;に変換して書き込む（&lt;a href="https://github.com/igrep/typesafe-precure/blob/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/src/ACME/PreCure/Index.hs#L61-L62"&gt;具体的には&lt;span class="ascii"&gt;48&lt;/span&gt;行目から&lt;span class="ascii"&gt;60&lt;/span&gt;行目&lt;/a&gt;）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上記のアルゴリズムにおいても、&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;の「&lt;span class="ascii"&gt;Stage Restriction&lt;/span&gt;」と戦わなければならないということは注記しておきましょう。&lt;br /&gt;
つまり、&lt;code&gt;ACME.PreCure.Index&lt;/code&gt;における&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;のコードで繰り返し使う便利な関数は、&lt;code&gt;ACME.PreCure.Index&lt;/code&gt;とは別のモジュールで定義して、&lt;code&gt;import&lt;/code&gt;して使わなければならないのです。&lt;br /&gt;
&lt;code&gt;ACME.PreCure.Index.Lib&lt;/code&gt;モジュールは、その制限を回避するためのモジュールです。&lt;/p&gt;
&lt;p&gt;ともあれこうして、&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;では&lt;code&gt;ACME.PreCure.Index&lt;/code&gt;モジュールをコンパイルする度に、各モジュールに定義されたすべてのプリキュアに関する情報を集めて、&lt;a href="https://github.com/igrep/typesafe-precure/tree/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/gen"&gt;&lt;span class="ascii"&gt;gen&lt;/span&gt;ディレクトリー&lt;/a&gt;にある&lt;code&gt;cure-index.json&lt;/code&gt;や&lt;code&gt;pretty-cure-index.json&lt;/code&gt;というファイルに書き出すことができました。&lt;br /&gt;
「定義を自動でまとめる問題」、これにて一件落着です！🎉&lt;br /&gt;
なお、自動生成されるファイルを&lt;span class="ascii"&gt;Git&lt;/span&gt;で管理することはなるべく避けた方がよいことですが、&lt;code&gt;cure-index.json&lt;/code&gt;の配布を簡単に行うため方策として用いることにしています。&lt;/p&gt;
&lt;h1 id="うまくいかなかった方法-来年のタイプセーフプリキュアについてちょっとだけ"&gt;うまくいかなかった方法 （&lt;span class="ascii"&gt;+&lt;/span&gt; 来年の「タイプセーフプリキュア！」についてちょっとだけ）&lt;/h1&gt;
&lt;p&gt;&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;における「定義を自動でまとめる問題」の解決方法はここまで述べたとおりですが、今後同じような問題に対応したくなったときのために、最初に思いついたけどうまくいかなかった方法や、後で思いついた別の解決方法をこの先の二つの節ででまとめておきます。&lt;br /&gt;
私や読者のみなさんがお仕事など、より重要なプロジェクトでこれらのアイディアを活かすことができれば幸いです。&lt;/p&gt;
&lt;h2 id="型クラスのインスタンスから"&gt;型クラスのインスタンスから&lt;/h2&gt;
&lt;p&gt;当初（実は今も大部分は）、&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;には、&lt;a href="https://github.com/igrep/typesafe-precure/blob/f6701b3b4a86fda3a9e82a6f0c06a87c4a56362e/src/ACME/PreCure/Textbook/KirakiraALaMode/Profiles.hs"&gt;&lt;code&gt;ACME.PreCure.Textbook.KirakiraALaMode.Profiles&lt;/code&gt;&lt;/a&gt;で定義しているような中間データはなく、各プリキュア（や、変身アイテムなど諸々）に対しては、直接型を宣言したり型クラスのインスタンスを実装したりしていました。&lt;br /&gt;
例えば下記のようなコードです&lt;a href="#fn5" class="footnote-ref" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;👇&lt;/p&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb18-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;CurePeach&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;CurePeach&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-3" data-line-number="3"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;CureStickPeachRod&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;CureStickPeachRod&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-5" data-line-number="5"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Purification&lt;/span&gt; &lt;span class="dt"&gt;CurePeach&lt;/span&gt; &lt;span class="dt"&gt;CureStickPeachRod&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-6" data-line-number="6"&gt;  purificationSpeech _ _ &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-7" data-line-number="7"&gt;    [ &lt;span class="st"&gt;&amp;quot;届け！愛のメロディ！&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-8" data-line-number="8"&gt;    , &lt;span class="st"&gt;&amp;quot;キュアスティック・ピーチロッド！&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-9" data-line-number="9"&gt;    , &lt;span class="st"&gt;&amp;quot;悪いの悪いの飛んでいけ！&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-10" data-line-number="10"&gt;    , &lt;span class="st"&gt;&amp;quot;プリキュア！ラブサンシャイン・フレッシュ！&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-11" data-line-number="11"&gt;    ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;今回作った&lt;code&gt;cure-index.json&lt;/code&gt;を最初に思いついたとき、「型クラスから各型のインスタンス宣言を自動で収集して、そこから&lt;code&gt;cure-index.json&lt;/code&gt;を作れないだろうか」と、漠然と考えていました。&lt;br /&gt;
&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;を作り始める以前、私は&lt;span class="ascii"&gt;Ruby&lt;/span&gt;で「定義を自動でまとめる問題」に対応した際、&lt;a href="#typesafe-precure2_case-ruby"&gt;&lt;span class="ascii"&gt;Ruby&lt;/span&gt;での場合&lt;/a&gt;の節で紹介したような方法を用いていたため、「&lt;span class="ascii"&gt;Haskell&lt;/span&gt;における、&lt;span class="ascii"&gt;Ruby&lt;/span&gt;で言うところの&lt;span class="ascii"&gt;mix-in&lt;/span&gt;されるモジュールは型クラスだ」なんて類推をしていたからかも知れません。&lt;br /&gt;
いずれにしても、そんな方法で実現できれば、既存の&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;のモジュールの構造をそのまま使って&lt;span class="ascii"&gt;cure-index&lt;/span&gt;が作れるので、大変都合がよかったのです。&lt;/p&gt;
&lt;p&gt;しかし、残念ながらその方法は、少なくとも単純に&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;を使うだけでは不可能であるとすぐ気づきました。&lt;br /&gt;
なぜなら、&lt;a href="https://hackage.haskell.org/package/template-haskell-2.12.0.0/docs/Language-Haskell-TH.html#v:reifyInstances"&gt;&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;のライブラリーが提供する&lt;code&gt;reifyInstances&lt;/code&gt;という関数&lt;/a&gt;は、インスタンス宣言を取り出したい型を、自前で持ってきて引数として渡さなければならないからです。&lt;br /&gt;
したがって、&lt;span class="ascii"&gt;Ruby&lt;/span&gt;でやっていたように、型クラスのインスタンスを自動でリストアップする、といったことはできません&lt;small&gt;（もちろん、&lt;span class="ascii"&gt;Ruby&lt;/span&gt;でやった時も完全に自動ではなく、&lt;code&gt;include&lt;/code&gt;したクラスが自分でグローバルなリストに追加していたわけですが）&lt;/small&gt;。&lt;br /&gt;
それならば、自前で&lt;code&gt;import&lt;/code&gt;しているモジュールから定義されている型を収集することはできないだろうか、と思って、指定したモジュールで定義されている型を取り出す&lt;span class="ascii"&gt;API&lt;/span&gt;を探ってみましたが、それも見つかりませんでした。&lt;br /&gt;
最もそれらしいことができそうな&lt;a href="https://hackage.haskell.org/package/template-haskell-2.12.0.0/docs/Language-Haskell-TH.html#v:reifyModule"&gt;&lt;code&gt;reifyModule&lt;/code&gt;という関数&lt;/a&gt;が返す&lt;a href="https://hackage.haskell.org/package/template-haskell-2.12.0.0/docs/Language-Haskell-TH.html#t:ModuleInfo"&gt;&lt;code&gt;ModuleInfo&lt;/code&gt;&lt;/a&gt;も、保持しているのはあくまでも&lt;code&gt;import&lt;/code&gt;している別のモジュールだけであり、いくら&lt;span class="ascii"&gt;reify&lt;/span&gt;してもモジュールの&lt;strong&gt;中で&lt;/strong&gt;定義されている型の情報はとれないのです。&lt;/p&gt;
&lt;p&gt;やむなく、私は&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;の構造を改め、現在のような、&lt;span class="ascii"&gt;JSON&lt;/span&gt;として書き出すデータ構造を元に型と型クラスのインスタンスを自動で定義するような実装にすることとしました。&lt;br /&gt;
この変更は依然として続いています。具体的には、今年新しく追加された「キラキラ☆プリキュアアラモード」に登場するプリキュア以外は、まだ従来の構造のままで、中間データの値は定義されていません。&lt;br /&gt;
「キラキラ☆プリキュアアラモード」に収録されたプリキュアの情報しか、&lt;code&gt;cure-index.json&lt;/code&gt;に記録されていないのはそのためです。&lt;/p&gt;
&lt;p&gt;来年のプリキュアハッカソンやプリキュア&lt;span class="ascii"&gt;Advent Calendar&lt;/span&gt;では、&lt;a href="https://hackage.haskell.org/package/haskell-src-exts"&gt;&lt;span class="ascii"&gt;haskell-src-exts&lt;/span&gt;&lt;/a&gt;という、&lt;span class="ascii"&gt;Haskell&lt;/span&gt;で&lt;span class="ascii"&gt;Haskell&lt;/span&gt;のソースコードをパースするライブラリーを使って、この大きな移行プロジェクトに取り組むことになるかと思います。&lt;br /&gt;
&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;には技術的なネタが尽きませんね。&lt;/p&gt;
&lt;h1 id="ほかにやればよかったかも知れない方法"&gt;ほかにやればよかったかも知れない方法&lt;/h1&gt;
&lt;p&gt;同じことを繰り返しますが、これから紹介する方法も含めて「定義を自動でまとめる」問題の解決は、どんな方法を使うにしても、多かれ少なかれ凝ったメタプログラミングのテクニックを使わなければならなくなります。&lt;br /&gt;
&lt;a href="#typesafe-precure2_warnings"&gt;注意点&lt;/a&gt;の節で強調したとおり、そのコードベースを初めて読んだ人が迷子にならないよう配慮することは忘れないでください。&lt;/p&gt;
&lt;h2 id="モジュールが持っている特定の名前の関数型を処理する"&gt;モジュールが持っている特定の名前の関数・型を処理する&lt;/h2&gt;
&lt;p&gt;その方法は、先の節でも紹介した&lt;a href="https://hackage.haskell.org/package/hspec-discover"&gt;&lt;code&gt;hspec-discover&lt;/code&gt;&lt;/a&gt;でも実際に行われている方法です。&lt;br /&gt;
&lt;code&gt;hspec-discover&lt;/code&gt;は、&lt;span class="ascii"&gt;GHC&lt;/span&gt;のカスタムプリプロセッサーを利用して実行することで、テストが書かれたディレクトリーから&lt;code&gt;Spec&lt;/code&gt;という名前で終わるすべてのテスト用モジュールを自動でまとめて、それらをすべて実行する&lt;code&gt;Spec.hs&lt;/code&gt;を、自動で生成します。&lt;br /&gt;
&lt;code&gt;hspec-discover&lt;/code&gt;の場合、&lt;code&gt;ANN&lt;/code&gt;のようなアノテーションは一切使用せず、モジュールの名前やモジュールがエクスポートする名前に規約を設けることで「定義をまとめる対象」を検出しています。&lt;br /&gt;
このように、&lt;code&gt;ANN&lt;/code&gt;のような特別な「印」を着けずに純粋に名前だけで「定義をまとめる対象」を決めることもできます。&lt;br /&gt;
実績もあり、同じような方法をとることは非常に簡単そうです。&lt;/p&gt;
&lt;p&gt;しかし、個人的には&lt;a href="#typesafe-precure2_warnings"&gt;注意点&lt;/a&gt;の節でも述べたとおり、「定義をまとめる」対象であることを表す「印」は、「定義をまとめる」対象のファイルの中にあった方が、わかりやすくていいと思います。&lt;br /&gt;
確かに&lt;code&gt;hspec-discover&lt;/code&gt;のように、公開されていて広く使用されているものであれば、使用したプロジェクトのコードを初めて読む人でも、すぐに理解できる場合が多いでしょう。「何がまとめられるのか」も比較的直感的ですしね。&lt;br /&gt;
とはいえ、私が想定している、例えばアプリケーションのプラグインみたいな、もう少しローカルなコードベースである場合、「印」はより「印」らしいものであった方が、手がかりとして気づきやすいのではないかと思います。&lt;/p&gt;
&lt;p&gt;😕初めて「まとめられる」コードを含むファイルを目にして、どのように使用されるのか分からず戸惑う&lt;br /&gt;
⬇️&lt;br /&gt;
🤔&lt;code&gt;{-# ANN MarkedAsFoo #-}&lt;/code&gt;という見慣れないコメントを見つけて、それでコードベースを検索してみる&lt;small&gt;（プラグマは多くの&lt;span class="ascii"&gt;syntax highlighter&lt;/span&gt;で普通のコメントより目立って見えるはずです）&lt;/small&gt;&lt;br /&gt;
⬇️&lt;br /&gt;
💡&lt;code&gt;MarkedAsFoo&lt;/code&gt;が着いたモジュールを実際に収集してまとめているコードを見つけて、理解する&lt;/p&gt;
&lt;p&gt;という流れで「定義を自動でまとめる」機構の存在に気づくのではないでしょうか。&lt;/p&gt;
&lt;p&gt;あるいはいっそ&lt;code&gt;ANN&lt;/code&gt;も使わずに、こんな内容の&lt;span class="ascii"&gt;human-readable&lt;/span&gt;なコメントを「印」とするのもよいかも知れません。&lt;br /&gt;
プログラムで検出するのもそう難しくはないでしょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb19-1" data-line-number="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Foo.Commands.SampleCommand&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-3" data-line-number="3"&gt;&lt;span class="co"&gt;-- | このコメントが付いたモジュールの &amp;#39;execute&amp;#39; という関数は、&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-4" data-line-number="4"&gt;&lt;span class="co"&gt;--   Template Haskellによって、自動的に再利用できるよう収集される。&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-5" data-line-number="5"&gt;&lt;span class="co"&gt;--   詳しくは &amp;#39;Foo.Commands` を読まれたし。&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これなら、&lt;code&gt;Foo.Commands&lt;/code&gt;モジュールにヒントがあることが、すぐに分かります。&lt;br /&gt;
&lt;code&gt;hspec-discover&lt;/code&gt;のように、&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;を使わず直接ファイルシステムにあるファイルを開く方法とも、相性がいいはずです。&lt;/p&gt;
&lt;p&gt;ほかにもいろいろな方法を考えましたが、これ以上に有効でもなさそうだし、そろそろ時間もなくなってきたので、この辺でまとめたいと思います。&lt;/p&gt;
&lt;h1 id="まとめ"&gt;まとめ&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;「定義を自動でまとめる」問題を解決することにより、モジュールに関わる情報&lt;small&gt;（どのような定義で、どのように使用されるのか）&lt;/small&gt;をなるべくモジュールのファイルのみに集約させることができる&lt;/li&gt;
&lt;li&gt;「定義を自動でまとめる」問題を解決するには、下記のことをする
&lt;ul&gt;
&lt;li&gt;「まとめたい定義」が書かれているファイルが、どのディレクトリー以下にあるか設定する&lt;/li&gt;
&lt;li&gt;「まとめたい定義」が書かれたファイルに、なんらかの印をつける&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="ascii"&gt;Haskell&lt;/span&gt;で「定義を自動でまとめる」問題を解決する場合、&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;と&lt;span class="ascii"&gt;GHC&lt;/span&gt;の&lt;code&gt;ANN&lt;/code&gt;プラグマや、&lt;span class="ascii"&gt;GHC&lt;/span&gt;のカスタムプリプロセッサー&lt;span class="ascii"&gt;(&lt;/span&gt;&lt;code&gt;-F -pgmF&lt;/code&gt;&lt;span class="ascii"&gt;)&lt;/span&gt;を組み合わせて使うことによって解決できるが、実際には&lt;span class="ascii"&gt;GHC&lt;/span&gt;のカスタムプリプロセッサーのみで十分可能
&lt;ul&gt;
&lt;li&gt;まとめる対象や状況に応じて、柔軟にやり方を考えよう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;どのような方法であれ、「定義を自動でまとめる」問題を解決すると、「『「自動でまとめられるファイル』がどのように使用されるか理解しにくくなる」という別の問題が発生するので、気をつけよう&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それでは&lt;span class="ascii"&gt;2018&lt;/span&gt;年も&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;とプリキュアで&lt;span class="ascii"&gt;Happy Hacking!!&lt;/span&gt; ❤️❤️❤️&lt;/p&gt;
&lt;h1 id="参考にしたページ"&gt;参考にしたページ&lt;/h1&gt;
&lt;p&gt;（記事中で直接リンクを張っていないもののみ）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dev.classmethod.jp/server-side/java/various-spring-configuration/"&gt;第&lt;span class="ascii"&gt;2&lt;/span&gt;回 &lt;span class="ascii"&gt;Spring&lt;/span&gt;の様々な設定記述 – &lt;span class="ascii"&gt;Annotation&lt;/span&gt;も&lt;span class="ascii"&gt;Java&lt;/span&gt;もあるんだよ ｜ &lt;span class="ascii"&gt;Developers.IO&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.ruby-lang.org/ja/2.4.0/method/Module/i/included.html"&gt;&lt;span class="ascii"&gt;instance method Module#included (Ruby 2.4.0)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/pragmas.html#annotation-pragmas"&gt;&lt;span class="ascii"&gt;GHC User&lt;/span&gt;’&lt;span class="ascii"&gt;s Guide&lt;/span&gt;の「&lt;span class="ascii"&gt;7.13. Pragmas&lt;/span&gt;」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;実際には「タイプセーフプリキュアそのものを開発する上で見つかった問題」というよりタイプセーフプリキュアの開発をすることで問題解決の実験をしている、といった方が正しいのは内緒。&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;もう少し正確に言うと、自動的に設定したいフィールド（あるいはコンストラクターの引数）に&lt;code&gt;@Autowired&lt;/code&gt;というアノテーションが必要ですが、今回の話では本質的ではないので割愛しています。&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;もちろん、数年前流行ったあのライトノベルのパロディーではありません。&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;誰にも聞かれてはいませんが勝手にお話ししますと、&lt;code&gt;ACME.PreCure.Textbook&lt;/code&gt;という名前は、&lt;a href="https://dic.pixiv.net/a/%E3%83%97%E3%83%AA%E3%82%AD%E3%83%A5%E3%82%A2%E6%95%99%E7%A7%91%E6%9B%B8"&gt;プリキュアの教科書&lt;/a&gt;から来ています。&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;現在もそうですが、実際には&lt;span class="ascii"&gt;Template Haskell&lt;/span&gt;で定義されているので、&lt;span class="ascii"&gt;typesafe-precure&lt;/span&gt;のリポジトリーにはこれと全く同じコードはありません。&lt;a href="#fnref5" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div id="post-navigation" class="row" style="margin-top: 20px;"&gt;
            &lt;div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4"&gt;
                
                &lt;i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"&gt;&lt;/i&gt;
                &lt;a href="/posts/2017/windows-gotchas.html"&gt;WindowsでHaskellを扱う時によく遭遇するエラーと対処法&lt;/a&gt;
                
            &lt;/div&gt;
            &lt;div class="col-lg-2 col-md-2 col-xs-4 text-center"&gt;
                &lt;a href="/"&gt;トップに戻る&lt;/a&gt;
            &lt;/div&gt;
            &lt;div class="col-lg-3 col-md-4 col-xs-4"&gt;
                
                &lt;a href="/posts/2017/no-stack-build.html" style="margin-left: auto;"&gt;Haskell-jp Blogへの投稿が簡単になりました！&lt;/a&gt;
                &lt;i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"&gt;&lt;/i&gt;
                
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/article&gt;

</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/12/19/203500</id><title type="text">HaskellのABC(Haskell Advent Calendar 6th)</title><updated>2017-12-19T20:35:00+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/12/19/203500"/><summary type="html">Haskellといえば一文字変数名、一文字変数名といえばHaskellという{{要出典}}ほどにHaskellでは一文字の変数名がよく使われている。これは名前を考えるのをサボっているとは限らない。多相性によって変数が具体的な性質を持たないがゆえに、具体的な名前がつけられないというのが主な理由だ。あるいは、適切な名前があっても、既存の名前と被っているという場合もある。かといって完全なランダムというわけでもないので、一文字変数名はどのように選べばいいか考察していこう。 a よくある種: * アルファベットの最初であるaは汎用性が高い。型変数に使うのが王道だ。値レベルの変数として単体で使うことは意外…</summary></entry><entry><id>http://ilyaletre.hatenablog.com/entry/2017/12/17/212053</id><title type="text">Left Recursionの悪夢再び</title><updated>2017-12-17T21:20:53+09:00</updated><author><name>ilyaletre</name></author><link href="http://ilyaletre.hatenablog.com/entry/2017/12/17/212053"/><summary type="html">はじめに Happyで生成したパーサのコンパイル遅すぎてもう限界だったのでparser combinatorに戻ってきた。 そしてまた現れたのだ、やつが。。。。 問題 やろうとしてることは以前と変わらない。 SML Definitionを読んで型の注釈を表す式 ty を解析しようとしているが、 左無限再帰が起きてしまって解析が終了しないというもの。 ty ::= tyvar (1) type variable such as 'a { tyrow i } (2) record type tyseq longtycon (3) type constructor with type argumen…</summary></entry><entry><id>http://ilyaletre.hatenablog.com/entry/2017/12/10/195016</id><title type="text">GHCの中間言語Coreへの脱糖を覗き見る</title><updated>2017-12-11T00:07:41+09:00</updated><author><name>ilyaletre</name></author><link href="http://ilyaletre.hatenablog.com/entry/2017/12/10/195016"/><summary type="html">Haskell (その3) Advent Calendar 2017 11日目の記事。(予約投稿知らなかったのでフライングになった) GHCがコンパイルの途中で中間表現として用いるCoreの生成っぷりを観察する。 観察して、あーはいはいなるほどね(わかってない)、と言うだけになりそう。 はじめに GHCはHaskellのソースコードを低レベルなコードへとコンパイルする過程で様々なpass(コンパイルのステージ)を通じてプログラムデータを変換する。 俯瞰図は下記のリンクに詳しい。 Compiling one module: HscMain 僕がGHCの話をどこかで聞きかじってかっこいいな、と思っ…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2016/07/02/174426</id><title type="text">Haskellの最近の例外ハンドリング</title><updated>2017-12-06T17:19:02+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2016/07/02/174426"/><summary type="html">どうもHaskellには標準のControl.Exceptionモジュールだけでなくmtlやexceptionsやexceptionalといった例外を扱うためのパッケージがあるらしいのだが、そのあたりのパッケージの選び方や使い方についてまとまった情報を見つけられなかった。 HaskellWiki例外のページも少々古いようで、deprecatedなものや統合される前のパッケージを書いていたりする。 調べた限り、mtlとexceptionsが今の主流っぽい。 その2つの使い方をまとめる。 なおバージョンはlts-6.1を基準としている。 mtl mtlパッケージのControl.Monad.Exc…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2016/08/28/175500</id><title type="text">続・Haskellの最近の例外ハンドリング</title><updated>2017-12-06T17:18:53+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2016/08/28/175500"/><summary type="html">前回 の記事ではHaskellの例外ハンドリングには exceptions パッケージを使えばいいのではないかと書いた。 ところが今年の6月に safe-exceptions という exceptions を拡張したようなパッケージがさる FPComplete から 発表 された。 そこでこの記事では safe-exceptions について調べてみる。 おそらくほぼ FPComplete の発表の受け売りになってしまうので英語を読める人は原文を読む方がいいかもしれない。 さすが FPComplete だけあってこれは既に LTS Haskell に入っている。 この記事では lts-6.14…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/haskell-library-2016</id><title type="text">Haskellライブラリ所感2016</title><updated>2017-12-06T17:18:40+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/haskell-library-2016"/><summary type="html">(これは Haskell Advent Calendar 2016 の7日目の記事です) 今年使ったり調べたりした Haskell ライブラリを広く紹介していく企画です。 あくまで今年使ったものなので新しいものばかりではないです。 また記事の性質上、紹介するものが偏っていてもご容赦ください。 Hackage にはすごい数のライブラリが登録されていて、 頼もしいことですが目が回りそうにもなってしまいます。 この記事が Haskell のライブラリを調べる上での指針になったら幸いです。 なおこの企画と方向性が似ているものとして State of the Haskell ecosystem ( 20…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2017/04/26/005415</id><title type="text">超技術書典でGHCJSの本を出します</title><updated>2017-12-06T17:18:31+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2017/04/26/005415"/><summary type="html">【告知】ニコニコ超会議2017と併催される超技術書典Day1(4/29)にて、GHCJSの入門的な本を出します。@y_taka_23 さんのスペースに委託する形になります。Haskell×JavaScriptに興味のある方はぜひA-04まで。 #技術書典 #超技術書典 pic.twitter.com/zUhiVc3CyX — しょしー 超技術書典A-04 (@syocy) 2017年4月25日 出します。 GHCJSの仕組みの話はほとんどなくて、あくまで使い方とか周辺事情の話になります。 GHCJSって昔は導入すること自体が難しくて、他のHaskell系AltJSに水をあけられている感があった…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2017/05/20/025021</id><title type="text">Haskellは真面目なアプリケーション開発に向いている</title><updated>2017-12-06T17:18:19+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2017/05/20/025021"/><summary type="html">qiita.com ↑の記事で（主題ではないと思うものの）Haskellの批判に結構な分量が割かれていて、その批判のなかに「ちょっと違うんじゃないかな」という点がいくつかあったので反論ぽいことを書きます。 "Haskell は真面目なアプリケーション開発には向いてない"について これには多分いくつか事例を挙げればよくて、 Facebook ではスパム等の攻撃と戦うためのシステムを Haskell で作っています。 Fighting spam with Haskell | Engineering Blog | Facebook Code | Facebook (この記事を書いている Simon …</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2017/08/14/235830</id><title type="text">HaskellとJSON、そしてレコード型</title><updated>2017-12-06T17:18:07+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2017/08/14/235830"/><summary type="html">HaskellのJSON周りについて、こうやるのがいいんじゃないかという私の現在のやり方を書きます。 題材としては、 Swagger Petstore に記されている REST API にリクエストを投げてレスポンスを取り出すというのをやります。 (Swagger ですが scaffold は使わず自分で HTTP クライアントライブラリを使います)。 基本方針は「出力は厳密に入力には寛容に」(出典失念) です。 もくじ JSONの前に: レコードのフィールドへのアクセス JSONの前に: レコードのデフォルト値 Haskellのデータ型→JSON JSONデータを含むHTTPリクエスト レス…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2017/08/27/003035</id><title type="text">GoのTickerみたいなやつをHaskellで作った</title><updated>2017-12-06T17:17:55+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2017/08/27/003035"/><summary type="html">github.com 作った。 GoのTickerはとてもシンプルな関数で、 指定した周期でチャネルに値を送るスレッドを生成する。 一定間隔で何かの処理を行いたいときに利用する。 今回作ったHaskell版もだいたい同じようなものを提供する。 実際のところパッケージにするには小さすぎる気もするけど、 Haskellパッケージ製作の練習をしたかったのでHackageのアカウントを取ってHackageに上げた。 練習のため、HaddockによるAPIドキュメントおよびhspecとdoctestによるテストも書いてある。 あとは何かCIを導入してGithubのページにCIのステータスを表示するような…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/a-tour-of-go-in-haskell</id><title type="text">A Tour of Go in Haskellを作ったのと、GoとHaskellの比較</title><updated>2017-12-06T17:17:38+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/a-tour-of-go-in-haskell"/><summary type="html">A Tour of Go in Haskell (日本語版/英語版) というサイトを作ったので、それの紹介をします。 https://a-tour-of-go-in-haskell.syocy.net/ja_JP/index.html Haskell は Go と同じく軽量スレッドやチャネルの機能があり、並行並列が得意な言語です。このサイトは A Tour of Go という Go のチュートリアルの並行性の章を題材として２つの言語を比較しています。</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/12/04/044908</id><title type="text">NGK2017B で Liquid Haskell について話してきました</title><updated>2017-12-04T04:49:08+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/12/04/044908"/><summary type="html">先日、毎年恒例のなごや LT 大会 NGK2017B / 名古屋合同懇親会 2017 忘年会 で発表してきました。 Liquid Haskell で普通の型システムの上を行け #NGK2017B from y_taka_23 www.slideshare.net 当日の動画は NGK2017B 第2部 - YouTube から見ることができます。 ちなみに NGK での発表は 5 年連続 5 回目です。前回まではモデル検査をテーマにしていましたが、今回はちょっと目先を変えて（とはいえ同じ形式手法の枠内ですが）もう少しプログラム寄りの題材として Liquid Haskell を選びました。 N…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/11/27/070558</id><title type="text">現在時刻をモックする Haskell ライブラリ time-machine を作ってみました</title><updated>2017-11-27T07:05:58+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/11/27/070558"/><summary type="html">主としてテスト時のために、現在時刻を操作する Haskell ライブラリを作成しました。Hackage にも登録済みです。 github.com 試しに次のコードを実行してみましょう。getCurrentTime しているはずなのに、返ってくる値が 1985 年 10 月 26 日になっているはずです。 module Main where import Control.Monad.TimeMachine import Control.Monad.Trans ( liftIO ) main :: IO () main = backTo (the future) $ do t &lt;- getCurr…</summary></entry><entry><id>https://haskell.jp/blog/posts/2017/no-stack-build.html</id><title type="text">Haskell-jp Blogへの投稿が簡単になりました！</title><updated>2017-11-27T00:00:00Z</updated><author><name>Haskell-jp</name></author><link href="https://haskell.jp/blog/posts/2017/no-stack-build.html"/><summary type="html">&lt;article&gt;
    &lt;div class="container"&gt;
        &lt;div class="row"&gt;
            &lt;div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10"&gt;
                &lt;ul class="social-buttons"&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a href="https://twitter.com/share" class="twitter-share-button"&gt;Tweet&lt;/a&gt;
                        &lt;script&gt;!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;script type="text/javascript"&gt;
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        &lt;/script&gt;
                        &lt;script type="text/javascript" src="//www.redditstatic.com/button/button1.js"&gt;&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;div&gt;
                        &lt;a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"&gt;&lt;/a&gt;
                        &lt;script type="text/javascript"&gt;!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");&lt;/script&gt;
                    &lt;/div&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
            &lt;div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"&gt;
              &lt;hr /&gt;
&lt;p&gt;こんにちは。&lt;span class="ascii"&gt;Haskell-jp&lt;/span&gt;です。&lt;br /&gt;
ちょっと間が空いてしまいましたが、久々の投稿です。&lt;span class="ascii"&gt;Haskell&lt;/span&gt;自体の話と関係なくてすみません！&lt;/p&gt;
&lt;p&gt;内容としてはタイトルのとおりなのですが、&lt;a href="https://github.com/haskell-jp/blog/pull/51"&gt;こちら&lt;/a&gt;や&lt;a href="https://github.com/haskell-jp/blog/pull/53"&gt;こちら&lt;/a&gt;をはじめとする&lt;span class="ascii"&gt;Pull request&lt;/span&gt;により、当ブログの記事の投稿が簡単になりました！&lt;br /&gt;
具体的には、下記の点を改善しております。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;記事を作成して&lt;span class="ascii"&gt;Pull request&lt;/span&gt;を送った際、&lt;span class="ascii"&gt;[Merge pull request]&lt;/span&gt;ボタンを押して&lt;span class="ascii"&gt;master&lt;/span&gt;ブランチにマージしただけで自動で記事が公開されるようになりました！&lt;/li&gt;
&lt;li&gt;&lt;a href="https://circleci.com/docs/1.0/build-artifacts/"&gt;&lt;span class="ascii"&gt;CircleCI&lt;/span&gt;の&lt;span class="ascii"&gt;artifacts&lt;/span&gt;機能&lt;/a&gt;を利用することにより、ビルド結果から実際に公開される際のページをプレビューできるようにしました！
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;span class="ascii"&gt;https://XX-XXXXXXXX-gh.circle-artifacts.com/0/home/ubuntu/blog/generated-site&lt;/span&gt;&lt;/em&gt; みたいな&lt;span class="ascii"&gt;URL&lt;/span&gt;で見られるようになります（具体的なページはビルド結果ごとに異なるので、適宜ご案内します）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;結果、これまで&lt;span class="ascii"&gt;Haskell-jp Blog&lt;/span&gt;に投稿する際に問題となっていた、下記の点が解消されました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;投稿する人が自分で&lt;code&gt;make&lt;/code&gt;などを実行しなければ、&lt;span class="ascii"&gt;markdown&lt;/span&gt;で書いた記事がどのような&lt;span class="ascii"&gt;HTML&lt;/span&gt;に変換されるかわからなかった。&lt;/li&gt;
&lt;li&gt;権限を持った人が&lt;code&gt;make deploy&lt;/code&gt;するまで、記事を&lt;span class="ascii"&gt;master&lt;/span&gt;ブランチにマージしても公開されなかった。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上を踏まえた、&lt;span class="ascii"&gt;Haskell-jp Blog&lt;/span&gt;の投稿手順については、&lt;a href="https://github.com/haskell-jp/blog#readme"&gt;&lt;span class="ascii"&gt;README&lt;/span&gt;&lt;/a&gt;をご覧ください。&lt;br /&gt;
基本的に投稿する人は、&lt;strong&gt;&lt;span class="ascii"&gt;Markdown&lt;/span&gt;で記事を書いて、&lt;span class="ascii"&gt;Pull request&lt;/span&gt;を送るだけ&lt;/strong&gt;です！&lt;/p&gt;
&lt;p&gt;それでは、これからも&lt;span class="ascii"&gt;Haskell-jp Blog&lt;/span&gt;をよろしくお願いします！ &lt;span class="ascii"&gt;hask(_ _)eller  &lt;/span&gt; なお、現在&lt;span class="ascii"&gt;Haskell-jp Blog&lt;/span&gt;では、&lt;a href="https://qiita.com/advent-calendar/2017/haskell"&gt;&lt;span class="ascii"&gt;Haskell Advent Calendar 2017&lt;/span&gt;&lt;/a&gt;（と&lt;a href="https://qiita.com/advent-calendar/2017/haskell2"&gt;その&lt;span class="ascii"&gt;2&lt;/span&gt;&lt;/a&gt;、&lt;a href="https://qiita.com/advent-calendar/2017/haskell3"&gt;その&lt;span class="ascii"&gt;3&lt;/span&gt;&lt;/a&gt;）の記事を特に精力的に募集しています。 &lt;span class="ascii"&gt; &lt;/span&gt; ぜひこの機会に&lt;span class="ascii"&gt;Haskell-jp Blog&lt;/span&gt;に記事を投稿してみませんか？&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div id="post-navigation" class="row" style="margin-top: 20px;"&gt;
            &lt;div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4"&gt;
                
                &lt;i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"&gt;&lt;/i&gt;
                &lt;a href="/posts/2017/typesafe-precure2.html"&gt;タイプセーフプリキュア！を支える技術 その2&lt;/a&gt;
                
            &lt;/div&gt;
            &lt;div class="col-lg-2 col-md-2 col-xs-4 text-center"&gt;
                &lt;a href="/"&gt;トップに戻る&lt;/a&gt;
            &lt;/div&gt;
            &lt;div class="col-lg-3 col-md-4 col-xs-4"&gt;
                
                &lt;a href="/posts/2017/13-about-kind-system-part2.html" style="margin-left: auto;"&gt;Haskellの種(kind)について (Part 2)&lt;/a&gt;
                &lt;i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"&gt;&lt;/i&gt;
                
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/article&gt;

</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/10/25/033444</id><title type="text">技術書典 3 で新刊落としました</title><updated>2017-10-25T03:34:44+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/10/25/033444"/><summary type="html">先日、秋葉原で開催された技術系同人誌のオンリーイベント 技術書典 3 にサークル参加しました。 本当は新刊として Scala 用の静的解析ツール Stainless の入門書を頒布する予定で、サークルカットも完全にその線で準備していたのですが、残念ながら諸事情につき完成しませんでした。 事前にサークルチェックしてくださっていた 36 名の方々には大変申し訳ありませんでした。チェシャ猫先生の次回作にご期待ください。 何も並べるものがないのはちょっとどうかと思ったので、当日は 前回の技術書典 2 で頒布 した既刊『入門 LiquidHaskell』の PDF 版（ダウンロードカード）を持ち込みまし…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/10/18/202148</id><title type="text">Serverless Meetup Tokyo #6 で Kubernetes について話してきました</title><updated>2017-10-21T02:14:23+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/10/18/202148"/><summary type="html">先日行われた Serverless Meetup Tokyo #6 で、Kubernetes 上で動作する Serverless フレームワーク Fission について発表してきました。 Fission で 始める Containerless Kubernetes #serverlesstokyo from y_taka_23 www.slideshare.net 先週も 似たようなブログ を書いたような気がしなくもないですが、Kubeless と Fission を比較した前回の発表に対し、今回は話題を Fission に限定しています。一方で追加要素として、複数の Function を組…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/10/17/172322</id><title type="text">ステートマシン猛レース</title><updated>2017-10-19T18:19:14+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/10/17/172322"/><summary type="html">ストリーム処理ライブラリはHaskellにおいて競争の激しい分野の一つだ。ストリーム処理ライブラリとは大雑把に言うと、IOなどの作用を絡めながら値の列(ストリーム)を生成したり、処理したりする構造を提供するライブラリである。多くのライブラリは、以下の3種の構造を定義している。 生産者(プロデューサー): IOなどのアクションを伴いつつ値を生成する。 消費者(コンシューマー): 多くの場合モナド変換子になっており、await :: Consumer s m sのようなアクションを組み合わせ、値の列を処理するプログラムを書ける。 変換者(トランスデューサー): 入力を受け取りながら、出力もできる。…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/10/14/092409</id><title type="text">Kubernetes Meetup Tokyo #7 で Serverless について話してきました</title><updated>2017-10-14T09:24:09+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/10/14/092409"/><summary type="html">先日行われた Kubernetes Meetup Tokyo #7 で、Kubernetes 上で動作する Serverless フレームワークについて発表してきました。 Kubernetes でも Serverless したい！ #k8sjp from y_taka_23 www.slideshare.net Serverless on Kubernetes を謳うツールはいくつかありますが、今回はそのうち Kubeless と Fission に焦点を当て、それぞれのアーキテクチャの違いを比較してみました。 当日の補足 Twitter 上で反応をもらった点についていくつか補足します。 Fu…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/10/11/230117</id><title type="text">WindowsでのHaskell開発環境構築(2017年秋版)</title><updated>2017-10-13T23:20:39+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/10/11/230117"/><summary type="html">身の丈に合わないと形容されても仕方ないようなハイスペックなPCを買った。開発環境は当然作り直すことになるので、その軌跡を残しておく。 MSYS2 まずはMSYS2を入れる。これでツールチェーンが揃い、minttyというターミナルエミュレータもついてくる。 $ pacman -Syuu $ pacman -Sy git stack Haskellのビルドツールであるstackのインストーラを入手する。処理系から依存パッケージまで無難かつ自動的に用意してくれるので便利だ。 Home - The Haskell Tool Stack ただしstackはMSYS2上ではうまく動作しない。設定ファイル(…</summary></entry><entry><id>http://lotz84.github.io/posts/an-introduction-to-haskell-for-engineers.html</id><title type="text">エンジニアのための『Haskell入門』</title><updated>2017-10-03T00:00:00Z</updated><author><name>lotz</name></author><link href="http://lotz84.github.io/posts/an-introduction-to-haskell-for-engineers.html"/><summary type="html"></summary></entry><entry><id>http://ilyaletre.hatenablog.com/entry/2017/09/30/193043</id><title type="text">SMLの関数適用を構文解析する時の問題</title><updated>2017-10-01T09:33:16+09:00</updated><author><name>ilyaletre</name></author><link href="http://ilyaletre.hatenablog.com/entry/2017/09/30/193043"/><summary type="html">まだ構文解析器で苦労している。 今回も詰まっているのは構文のconflict。 問題 これが関数適用 app : exp exp これが二項演算子適用 infixapp : exp vid exp この時に入力を x y z とすると２つの解釈ができてしまうことになる。 ((x y) z) とするネストした関数適用なのか x y z とする二項演算子の適用なのかParserが判断つけられない。 前者ならreduceするが後者ならshiftする。 なのでこれはshift/reduce conflictが起きていると言える。 happyはデフォルトでshiftするので二項演算子として解釈される。 …</summary></entry><entry><id>http://ilyaletre.hatenablog.com/entry/2017/09/24/234126</id><title type="text">好きなプログラミング言語の好きなところについて思った</title><updated>2017-09-24T23:45:25+09:00</updated><author><name>ilyaletre</name></author><link href="http://ilyaletre.hatenablog.com/entry/2017/09/24/234126"/><summary type="html">改めて最近実感すること。 Haskell, Elm, Clojureほんと好き。 Scala勉強しなきゃなーと思いながらClojureを触ってしまうことが多かったのだけれど、 その理由が少しずつわかってきた。 いい言語たち いままで少しだけ触れてきたJava, Python, Scala, Goはいずれもとても大きなユーザを抱えている。 どの言語もたくさんのユーザを得るために現場で使えるようなエコシステムをどんどん投下してあっという間に大きなユーザベースを獲得した。 プログラミングのしやすさを大事にして、誰でもすんなり入門できるように設計されている。 僕が入門できるくらいだから本当に敷居が低く…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/09/14/150435</id><title type="text">Haskell ライブラリにスターを送るツール thank-you-stars を作ってみました</title><updated>2017-09-14T15:04:35+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/09/14/150435"/><summary type="html">Haskell の GitHub レポジトリを眺めてみると、有名ライブラリであってもスター数が意外と少ないことがあります。かの Yesod ですら本記事執筆時点で 1,794 個であり、Rails の 36,933 個や Django の 28,165 個と比較すると文字通り桁違いです。 スター数は必ずしも OSS としての評価や価値を反映しませんし、そもそも Haskell ユーザの絶対数が少ないからと言ってしまえばそれまでなのですが、若干寂しい感じがしません？ 一方、先日 id:teppeis さんが 依存しているライブラリにスターを送る npm ツール を公開されていました。そこで真似し…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/08/06/154901</id><title type="text">FRPクライシス</title><updated>2017-08-06T18:18:29+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/08/06/154901"/><summary type="html">FRP(Functional Reactive Programming)は、リアクティブプログラミングと関数型プログラミングの性質を持つプログラミングパラダイムである。FRPは古典的FRPと矢矧のFRPに大別される。 古典的FRP 古典的(Classical)FRPは、非連続的な値の列Eventと、常に何らかの値を取るBehaviourの二種類の構造を導入したものである。 代表的な実装としてreactive-banana、euphoria、reflexなどが挙げられる。 Haskellにおいては、EventはIOを通じて非同期的に生成できる設計が多い。Eventはマップやフィルタリングができ、…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/08/02/230422</id><title type="text">快速のExtensible effects</title><updated>2017-08-03T08:52:52+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/08/02/230422"/><summary type="html">extensibleは拡張可能レコードだけでなく拡張可能作用(extensible effects)も用意している。拡張可能作用は一時期Haskell界隈で話題になったものの、今では人気も下火になってしまった。新しいバージョンをリリースした今、拡張可能作用の動機と使い方について改めて紹介しよう。 難行の一次関数 Haskellでモナドをカスタマイズする方法としては、transformersのモナド変換子がよく使われている。モナド変換子は、モナドをパラメータとして取り、新たな能力を付与したモナドにする構造だ。例えば、StateT sはモナド変換子の一つである。任意のアクションm aはliftを使…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/01/30/%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%E3%80%8F%E6%AD%A3%E8%AA%A4%E8%A1%A8</id><title type="text">『遠回りして学ぶ Yesod 入門』正誤表</title><updated>2017-07-25T03:40:10+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/01/30/%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%E3%80%8F%E6%AD%A3%E8%AA%A4%E8%A1%A8"/><summary type="html">kakkun61.booth.pm C91 版 電子版では修正済みです。 ページ 章節 誤 正 補足 3 はじめに Yesod の初歩的な解説が書かれた本の上巻です。 Yesod の初歩的な解説が書かれた本の上巻です。 7 1 リンク切れの検出や リンク切れの検出や 17 3.2 これは quasi quote（準引用）と呼ばれる これは quasi quotes（準引用）と呼ばれる 表記の統一 20 4.1 メモリーに文字のデータが メモリーに文字列のデータが 23 5.1 GHC Users Guidehttp://wiki.haskell.org/GHC GHC Users Guide …</summary></entry><entry><id>http://ilyaletre.hatenablog.com/entry/2017/07/03/163749</id><title type="text">左再帰を含む構文解析むずい</title><updated>2017-07-03T18:04:24+09:00</updated><author><name>ilyaletre</name></author><link href="http://ilyaletre.hatenablog.com/entry/2017/07/03/163749"/><summary type="html">やろうとしていること Haskellのparsecを使ってSMLの構文を解析し構文木を生成する。 やっていること SMLの構文解析はいろいろステップがある。 リテラル (special constants) 識別子 (identifier) 型注釈 !!イマココ!! パターンマッチ 式 宣言 モジュール構文 リテラルや識別子はなんとか倒して、いま型注釈の解析に取り組んでいるところ。 苦戦しているところ この型注釈の構文解析で例の問題に突き当たった。 左再帰問題だ。 SMLの型注釈の構文はこんな感じ。 ty ::= tyvar { &lt;tyrow&gt; } tyseq longtycon ty -&gt; …</summary></entry><entry><id>http://ilyaletre.hatenablog.com/entry/2017/05/20/174125</id><title type="text">Haskellの代数データ型をJava的なインタフェースと捉える</title><updated>2017-06-03T09:42:59+09:00</updated><author><name>ilyaletre</name></author><link href="http://ilyaletre.hatenablog.com/entry/2017/05/20/174125"/><summary type="html">Haskellの代数データ型は僕にとってJavaのインタフェースに近い。 データ型がインタフェースでそのデータを受け取る関数がインタフェースのメソッドに相当する。 データをパターンマッチで分解して値コンストラクタ別の関数定義をするのは、 インタフェースに対する実装を与えているものだと考えている。 data Maybe a mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b Maybe aというデータ型があるとする。これがインターフェース。 mapMaybeという関数があるとする。これがメソッド。 インタフェースに実装を与えていく。 まずはデータ構造としてのイン…</summary></entry><entry><id>http://ilyaletre.hatenablog.com/entry/2017/05/21/162855</id><title type="text">Haskellerの好きなところ</title><updated>2017-05-21T16:35:21+09:00</updated><author><name>ilyaletre</name></author><link href="http://ilyaletre.hatenablog.com/entry/2017/05/21/162855"/><summary type="html">僕はHaskellが好き。 なんだけど、同じくらいHaskellもくもく会の常連の人達が好き。 ちょっとした型についての質問から、いつの間にかホワイトボード上で証明とか書き出して「あー、ほんとだー、そういうことかー」って言ってる感じが好き。 解らないことがあったら自分で検証するっていう、問題に対する誠実で真っ直ぐな態度を持っている人達が好き。 Haskellではそういう解らないところを形式的に検証する方法や知識がよく整備されていると思う。(とても難しいものもあるけど) きっと他のコミュニティにもそういう人はたくさんいる。でもHaskellもくもく会にはそういう人達が間違いなくいるのを僕は知って…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/05/21/150903</id><title type="text">JJUG CCC 2017 Spring で Haskell on JVM について話してきました</title><updated>2017-05-21T15:14:00+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/05/21/150903"/><summary type="html">先日行われた JJUG CCC 2017 Spring で、JVM 上で動作する Haskell について発表してきました。 思ったほど怖くない！ Haskell on JVM 超入門 #jjug_ccc #ccc_l8 from y_taka_23 www.slideshare.net メインになるコンテンツはふたつの JVM 言語、Frege と Eta です。 今回はあくまでも Java のイベントなので、発表前半では Haskell の基本概念、特にモナドについてそれなりの時間を割いて説明してみました。さらにそれを踏まえて後半ではモナドを利用した Java ライブラリの呼び出しに焦点を…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/05/17/%E9%96%A2%E4%BF%82%E3%81%A8%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E3%81%A8%E3%81%AE%E7%9B%B8%E4%BA%92%E5%A4%89%E6%8F%9B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E5%A6%84</id><title type="text">関係と代数的データ型との相互変換についての妄想 その2</title><updated>2017-05-17T15:13:55+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/05/17/%E9%96%A2%E4%BF%82%E3%81%A8%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E3%81%A8%E3%81%AE%E7%9B%B8%E4%BA%92%E5%A4%89%E6%8F%9B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E5%A6%84"/><summary type="html">思い付き その1 型レベルのリストをクエリー函数に与えてやる。（DataKinds が有効） data Attr = Id | Name | Friends data User = User { id :: Int, name :: String, friends :: [User] } query :: Proxy '[??] -&gt; Key -&gt; MonadDB User userFriends :: Proxy '[Friends] -&gt; User -&gt; [User] リストだとダメだなーって気付いた。勝手に型の和が取られるわけじゃないからね。 それはそれとして、分からないところが2点。 …</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/05/16/%E9%96%A2%E4%BF%82%E3%81%A8%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E3%81%A8%E3%81%AE%E7%9B%B8%E4%BA%92%E5%A4%89%E6%8F%9B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E5%A6%84</id><title type="text">関係と代数的データ型との相互変換についての妄想 その1</title><updated>2017-05-16T10:53:24+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/05/16/%E9%96%A2%E4%BF%82%E3%81%A8%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E3%81%A8%E3%81%AE%E7%9B%B8%E4%BA%92%E5%A4%89%E6%8F%9B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E5%A6%84"/><summary type="html">OR マッパーみたいな、関係*1とデータ型との相互変換が機械的にできたら嬉しいなという話。 シンプルなのは簡単だしすでにできる。例えば次のような関係がある場合*2、 var user base relation { id integer, name string, } key { id }; var friends base relation { user1 integer, user2 integer }; これを単に次のようなデータ型に変換するのはいくらかのライブラリーで実現できる。 data User = User { id: Int, name: String } data Frien…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/05/06/060400</id><title type="text">超技術書典で同人誌『入門 LiquidHaskell』を頒布できませんでした</title><updated>2017-05-06T06:04:00+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/05/06/060400"/><summary type="html">先日、ニコニコ超会議内で行われた「超技術書典」にて、LiquidHaskell の同人誌でサークル参加してきました。 lh101.dodgsonlabs.com 技術書典 2 ではそこそこの部数が出た ので Haskell 同人誌の需要はゼロではないと踏んでいたのですが、びっくりするぐらい売れません でした。とりあえず後に続く人が同じ轍を踏まないように、今回の様子について記録しておきます。 頒布物 頒布した同人誌は以下の 2 種類です。前者は技術書典 2 で頒布したものの増刷、後者は id:kazeula さんから委託を受けた新刊です。 入門 LiquidHaskell −篩型による静的コード…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/02/28/Yesod_%E3%81%A8_HDBC-mysql_%E3%81%A8_haskell-relational-record_%E3%81%A7_%E2%80%9CCommands_out_of_sync%E2%80%9D</id><title type="text">Yesod と HDBC-mysql と haskell-relational-record で “Commands out of sync”</title><updated>2017-04-27T10:05:11+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/02/28/Yesod_%E3%81%A8_HDBC-mysql_%E3%81%A8_haskell-relational-record_%E3%81%A7_%E2%80%9CCommands_out_of_sync%E2%80%9D"/><summary type="html">Yesod と HDBC-mysql と haskell-relational-record を一緒に使っているのだが、MySQL サーバーに「Commands out of sync; you can’t run this command now」って言われてぐぬぬってなって、最近デバッグをがんばっている。とりあえず途中経過をメモしておく。 そもそも MySQL プロトコルの呼び出し順とか知らないので苦戦していた。 この辺でエラーが出ている。結合をしなければエラーは出ない。 import Import hiding (on) import Database.Relational.Query …</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2017/04/11/044041</id><title type="text">技術書典 2 で同人誌『入門 LiquidHaskell』を頒布しました</title><updated>2017-04-11T04:40:41+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2017/04/11/044041"/><summary type="html">先日、秋葉原で行われた技術書のオンリーイベント「技術書典 2」にて、LiquidHaskell の同人誌を頒布してきました。 lh101.dodgsonlabs.com LiquidHaskell は、SMT ソルバをバックエンドとして利用することで、Haskell の持つ型の表現力をより強化する仕組みです。通常の Haskell では型情報としてエンコードできない値レベルの制約を記述できるため、例えば「0 でない Int 型」を定義すればゼロ除算をコンパイル時に検知できます。以前の記事 にちょっとした解説があります。 当日は冊子版を 30 冊と PDF 版ダウンロードカードを 50 シリアル…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/03/30/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B82%E3%81%AB%E3%82%B5%E3%83%BC%E3%82%AF%E3%83%AB%E5%8F%82%E5%8A%A0%E3%81%97%E3%81%BE%E3%81%99</id><title type="text">技術書典2にサークル参加します 「Haskell Yesod 本」</title><updated>2017-04-06T19:35:40+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/03/30/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B82%E3%81%AB%E3%82%B5%E3%83%BC%E3%82%AF%E3%83%AB%E5%8F%82%E5%8A%A0%E3%81%97%E3%81%BE%E3%81%99"/><summary type="html">4月9日日曜日にアキバ・スクエアにて開催される技術書オンリー同人誌即売会「技術書典2」にサークル「趣味はデバッグ……」として参加します。 冬コミで頒布した『遠回りして学ぶ Yesod 入門』の誤字脱字等を修正して組版を改善したものを持っていきます。 新作はちょっと間に合うか…… 内容 内容は、下記となります。 ビルドツール Stack 効率のよい文字列の扱い Haskell の言語拡張 コンパイル時計算 Template Haskell Web Application Interface とは 簡単な Yesod の解説 ロガー用 Middleware を作る 詳しい内容は見本誌で確認ください…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2016/12/24/%E3%82%B3%E3%83%9F%E3%83%83%E3%82%AF%E3%83%9E%E3%83%BC%E3%82%B1%E3%83%83%E3%83%8891_%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%E3%80%8F</id><title type="text">コミックマーケット91 『遠回りして学ぶ Yesod 入門』</title><updated>2017-03-30T10:45:09+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2016/12/24/%E3%82%B3%E3%83%9F%E3%83%83%E3%82%AF%E3%83%9E%E3%83%BC%E3%82%B1%E3%83%83%E3%83%8891_%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%E3%80%8F"/><summary type="html">サークル「趣味はデバッグ……」の2冊目の頒布をコミックマーケット91にて行います！ 『遠回りして学ぶ Yesod 入門』 前回、技術書典で頒布した『遠回りして学ぶ Yesod 入門（上）』の増補改訂版という形になります。 対象読者 対象読者は前回通り、下記ような方になります。 Haskell の入門書は読み終わったよ Yesod のサンプルコード見たら知らない文法とかあって読めないよ 内容 内容は、下記となります。 ビルドツール Stack 効率のよい文字列の扱い Haskell の言語拡張 コンパイル時計算 Template Haskell Web Application Interface…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2017/03/28/Yesod_%E3%81%A71%E3%83%9A%E3%83%BC%E3%82%B8%E3%81%AB%E8%A4%87%E6%95%B0%E5%80%8B%E3%83%95%E3%82%A9%E3%83%BC%E3%83%A0%E3%81%8C%E3%81%82%E3%82%8B%E5%A0%B4%E5%90%88%E3%81%AF_identifyForm_%E3%82%92%E4%BD%BF</id><title type="text">Yesod で1ページに複数個フォームがある場合は identifyForm を使う</title><updated>2017-03-28T10:49:23+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2017/03/28/Yesod_%E3%81%A71%E3%83%9A%E3%83%BC%E3%82%B8%E3%81%AB%E8%A4%87%E6%95%B0%E5%80%8B%E3%83%95%E3%82%A9%E3%83%BC%E3%83%A0%E3%81%8C%E3%81%82%E3%82%8B%E5%A0%B4%E5%90%88%E3%81%AF_identifyForm_%E3%82%92%E4%BD%BF"/><summary type="html">resolver lts-5.4 で確認。 問題 1ページに複数個フォームがある場合、runFormPost はそれぞれのフォームの区別をしてくれません。どういうことかというと、例えば下記のような2つのフォームを利用するとします。 data AFormData = AFormData Text aForm :: Html -&gt; MForm Handler (FormResult AFormData, Widget) aForm = renderDivs $ AFormData &lt;$&gt; areq textField "A Text" Nothing data BFormData = BFormD…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2017/03/11/232319</id><title type="text">generateの罠</title><updated>2017-03-11T23:24:28+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2017/03/11/232319"/><summary type="html">vectorパッケージのData.Vectorにはgenerateという関数がある。 generate :: Int -&gt; (Int -&gt; a) -&gt; Vector a 型から全てを知ることはできないが、だいたい想像通りgenerate n fは[f 0, f 1, f 2, ...f (n - 1)]からなるVectorを生成する。しかし、これは要素を評価はしない。生成されるのはあくまでサンクのVectorだ。 Prelude &gt; import Data.Vector as V Prelude V&gt; V.length $ V.generate 5 (const undefined) 5 ve…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2016/06/27/%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%EF%BC%88%E4%B8%8A%EF%BC%89%E3%80%8F%E3%81%AE%E9%9B%BB%E5%AD%90%E7%89%88%EF%BC%88PDF%EF%BC%89%E3%81%AE</id><title type="text">『遠回りして学ぶ Yesod 入門（上）』の電子版（PDF）のインターネット販売を開始しました</title><updated>2016-12-27T23:42:20+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2016/06/27/%E3%80%8E%E9%81%A0%E5%9B%9E%E3%82%8A%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6_Yesod_%E5%85%A5%E9%96%80%EF%BC%88%E4%B8%8A%EF%BC%89%E3%80%8F%E3%81%AE%E9%9B%BB%E5%AD%90%E7%89%88%EF%BC%88PDF%EF%BC%89%E3%81%AE"/><summary type="html">BOOTH にて『遠回りして学ぶ Yesod 入門（上）』の電子版（PDF）のインターネット販売を開始しました！ 1000円となります。 kakkun61.booth.pm 結構さっくり開設できてびっくりしてる。 店舗候補 どこでダウンロード販売すべきなんかなと思ってちょっと調べたんでまとめときます。 候補としては、メロンブックス・BOOTH・DLsite がありました。それぞれの店舗での販売価格に対する受取価格はざっくり次の通りでした。 店舗 受取価格 メロンブックス*1 販売価格 × 0.7 -（振込手数料） BOOTH*2 販売価格 × 0.966 - 10 -（振込手数料 300 or…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/12/24/193038</id><title type="text">LiquidHaskell コトハジメ</title><updated>2016-12-25T15:06:06+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/12/24/193038"/><summary type="html">このエントリは Haskell Advent Calendar 2016 および Formal Method Advent Calendar 2016 の 23 日目の投稿です。のはずでしたがすでに日付が変わりました。謹んでお詫び申し上げます。 ちなみに 22 日目の担当者はそれぞれ Haskell Advent Calendar 2016 : heredocsの紹介 - Qiita Formal Method Advent Calendar 2016 : 農夫 山羊 キャベツ 狼 - Qiita です。偶然ですが同じ方が執筆担当ですね。 さて、本エントリでは Haskell の型の表現力をよ…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/12/19/060147</id><title type="text">NGK2016B で Kubernetes + Alloy について話してきました</title><updated>2016-12-19T06:01:47+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/12/19/060147"/><summary type="html">先日、毎年恒例のなごや LT 大会 NGK2016B / 名古屋合同懇親会 2016 忘年会 で発表してきました。 机上の Kubernetes - 形式手法で見るコンテナオーケストレーション #NGK2016B from y_taka_23 www.slideshare.net 当日の動画は NGK 2016B LT #2 - YouTube から見ることができます。 ちなみに NGK での発表は 4 年連続 4 回目です。今回も含めてすべてモデル検査が題材になっています。 NGK2013B : Alloy ではじめる簡単モデル検査 NGK2014B : 猫でもわかる！ モデル検査器 SPI…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2016/12/18/181540</id><title type="text">波打たせるものの正体(エクステンシブル・タングル)</title><updated>2016-12-18T18:15:40+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2016/12/18/181540"/><summary type="html">Haskell Advent Calendar 11日目 リアルワールドなHaskellerは、幾十ものフィールドを持つ大きなレコードをしばしば扱う羽目になる。モナディックにレコードを構築したい場合、RecordWildCards拡張を用いて以下のようにするのが定番だ。 import System.Random data Rec = Rec { foo :: String, bar :: Int, baz :: Double, qux :: Bool } makeRec = do foo &lt;- getLine bar &lt;- length &lt;$&gt; getLine baz &lt;- readLn qu…</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/12/haskellyesod-typedcontent.html</id><title type="text">[haskell][yesod] TypedContentを利用してクライアントが要求するフォーマットでレスポンスを返す</title><updated>2016-12-17T15:16:26.835+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/12/haskellyesod-typedcontent.html"/><summary type="text">Yesod Advent Calendar 2016の6日目の記事です。

RESTfulなAPIを提供する場合、クライアントの都合にあわせて、フォーマットを変えてレスポンスを返したいケースがあります。サーバー上で管理しているDBから、表現だけをHTML, JSON, XML, CSVなどに変更して返すイメージです。例えば、人物情報（名前、年齢、性別など）の一覧を返す際には以下のようなデータが返されることになります。

HTML
&lt;table border&gt;
  &lt;tr&gt;
    &lt;th&gt;name&lt;/th&gt;    &lt;th&gt;sex&lt;/th&gt;    &lt;th&gt;age&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Taro Yamada&lt;/td&gt;    &lt;td&gt;Male&lt;/td&gt;    &lt;td&gt;18&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Hanako Yamada&lt;/</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/07/yesodhaskell-stack-new-xxx-project.html</id><title type="text">[haskell][yesod] stackのnewコマンドで指定できるyesod関連templateの説明</title><updated>2016-12-03T23:37:28.283+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/07/yesodhaskell-stack-new-xxx-project.html"/><summary type="text">現状、stackで指定できるyesod関連のtemplatesには以下のものがあります。どのtemplateに何が用意されているのか、知りたかったのですがどこにも説明されていないようなので、調べてまとめてみました。
% stack templates | grep yesod
yesod-hello-world （←現時点では削除されています）
yesod-minimal
yesod-mongo
yesod-mysql
yesod-postgres
yesod-postgres-fay
yesod-simple
yesod-sqlite


以下、各テンプレートの説明です。後に出てくるテンプレートほど内容が複雑になっています。テンプレートを指定して新しいプロジェクトを生成する場合は以下のコマンドを実行します。
% stack new プロジェクト名 yesod-???




</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/11/emacs-emacsgrep.html</id><title type="text">[emacs] emacs上のgrep関連機能、複数ファイルの一括置換手順のまとめ</title><updated>2016-11-30T10:03:25.873+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/11/emacs-emacsgrep.html"/><summary type="text">emacs上でgrep関連の機能を利用する際のTIPSをまとめておきます（よく忘れて調べ直すので…）。


grepコマンドのオプション

指定ディレクトリ以下のファイルを再帰的に検索

-R DIR    シンボリックリンクを辿る
-r  DIR    シンボリックリンクは辿らない

検索対象をファイル名でフィルタする

--include=GLOB    GLOBにファイル名を指定する。"*.cpp"のようにワイルドカード（*,?,[...]）を指定可能

検索対象から指定ファイル・ディレクトリを除外する

--exclude=GLOB   GLOBに除外するファイルのファイル名を指定する（ワイルドカード指定可能）。
--exclude-dir=DIR DIRに指定されたディレクトリをスキップ


使用例：

docディレクトリ以下の.txtを拡張子に持つ全てのファイルを対象に"</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/09/cygwin-cygwin64.html</id><title type="text">[cygwin] cygwin64セットアップメモ</title><updated>2016-11-28T00:47:36.358+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/09/cygwin-cygwin64.html"/><summary type="text">自分向け備忘録。cygwin64環境をセットアップする際の手順をまとめておきます。


設定


ssh-agent関連

ssh-agentの重複起動を防ぐ
ssh-agentのために秘密鍵セットアップ

~/.ssh/

※group/otherのrw権限は削除


ssh-agentがパスワードを覚えてくれなくなった問題への対処

pingのエラー回避
ユーザーのアカウント名、ホームディレクトリの変更

/etc/passwdを編集する

GNU screen でlessやvimの終了後に画面クリアをしない方法
改行コードにCR+LFが用いられているbashスクリプトを実行するための設定
tcshのデフォルト補完設定のイマイチな部分を修正




環境変数

HOME

ホームディレクトリを設定



SHELL

"/bin/tcsh"とすることでデフォルトのシェルが切り替わる
</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/11/20/163839</id><title type="text">Frege のチュートリアル集「Frege Goodness」を翻訳しました</title><updated>2016-11-20T16:38:39+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/11/20/163839"/><summary type="html">Frege のチュートリアル集を日本語に翻訳しました。原著は Dierk Koenig 氏による Frege Goodness · GitBook です。 www.gitbook.com 対象読者 まえがきでも述べられている通り、Frege の (すなわち Haskell の) 基本的な文法については既知のものとして扱われます。より具体的には「すごい Haskell」の前半部分を読んだ、ぐらいでしょうか。例えば型クラス自体は知っている必要がありますが、モナドに対する理解は要求しません。 ちなみに、目を通していただけるとすぐにわかりますが、実は Frege に特有な内容はさほど登場しません。どち…</summary></entry><entry><id>http://syocy.hatenablog.com/entry/2016/10/31/025512</id><title type="text">HaskellのロガーKatipを試す</title><updated>2016-10-31T02:55:12+09:00</updated><author><name>syocy</name></author><link href="http://syocy.hatenablog.com/entry/2016/10/31/025512"/><summary type="html">モチベ Haskell の実行時ログ出力を行うライブラリは monad-logger が一番有名っぽい。 これは Yesod 陣営が開発しているから安心感があるし、バックエンドが fast-logger なので速度も信頼できる。 ただ (自分の調べ方が悪いのかもしれないが) ちょっと自分の用途には機能が足りなかった。 具体的には以下の機能: ログにタイムスタンプを付記したい。 ロガーに名前をつけたい。 ファイルサイズか日付でログローテーションしたい。 Katip という別のロガーライブラリは機能が豊富のようなので今回はそれを試してみる。 (この記事のHaskell環境: lts-6.23) K…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/10/30/155758</id><title type="text">Frege からメールが送信できるようになりました</title><updated>2016-10-30T17:31:40+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/10/30/155758"/><summary type="html">ちょっとした Web アプリを作成しようと思うと、メール送信機能がないと困ります。例えば、ログイン機能を持っていれば必然的にパスワードリセットとかも必要になりますからね。 Haskell 風の JVM 言語 Frege でもフレームワーク Chinook を使用して Web アプリが作れますが、メールを送信するライブラリが見当たらなかったので自作しました。 github.com なお、すでに Bintray に公開済みなので、各種ビルドツール経由で呼び出すことができます。現状、Frege のビルドは Gradle がデファクトスタンダードなので、以下でも Gradle で説明しましょう。 bi…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/10/23/201420</id><title type="text">JAWS FESTA 東海道 2016 で形式手法によるネットワーク設計について話してきました</title><updated>2016-10-23T20:14:20+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/10/23/201420"/><summary type="html">先日行われた JAWS FESTA 東海道 2016 で登壇してきました。 形式手法と AWS のおいしい関係。- モデル検査器 Alloy によるインフラ設計技法 #jawsfesta from y_taka_23 www.slideshare.net テーマは以前 AWS Summit で発表したものと同じですが、前回が 5 分の LT だったのに比べて今回は 25 分の枠を頂きました。そこで、形式手法を用いる動機を中心に据えた前回と比較して、以下のような実践的なトピックを充実させてあります。 Alloy を使うためにの最低限必要な言語機能を知る シンプルな Web サーバ周りのネットワー…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2016/10/10/000011</id><title type="text">割とすぐに始められるextensibleチュートリアル(レコード編)</title><updated>2016-10-10T00:50:06+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2016/10/10/000011"/><summary type="html">ごきげんよう諸君。今回はextensibleについて説明しよう。 extensibleはその名の通り、拡張可能なデータ構造を提供するライブラリである。具体的には、型レベルのリストによって特徴づけられる積と和を提供する。非常に残念なことに、GHC 8.0.1ではコンパイラのバグのせいでそもそもライブラリがビルドできない*1。来たる8.0.2では修正されているので、それを待つほかない。 とにかく、ここでは積の応用技である拡張可能レコードについて紹介する。使い方は簡単だ。まず使いたいフィールド名をスペースで区切ってmkFieldに渡す。 {-# LANGUAGE TemplateHaskell, D…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2016/06/13/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8%E3%81%AB%E3%81%A6%E4%BA%BA%E7%94%9F%E5%88%9D%E3%81%AE%E5%90%8C%E4%BA%BA%E8%AA%8C%E3%82%92%E9%A0%92%E5%B8%83%E3%81%97%E3%81%BE%E3%81%99%EF%BC%81</id><title type="text">技術書典にて人生初の同人誌を頒布します！</title><updated>2016-09-30T12:11:59+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2016/06/13/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8%E3%81%AB%E3%81%A6%E4%BA%BA%E7%94%9F%E5%88%9D%E3%81%AE%E5%90%8C%E4%BA%BA%E8%AA%8C%E3%82%92%E9%A0%92%E5%B8%83%E3%81%97%E3%81%BE%E3%81%99%EF%BC%81"/><summary type="html">技術書典にて人生初の同人誌を頒布します！うおぉぉ！！ドコドコドコ！プワプワー！ 『遠回りして学ぶ Yesod 入門（上）』 内容は、入門書程度の内容の Haskell を理解した人がウェブアプリケーションフレームワーク Yesod を使うときに手助けになるような内容です。具体的には次の通り。 ビルドツール Stack 効率のよい文字列の扱い Web Application Interface とは Scotty を使ったウェブアプリ ただ書いてたら最後まで間に合わない気がしてきたので今回は「上巻」ってことで逃げました！これから下巻書かなきゃ。 ペンタブレットを買って表紙も自分で書きました！絵が…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2016/06/26/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8_%E3%81%B5%E3%82%8A%E3%81%8B%E3%81%88%E3%82%8A</id><title type="text">技術書典 ふりかえり</title><updated>2016-09-11T19:14:03+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2016/06/26/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8_%E3%81%B5%E3%82%8A%E3%81%8B%E3%81%88%E3%82%8A"/><summary type="html">技術書典お疲れさまでしたー。 閉場30分前まで整理券制で、だいたいの方が1時間半待ちだったそうですね。びっくりするような盛況で何よりです。運営さんの手際もよく大変ありがとうございました。 #技術書典 会場のキャパに余裕が出てきたため、只今から整理券なしでも入場可能にします！残り三十分強ですがお楽しみいただければと思います。— TechBooster@3日目西a05a (@TechBooster) June 25, 2016 最終的に1200人は超えたそうですね。 #技術書典 最終集計できてないですが速報(すぐ数えられるもので)来場数は1200名を超えました！至らないところもありましたがサークル…</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/08/haskellyesod-yesodrestfuljson-api.html</id><title type="text">[haskell][yesod] YesodにおけるRESTfulなJSON API実装チュートリアル</title><updated>2016-08-28T17:53:43.356+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/08/haskellyesod-yesodrestfuljson-api.html"/><summary type="text">HaskellのwebフレームワークであるYesodにおいて、RESTful APIを実装する手順を紹介します。Haskell上のデータ構造をJSONテキストに変換する、逆に、JSONテキストをパースしてHaskell上のデータ構造を生成する、といった処理が非常に簡単に実現できます。加えて、コードを書かなくてもバックエンドのDBとのORマッピングが可能になっており、効率的に開発することができます。
ここで紹介しているコードはgithubにコミットしています。


準備：

json-sampleというプロジェクト名でYesodのscaffolding siteをセットアップする

空のプロジェクト生成

% stack new json-sample yesod-sqlite --system-ghc

"--system-ghc"は省略可能。インストール済みのghcを使うことを指示し</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/07/haskellyesod-stackyesod-tutorial.html</id><title type="text">[haskell][yesod] stack対応版Yesod tutorial</title><updated>2016-07-17T18:06:36.108+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/07/haskellyesod-stackyesod-tutorial.html"/><summary type="text">HaskellのwebサービスフレームワークにYesodというフレームワークがあります。Yesodに触れたことのない開発者向けに書かれたチュートリアルの一つにYesod tutorialがあり、手順に沿っていくだけで簡単なwebサービスを動作させることができ、Yesodで何ができるかを簡単に理解できるようになっています。
ただ残念なことに、このYesod tutorialの記載は内容が古く、stackを利用した現行の手順とマッチしなくなっています。stackに対応している最新環境（Yesod 1.4.x）における順があると役に立つと思い、書き起こしてみました。


Before the real start（はじめに）

Install（インストール手順）
stackをインストールする。以下のサイトが参考になります。

installation instructions for </summary></entry><entry><id>https://kurokawh.blogspot.com/2016/07/haskellyesod-stack-exec-yesod-devel.html</id><title type="text">[haskell][yesod] stack exec -- yesod devel で devel.hs: getAddrInfo: does not existというエラーになる問題の対処方法</title><updated>2016-07-17T17:39:43.279+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/07/haskellyesod-stack-exec-yesod-devel.html"/><summary type="text">
Widnwos環境での現象：
windows上でyesodのscafolding siteをセットアップし、さあ起動！ブラウザから接続確認してOKとなるはずが、なぜか「The application isn't built」という表示が出てしまいました。



このときターミナルには以下のようなログが出力されていました。
% stack exec -- yesod devel
Yesod devel server. Type 'quit' to quit
Application can be accessed at:

http://localhost:3000
https://localhost:3443
If you wish to test https capabilities, you should set the following variable:
  export </summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2016/05/03/211430</id><title type="text">写真の撮り方</title><updated>2016-06-14T23:59:05+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2016/05/03/211430"/><summary type="html">物体の発する光や反射した光を結像し、何らかの媒体に記録したものを写真と呼ぶ。カメラと呼ばれる道具には「撮影」という動作が必ず定義されており、撮影によって内部状態に画像を記録できる。内部状態を取り出して処理する(現像)ことで写真が得られる。大抵のカメラには以下のようなパラメータがあり、それらを最適化するのが撮影者の仕事になる。 焦点(Focus) はっきりとした像を得るには、光学系の焦点をそれに合わせる必要がある。最近のカメラは対象物の距離を測定し、自動で焦点を合わせる(オートフォーカス)機能を持っているものもある。 焦点距離(Focal length) 焦点距離が長いほど像は拡大されて見えるよ…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/06/06/051120</id><title type="text">AWS Summit Tokyo 2016 で形式手法について話してきました</title><updated>2016-06-06T05:11:20+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/06/06/051120"/><summary type="html">先日行われた AWS Summit Tokyo 2016 で、形式手法のインフラ設計への応用について発表してきました。 形式手法で捗る！インフラ構成の設計と検証 from y_taka_23 www.slideshare.net モデル検査器 Alloy を利用して AWS の設定を検査する、という内容の LT で、昨年 12 月の NGK2015B でも同じテーマについて話しています。よければ以下の記事も合わせてお読みください。 ccvanishing.hateblo.jp NGK2015B の発表ではサンプルコードの紹介に比較的時間を割いているのに対して、今回の発表では「動機」の部分により…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/04/17/201842</id><title type="text">NL 名古屋で Frege の評価戦略について話してきました</title><updated>2016-04-17T20:18:42+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/04/17/201842"/><summary type="html">先日の 歌舞伎座.tech に引き続き、NL名古屋 - connpass で Haskell 風 JVM 言語 Frege について発表してきました。 今回の発表では、Frege の持つ Haskell 的特徴である非正格評価に焦点を当て、正格評価を行うはずの Java 上でなぜ評価を遅延させられるのか、その内幕を解説しています。 Frege, What a Non-strict Language from y_taka_23 www.slideshare.net なお当日の様子は NL名古屋 -NLとはなんだったのか- #nlnagoya - Togetterまとめ にまとめられています。長…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2016/04/08/215045</id><title type="text">今のところ比較的簡単なモナドの作り方</title><updated>2016-04-08T21:51:50+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2016/04/08/215045"/><summary type="html">準備 モナドを作るには、どんなモナドを作りたいか考える。モナドは一般に、どのようなアクションが使えるかによって特徴付けられる。その点ではオブジェクト指向におけるインターフェイスとよく似ている。 では、foo :: String -&gt; M Boolとbar :: M Intという二種類のアクションを持つモナドを作るとしよう。まず、どんなアクションが使えるかを表すデータ型を定義する。 {-# LANGUAGE GADTs #-} data MBase x where Foo :: String -&gt; MBase Bool Bar :: MBase Int GADT(一般化代数的データ型)の各データ…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/03/22/020302</id><title type="text">歌舞伎座.tech #9 で Frege について話してきました</title><updated>2016-03-22T02:03:02+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/03/22/020302"/><summary type="html">先日行われた 歌舞伎座.tech#9「異種プログラミング言語格闘勉強会」 - connpass で Haskell 風 JVM 言語である Frege について発表してきました。 今回の勉強会のテーマは「様々な言語に触れて視野を広げる」ということだったので、細かな言語仕様にはあえて触れていません。Frege 自体の紹介と、あとは JVM 言語として一番キャッチーな機能である Java 呼び出しについて解説しました。 すごい Frege たのしく学ぼう！ from y_taka_23 www.slideshare.net 勉強会自体も、マイナ言語の話を一度にこれだけ聞けるというのは珍しくなかなか…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2016/02/29/191740</id><title type="text">GHC 8.0.1/base-4.9.0.0の新機能まとめ</title><updated>2016-02-29T19:17:40+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2016/02/29/191740"/><summary type="html">GHC 8.0.1は、最上位の桁が変わるだけあって、かなり新しい機能が追加されている。 base-4.9.0.0 めっちゃインスタンスが増えた ghc/changelog.md at ghc-8.0 · ghc/ghc · GitHubを参照。あるべきインスタンスが存在することにより、孤児インスタンスを定義する必要がなくなるため、ぐっとストレスが減る。Monoid a =&gt; Monad ((,) a)、Traversable ZipListなど、いくつかは私がやった。 Semigroup ついにData.Semigroupが追加された。将来的にはこれはモノイドのスーパークラスになる。この変更に…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2016/02/13/175220</id><title type="text">すごい JVM 言語 Frege をたのしく学ぼう！</title><updated>2016-02-13T17:52:20+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2016/02/13/175220"/><summary type="html">言わずと知れた Haskell の定番教科書『すごい Haskell たのしく学ぼう！』に登場するサンプルコードを、プログラミング言語 Frege に翻訳してみました。 github.com Frege について Frege は、JVM 上で動く純粋関数型プログラミング言語です。 github.com 最近、JVM 用 Lisp である Clojure の存在感を増してきている気がしますが、Frege はいわばその Haskell 版ですね。 文法的には Haskell + Java のメソッドを呼び出すための追加構文、といった感じ。細かな違いはありますが、Haskell が読める人間であれば…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/04/haskell-cmdargs.html</id><title type="text">[haskell] cmdargsパッケージで楽々コマンドライン引数パース</title><updated>2016-02-11T01:10:46.307+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/04/haskell-cmdargs.html"/><summary type="text">コマンドラインツール実装時、オプション指定とか引数の並びとか考え始めると大変です。HaskellではSystem.EnvironmentモジュールからgetArgsという関数が提供されていますが、本エントリで紹介するcmdargsパッケージを利用すると以下のようなことが簡単にできます。

cmdargsパッケージの特徴：

データ構造を定義するだけで起動引数・オプションのパースができる
パース結果を型付きで参照することができる
パース失敗時には、原因がわかるエラーメッセージが表示される
--help, --versionオプションで表示される情報を自動で生成してくれる

Haskell版GNU getoptライブラリと比べて以下の2点が優れている、とHPには書かれています。

HLintコマンドラインのハンドリングが1/3の短さ
Cabal, darcsなどのmultiple mode</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2016/02/04/214714</id><title type="text">比を最適化する</title><updated>2016-02-04T21:47:14+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2016/02/04/214714"/><summary type="html">二つの負でない実数、を考える。比をある値に近づけたいといった条件が複数あり、それらを最適化したいとき、どうするのがよいだろうか。 序: 近道の階段 簡単な方法の一つとして考えられるのは、単純に比の差をとり、それらの平方の和を最適化の対象とするというものだ。 しかし、これは最適化の結果、しばしば、のどちらかが0にぶつかってしまう。これは目的関数として非常にいびつであり、直感的とも言いがたい。 破: バリアフリー化 0や1に近い比率は極端であり、望まれていない。境界に近づくほど目的関数が無限大に発散するようにできないだろうか。 そんなときに使えるのがロジットだ。ロジットは0より大きい1未満の実数を…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/11/haskellyesodsqlite-persistent.html</id><title type="text">[haskell][persistent][sqlite] Persistentパッケージ利用時にテーブルにインデックスを生成する方法</title><updated>2016-01-30T17:12:12.076+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/11/haskellyesodsqlite-persistent.html"/><summary type="text">PersistentパッケージにはMigration機能が備わっており、自動的にテーブルを生成してくれます。スキーマ変更を行った際にも、変換が可能な限りテーブル内のレコードを保持したまま新しいスキーマに変換してくれます（Migration機能については過去のエントリでまとめています）。

自分が利用する上で、インデックスやトリガーを生成する手順が紹介されておらず困っていたのですが、rawExecuteという関数を用いることで自由にDDLを発行できることがわかりました。以下その手順とサンプルを紹介しておきます。


サンプルコード：
以下は、personテーブルのnameカラムにインデックスをs生成するサンプルです。runMigration実行直後に、runExecuteを実行することでインデックスを生成しています。このサンプルではインデックスを生成しているだけですが、同じ手順でトリガーの</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/08/haskellyesodsqlite-persistentmigration.html</id><title type="text">[haskell][persistent][sqlite] Persistentパッケージのmigration機能のまとめ</title><updated>2016-01-30T17:11:40.032+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/08/haskellyesodsqlite-persistentmigration.html"/><summary type="text">HaskellでDB操作ができるPersistentパッケージの紹介をしましたが、このエントリではPersistentパッケージが提供しているmigration機能をまとめておきます。
DBを作って運用していると、機能追加や仕様変更に伴いスキーマ変更が必要になるケースが多々あります。このようなケースにおいてPersistentのmigration機能がどれくらい使えるのかを調べた結果です。


基本：
Persistetのmigration機構は（保守的なルールに沿って）スキーマ変更をある程度まで自動で処理してくれます。
ロードしたDB内のテーブル情報と、コードで定義されたEntity Definition（テーブル定義）を比較し、以下のケースにおいてスキーマの変更を行います。

カラムの型を変更した場合：

ただし、値の変換ができない場合には、DBによって拒否されることになります。

</summary></entry><entry><id>https://kurokawh.blogspot.com/2016/01/haskellgccwin-windowshaskell.html</id><title type="text">[haskell][gcc][win] Windows版Haskell Platform付属のgccでC++11のコードをコンパイルする方法</title><updated>2016-01-15T00:45:37.692+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2016/01/haskellgccwin-windowshaskell.html"/><summary type="text">Windows版のHaskell Platformにはmingwが同梱されておりgccが含まれています。現在自分のPCにはHaskell Platform 2014.2.0.0をインストールしているのですが、これに付属されているgccでC++11のコードをコンパイルしようとすると、以下のようなエラーになってしまいました。
% gcc -std=c++11 cpp11.cpp
cc1plus.exe: error: unrecognized command line option '-std=c++11'


-stdオプションで"c++11"を指定しても、認識してくれません。
本家のサイトによると、'-std=c++11'オプションはgcc 4.7でサポートされたようです。これに対し、Haskell Platform 2014.2.0.0に付属されているgccのバージョンを確認したところ</summary></entry><entry><id>https://kurokawh.blogspot.com/2013/11/sqlite-sqlite.html</id><title type="text">[sqlite] SQLiteのロック・トランザクション関連仕様の整理</title><updated>2016-01-06T12:11:40.986+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2013/11/sqlite-sqlite.html"/><summary type="text">SQLiteは共有ロック・排他ロックの仕組みを備えており、プロセス内の複数スレッド、だけでなく、プロセスをまたぐ状態でSQLが同時に発行されても適切に処理されます。
トランザクションに複数のモードが存在し、指定するモードに依って取得されるロックが変わります。さらにSQLの内容に依存してロック状態が遷移するため、複数プロセスがアクセスしたときの挙動を正確に把握できるよう、仕様を整理してみました。
（文中の「プロセス」は、正確には「プロセス、もしくはスレッド」を意味します。）


DBのロック状態の種類：

UNLOCKED

ロックされていない状態。誰も読み書きしていない。DBの初期状態。

SHARED

read可、write不可な状態。複数プロセスが同時にSHAREDロックを取得可能。複数プロセスが同時にreadできることを意味する。DBがこの状態にあるとき、他のプロセスからの</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/12/30/220159</id><title type="text">デシリアライザとスキーマ</title><updated>2015-12-30T22:16:49+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/12/30/220159"/><summary type="html">盛大に遅れました… qiita.com 最近思いついたネタで実用性の高そうなものを紹介。 binaryやcerealのようなライブラリはデータを密にシリアライズするが、その際にフィールド名や型などの情報は失われてしまう。かといってそれらを一つ一つすべて含めるとひどく効率の悪いフォーマットになってしまう。そこで、スキーマを分離できるような仕組みを作れないかと考えて作ったのがこのクラスだ。 {-# LANGUAGE TypeFamilies, ScopedTypeVariables, FlexibleContexts, UndecidableInstances #-} import Data.Bi…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/07/cygwinhaskellemacs-mingwcygwincygdrivec.html</id><title type="text">[cygwin][haskell][emacs] MinGWでcygwinの"/cygdrive"パスにアクセスする裏技（cygwin環境のemacsでflycheckを動作させる方法）</title><updated>2015-12-27T23:55:24.842+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/07/cygwinhaskellemacs-mingwcygwincygdrivec.html"/><summary type="text">haskell関連のコマンドはMinGW上でビルドされているため、cygwin環境の"/cygdrive"から始まるパスには対応していません。haskell-hlintから呼び出されるhlintも当然この問題の影響を受けておりemacs関連の設定が適切にされていたとしても、以下のようなエラーが表示されてしまいます。



ミニバッファに表示されるエラー詳細：
Suspicious state from syntax checker haskell-hlint: Checker haskell-hlint returned non-zero exit code 1, but no errors from output: hlint.exe: Couldn't find file: /cygdrive/c/Users/Hiroyuki/tmp/flycheck_hello.hs



</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2015/12/23/190729</id><title type="text">Alloy で自動定理証明っぽいやつ</title><updated>2015-12-23T19:42:18+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2015/12/23/190729"/><summary type="html">このエントリは Theorem Prover Advent Calendar 2015 - Qiita の 23 日目です。 とは言ってみたものの、内容はいわゆる定理証明器の話ではありません。モデル検査器 Alloy を利用して古典命題論理のシークエント計算をモデル化し、証明図を自動生成させることを目標にします。 なお、以下で部分的に引用しているモデル定義の完全版は alloy_sequent.als · GitHub にアップロードしてあります。 モデル化してみる 命題論理式の実装 まず対象となる論理式を Alloy で記述します。 abstract sig Formula {} sig A…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2015/12/13/193508</id><title type="text">NGK2015B で AWS + Alloy について話してきました</title><updated>2015-12-13T19:35:08+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2015/12/13/193508"/><summary type="html">先日、毎年恒例のなごや LT 大会 NGK2015B / 名古屋合同懇親会 2015 忘年会 で発表してきました。 AWS は形式手法の夢を見るか？ - モデル検査器 Alloy によるインフラ設計 from y_taka_23 www.slideshare.net 当日の動画は [3] NGK2015B（名古屋合同懇親会 2015 忘年会） - YouTube から見ることができます。 TL;DR AWS でインフラ運用中 でも設定が大人の都合でカオスになりがちだったりして辛い よろしい、ならば形式手法だ サンプルコードを動かしてみよう！ まずはインストールしてみる 公式ページ Alloy …</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/12/10/200630</id><title type="text">正格フラグ、バンパターン、正格版関数・データ構造</title><updated>2015-12-10T20:06:30+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/12/10/200630"/><summary type="html">Haskellスペースリーク Advent Calendar 2015 9日目 Haskellerとて、時には厳しくならなければいけないこともある―― @fumieval, 2015 Haskellは遅延評価を基本としているため、場合によっては未評価の式が積もり非効率な状況に陥ることがある。これを防ぐため、部分的に正格評価にするための仕組みが用意されている。もちろんこれらは闇雲に使えばよいというものではない。使うべきポイントを把握し、これらを見逃さないようにしよう。 この記事では、それらの機能の正しい使い方、間違った使い方を紹介していこう。 カウンター・カウンターズ・サンクス 条件を満たす要素…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/11/haskellstack-stack-exec-ghcicouldnt.html</id><title type="text">[haskell][stack] stack exec ghciで”Couldn't match expected type"エラーが発生する問題の対処</title><updated>2015-11-08T15:09:21.187+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/11/haskellstack-stack-exec-ghcicouldnt.html"/><summary type="text">先日、haskellのパッケージ管理をcabalからstackに移行して「便利〜！」と感動していたところなのですが、stach exec ghciでソースをロードしようとすると"Couldn't match expected type: xxxxx"とエラーが発生する問題に遭遇しました。
ネットの情報を参考に解決することができたのでその手順をまとめておきます。


問題：
stack buildは成功するにもかかわらず、stack exec ghci xxx.hs（xxx.hsはbuild対象のファイル）がエラーになる。
stack exec ghci実行時のエラーログ：
% stack exec ghci FileToVec.hs
GHCi, version 7.10.2: http://www.haskell.org/ghc/  :? for help
[1 of 1] </summary></entry><entry><id>https://kurokawh.blogspot.com/2015/11/cygwin-cygwinpathusrbinusrlocalbin.html</id><title type="text">[cygwin] cygwinのシェル起動時にPATHの先頭に/usr/binと/usr/local/binが勝手に追加されないようにする</title><updated>2015-11-04T22:29:43.126+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/11/cygwin-cygwinpathusrbinusrlocalbin.html"/><summary type="text">cygwinのデフォルトの設定では、シェル起動時に以下の2つのディレクトリが自動的にPATHの先頭に追加されます。

/usr/local/bin
/usr/bin


cygwinでインストールされているコマンドと同名の別コマンドを優先して起動したい場合には、この設定が邪魔になります。
これを無効にするには以下の方法があります。お好みでどちらかを選択してください。

/etc/profileもしくは/etc/csh.loginの該当処理をコメントアウトする（bash / tcsh）

cygwinがPATHを上書きしているのは、/etc/profile（bashの場合）と/etc/csh.login（tcshの場合）です。これらのスクリプトを編集することで、/usr/binと/usr/local/binが勝手に追加されないようにできます。

ORIGINAL_PATHでPATHを上書き</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/10/27/234832</id><title type="text">動物、とくにヒトと性について</title><updated>2015-10-27T23:52:44+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/10/27/234832"/><summary type="html">我々脊椎動物は有性生殖をする。したがって、繁殖に寄与する性質が必然的に残り、そうでないものは消えてゆく。オスは精子、メスは卵を作り出すという非対称性があり、体つきや行動もそれに合わせるように決まるのは自然だ。一夫多妻制の種においては、オスはメスを取り合うためにより強靭で攻撃的な性質が要求される。日本では法律上一夫一妻制を取るが、その影響は強く残っているだろう。実際、オスとして生を受けた私も、コミュニティの中でそれを体感している。 生まれつきの体質か、育った環境のせいかは知らないが、幼いころは体が弱かった(3才のころ、両足飛びができなかったそうだ)。そのため、幼いころの私の趣味は読書、ままごとや…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/10/08/183215</id><title type="text">就職しました</title><updated>2015-10-08T18:32:15+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/10/08/183215"/><summary type="html">本日、Tsuru Capitalのポジションを得ました。 Tsuru Capitalはデリバティブの取引を行っている企業で、自動株取引の会社ではありません。取引に関わっている10人のメンバーのうち、創始者であるSimonを除く全員がHaskellerで、取引状況の分析や一部の取引の自動化など、あらゆるところにHaskellを使っているのが大きな特徴です。日本では数少ない、Haskellをメインに使っている企業の一つでもあります。 東京、シンガポール、バンクーバーにオフィスがあり、東京には私を含む5人の開発者と事務担当、Simonと愛犬テトがいます。 オフィスはオランダヒルズ森タワーRoPにあり…</summary></entry><entry><id>http://kakkun61.hatenablog.com/entry/2015/06/15/stack_%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%BF%E3%81%9F</id><title type="text">stack コマンドを使ってみた</title><updated>2015-10-06T02:27:04+09:00</updated><author><name>岡本和樹</name></author><link href="http://kakkun61.hatenablog.com/entry/2015/06/15/stack_%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%BF%E3%81%9F"/><summary type="html">6月9日に FP Complete から stack コマンドがリリースされました（公式ブログ）。とりあえずブログ1文目を訳すとこんな感じです。 stack は新しく、完璧で、クロスプラットフォームで動作する開発ツールで、新参も古参も対象にしていて、コンパイラーをインストールしてセットアップして、必要なパッケージをインストールして、ビルドして、プロジェクト内の1つ以上のパッケージのテストをするもしくはベンチマークを取るためのものです。 stack is a new, complete, cross-platform development tool aimed at both new and …</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/09/ssh-opensshssh-agent.html</id><title type="text">[ssh] OpenSSHのアップデートでssh-agentがパスワードを覚えてくれなくなった問題への対処</title><updated>2015-09-06T00:44:24.703+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/09/ssh-opensshssh-agent.html"/><summary type="text">ssh-agent/ssh-addを利用してsshを用いたサーバーへのログイン時のパスワード入力を省略している方、OpenSSHのアップデートにより、毎回パスワード入力を求められるようになった場合は以下の設定を疑ってみてください。


問題の症状：
OpenSSHパッケージを最新版にアップデートすると発生するようになった問題です。ssh-agentを起動してssh-addで鍵を正しく登録しているにも関わらず、sshコマンドを実行する度に"password:"というプロンプトが表示されてパスワードの入力を求められてしまいます。


環境：
問題に遭遇＆解決した私のcygwin環境では以下のバージョンで問題が発生することを確認しました。

OpenSSH_7.0p1, OpenSSL 1.0.2d 9 Jul 2015
OpenSSH_7.1p1, OpenSSL 1.0.2d 9 Jul </summary></entry><entry><id>https://kurokawh.blogspot.com/2015/09/cygwin-cygwinx-serverxwin.html</id><title type="text">[cygwin] cygwin版X server（XWin）にリモートクライアントから接続できない問題の対処方法</title><updated>2015-09-02T23:09:07.989+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/09/cygwin-cygwinx-serverxwin.html"/><summary type="text">cygwinを最新バージョンにアップデートしたところ、リモートのX clientからwindows上のcygwin版X serverに接続できなくなってしまいました。
対処方法は簡単でXWin起動時に"-listen tcp"オプションを付けてあげればよいだけです。cygwinバージョンアップ前にはオプション指定なしで接続できていたため、デフォルトの設定が変わったのだと思われます。


cygwin環境：
uname -aで表示されるcygwinバージョン情報です。

% uname -a
CYGWIN_NT-6.1 xxx 2.2.1(0.289/5/3) 2015-08-20 11:42 x86_64 Cygwin



問題発生時の症状：
クライアント側で起動したxtermをサーバー側で表示しようとすると、以下のようなエラーになっていました。
% xterm
xterm Xt </summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/08/30/210019</id><title type="text">カリー化</title><updated>2015-08-30T21:00:19+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/08/30/210019"/><summary type="html">鍋にオリーブオイルを入れる。 にんにくを細切りにし、入れる。しょうがを少しすりおろす。いつもの流れである。 玉ねぎの半分をみじん切りにし、鍋に入れ、しばらく炒める。 キャベツ、にんじん、ヒラタケ、残りの玉ねぎ、じゃがいも(皮ごと)を大き目に切り、蓋をしつつ少し間隔を置いて順に入れる。 しばらくしたあと、鶏肉を入れる。少量のクレイジーソルトとバターも入れた。 水は少しだけ加え、他は素材の水分に頼る。Vita Craftの性能に期待を寄せる。 ビタクラフトオフィシャルサイト｜全面多層鍋の無水調理で実証www.vitacraft.co.jp 市販のカレールウをある程度分割し、まぶすように入れる。6分…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/08/23/145932</id><title type="text">最近作った料理(簡単さ順)</title><updated>2015-08-23T14:59:32+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/08/23/145932"/><summary type="html">面倒なので写真はなし。 ミニマリスティック卵スープ 鍋で水を沸かす。 創味シャンタンを1人あたり小さじ半分ほど入れる。塩で味を補う。 溶き卵を乱暴に投入する。 賞味期限の近い具材を消費するためのチャーハン ごま油とサラダ油を強火で熱したフライパンに入れる。 溶き卵を乱暴に投入する。 数秒後にご飯を投入する。 ねぎと薄く切ったにんにくを入れる。 創味シャンタンを小さじ半分入れる。 適当な具材を入れる。賞味期限が切れそうだったソーセージとキムチを入れた。 醤油と黒胡椒で味を調える。 牛丼 ごま油とサラダ油をフライパンに入れる。 みじん切りにしたにんにく、少量のおろししょうがを加える。 ここで七味唐…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/08/cygwinemacs-cygwinemacsgtags.html</id><title type="text">[cygwin][emacs] cygwin版emacsでgtagsを使えるようにする方法</title><updated>2015-08-17T00:49:02.649+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/08/cygwinemacs-cygwinemacsgtags.html"/><summary type="text">これまでタグジャンプにはctagsを用いていたのですが、gtagsの「呼び出し元も一覧できる」という機能に惹かれてセットアップしてみました。いくつかはまりポイントがあったのでその対応方法も含め、手順を残しておきます。
cgwin提供のパッケージにはgtagsは含まれていなかったため、自前でビルドすることにしました。


目次：

gatgsの特徴
gtagsのインストール手順
emacsの設定
gtagsの使い方




gtagsの特徴：

良い点！

関数の呼び出し元を一覧表示しジャンプできる（gtags-find-rtag）
関数だけでなく、ローカル変数を含む任意のシンボルをタグジャンプできる（gtags-find-symbol）

正規表現で一覧絞り込み可能（gtags-find-pattern）
開いているファイルで絞り込み可能（gtags-parsefiile）

特定文字列</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2015/08/01/203751</id><title type="text">第十二回渋谷 Java で Featherweight Java の話をしてきました</title><updated>2015-08-01T20:37:51+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2015/08/01/203751"/><summary type="html">8 月 1 日に行われた第十二回渋谷 Java で Java の型システムについて LT をしてきました。以下が使用したスライドです。 Hello, Type Systems! - Introduction to Featherweight Java from y_taka_23 ちなみに Featherweight Java を導入した論文はここで読めます。今回の LT では時間の都合上細かい内容をほとんど述べていないので、もし興味があればぜひ元論文に目を通してみると面白いと思います。なお LT で扱ったのは第 2 章で述べられている（ジェネリクスを持たない）FJ の部分です。 スライドの補…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2015/07/26/174136</id><title type="text">稼働中の Docker コンテナ内にファイルを転送するツール Docker Inject を作ってみました</title><updated>2015-07-26T17:41:36+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2015/07/26/174136"/><summary type="html">ホスト側から run 中の Docker コンテナ内へ、ディレクトリごとコピーします。 y-taka-23/docker-injectgithub.com 背景 Docker を運用している上で、動いているコンテナの中にファイルを送り込みたくなったことはないでしょうか。ないですか？ 残念ながらあるところにはあるのです。とりあえず今回はあるということにして進みます。 docker cp コマンドを使用すれば「コンテナからホストへ」のファイル転送は可能ですが、逆に「ホストからコンテナへ」の転送手段は公式では提供されていないはずです。docker run 時に -v オプションを付けておいて、マウン…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/07/14/223329</id><title type="text">lensパッケージのオプティクス(弱い順)</title><updated>2015-07-14T22:33:29+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/07/14/223329"/><summary type="html">lensではオプティクスと呼ばれる様々な構造が定義されている。これらの関係を把握していれば、ドキュメントから欲しいものを見つけるのが楽になる。この記事では弱い順にオプティックの数々を紹介していく。 Fold type Fold s a = forall f. (Applicative f, Contravariant f) =&gt; (a -&gt; f a) -&gt; s -&gt; f s Contravariantがついているのでわかりにくいが、これは本質的に以下の型と等価だ。mappendは*&gt;、memptyはfmap absurd $ contramap absurd $ pure ()に相当する。 t…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/06/subversion.html</id><title type="text">[subversion] 特定ディレクトリ以下をサーバーとの同期対象から除外する方法</title><updated>2015-06-26T13:55:24.651+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/06/subversion.html"/><summary type="text">subversionでチェックアウトした作業コピー内の特定ディレクトリ以下をサーバーとの同期対象から除外したい、ということを考えたことはないでしょうか。
例えば、リポジトリの特定ディレクトリ以下に自分にとって不要なファイルやアーカイブが多数コミットされていると、以下のような無駄が生じます。これらの無駄をなくしたい、というのが主なユースケースです。

不要なファイル・アーカイブによってディスクスペースが占有される
サーバー上に更新が発生した際にupdateに余計な時間がかかってしまう



単純に特定ディレクトリ以下の作業ファイルを削除してしまうと、コミット時に差分として検知されてしまう、また、次回以降のupdateコマンドで再ダウンロードされてしまう、という非常に残念な挙動になります。

このようなケースでは以下の方法を使えば、差分が検知されない状態で所定ディレクトリ以下のファイルを削除</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/06/22/162833</id><title type="text">Haskellの型クラスを活用する</title><updated>2015-06-22T16:30:14+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/06/22/162833"/><summary type="html">Haskellの型クラスは、うまく使えば高いパフォーマンスと抽象度を両立できる、優れた仕組みである。その使い方のコツは、決して理解の難しいものではない。 小さな性質、大きな恩恵 プログラマは大きなものを小さく見せがちだ。オブジェクト指向プログラミングに慣れている人がやりがちなアンチパターンとして、欲しい機能と、それを分割する基準が現実に寄りすぎていて、一つ一つが巨大というものがある。 普通のプログラミングではありえない例かもしれないが、たとえば家を作りたいことを考える。「ベッド」「箪笥」「台所」「冷蔵庫」「トイレ」「風呂」のように設備ごとに分けた抽象化をしたいと考えるだろう。確かにこれは理に適…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2015/06/21/200416</id><title type="text">Dockerfile をパラメータ化するツール VoicePipe を作ってみました</title><updated>2015-06-21T20:04:16+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2015/06/21/200416"/><summary type="html">ひとつの Dockerfile から複数の Docker イメージをビルドすることができます。 y-taka-23/voicepipegithub.com 背景 インフラ環境まわりを Docker 化している場合、しばしば複数の Docker イメージを同時並行的に管理する必要が生じます。例えばミドルウェアのバージョンの組み合わせをいろいろ試したいとか、開発環境と本番環境とで設定を変えたいとか。 一方、一般的にイメージとしてビルドされる情報はすべて Dockerfile に記述されており、docker build コマンドの際にはパラメータを渡すことができないため、いきおい、一部分だけ異なる …</summary></entry><entry><id>http://lotz84.github.io/posts/published_haskell_by_example.html</id><title type="text">Haskell by Exampleを公開しました</title><updated>2015-05-06T00:00:00Z</updated><author><name>lotz</name></author><link href="http://lotz84.github.io/posts/published_haskell_by_example.html"/><summary type="html"></summary></entry><entry><id>http://lotz84.github.io/posts/build-chat-server-on-haskell.html</id><title type="text">Haskellでチャットサーバーを建ててみた</title><updated>2015-04-27T00:00:00Z</updated><author><name>lotz</name></author><link href="http://lotz84.github.io/posts/build-chat-server-on-haskell.html"/><summary type="html"></summary></entry><entry><id>http://lotz84.github.io/posts/unity-hands-on-session-at-camphor.html</id><title type="text">Unityハンズオン勉強会に参加しました@CAMPHOR-</title><updated>2015-04-25T00:00:00Z</updated><author><name>lotz</name></author><link href="http://lotz84.github.io/posts/unity-hands-on-session-at-camphor.html"/><summary type="html"></summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/04/17/125213</id><title type="text">最近やったこと</title><updated>2015-04-20T18:52:24+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/04/17/125213"/><summary type="html">最近やったことのまとめ。 CPSのモナド変換子 モナド変換子の速さを測ってみる - モナドとわたしとコモナドfumieval.hatenablog.com で作ったmtl-cの塵を払い、Hackageにリリースした。 StateTやWriterTは中でタプルを作ったり壊したりしているが、CPS変換するとそれがなくなり、しかも(&gt;&gt;=)も最適化されるためそれなりのパフォーマンスの向上が期待できる。モナドガチユーザにおすすめだ。 補足 GHC 7.10.1現在、StateTに関しては最適化がうまく効くらしく、Lazy、Strict、CPS版のパフォーマンスはほぼ同じだった。一方、CPS版Write…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/04/06/173848</id><title type="text">Haskellでいかに多態を表すか</title><updated>2015-04-06T17:46:12+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/04/06/173848"/><summary type="html">オブジェクト指向を行使する心 ではオブジェクト指向の必要性と仕組みについて議論した。 インスタンスは言語によって様々な実装方法があるが、大きく分けて「クラス(処理)のインデックス」か「処理そのもの」のどちらかがインスタンスの内部に隠れている。 と述べたが、Haskellの場合、クラスのインデックスに基づいた表現では、インターフェイスは型クラス、クラスはインスタンス、インスタンスは存在量化された型の値に対応する。…といってもややこしいことこの上ないので、実装例を考えてみよう。 まず、問題となっている愚直な実装は、Haskellではこんな感じだ。 data World = World { … } …</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/04/06/141523</id><title type="text">オブジェクト指向を行使する心</title><updated>2015-04-06T14:16:10+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/04/06/141523"/><summary type="html">今日、とあるツイートでプログラミングにおけるよくある問題が顕現していた。 プログラミングしてそうなサークル探したら、ゲーム公開してて、ソースコード公開されてたから見た。 pic.twitter.com/7W09sb9DFa— タコス(祭り) (@tacosufestival) 2015, 4月 4 奇妙な行コメントには目を瞑るとして、このコードは要約すれば以下のような処理を実現していることが窺える。 ゲームプログラミングでは、現在のシーンによって処理を切り替える必要がある。メニュー画面ならメニューの処理を、戦闘画面なら戦闘を、マップならマップの表示をそれぞれ行う。 現在のシーンの種類は変数によ…</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/04/windowshaskell-widnwoshaskell-platform.html</id><title type="text">[windows][haskell] Widnwos環境でHaskell Platformを完全削除する方法</title><updated>2015-04-05T01:53:40.022+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/04/windowshaskell-widnwoshaskell-platform.html"/><summary type="text">Windows上でHaskell Platformを完全削除する方法です。
LinuxやMac環境についてはネット上に多数情報がありますが、Windows環境についてはそれが見当たらなかったため、本エントリにまとめておきます。確認した環境はWindows 8.1＋Haslell Platform 2014.2.0.0です。


削除手順：
Windows環境では以下の手順でHaskell Platformを完全に削除できます。

Haskell Platformのアンインストール

[コントロールパネル] - [プログラム] - [プログラムと機能]を開く
"Haslell Platform 2014.2.0.0"を選択して[アンインストール]を実行

ユーザー領域に作成されたパッケージ関連ファイルの削除

手動（エクスプローラ、rmコマンドなど）で次の２つのディレクトリ以下を完全に削除</summary></entry><entry><id>https://kurokawh.blogspot.com/2015/03/cygwin-cygwingit.html</id><title type="text">[cygwin] cygwin版のgitコマンドでサーバーとの通信に失敗する問題の対処</title><updated>2015-03-27T00:35:59.717+09:00</updated><author><name>Hiroyuki Kurokawa (hrkr)</name></author><link href="https://kurokawh.blogspot.com/2015/03/cygwin-cygwingit.html"/><summary type="text">cygwin上でgitコマンドを使用しているのですが、ある環境でのみgit pull/pushで以下のようなエラーが発生する問題に遭遇しました。調子よく動作している別の環境との比較で原因が判明したので、同じ問題にハマってしまった人向けに情報を残しておきます。


問題の現象：
問題の環境ではgit pull/pushを実行すると、以下のようなエラーが出力されていました。
% git pull origin master
fatal: 'pull' appears to be a git command, but we were not
able to execute it. Maybe git-pull is broken?

% git push origin master
fatal: Full write to remote helper failed: Broken pipe

</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/03/20/155326</id><title type="text">モノイドと継続渡しの道具箱</title><updated>2015-03-21T06:54:08+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/03/20/155326"/><summary type="html">関数型言語Haskellにおいて、普通は計算の結果は関数の戻り値として扱うが、「結果を受け取る関数」 に渡すという継続渡しというスタイルもある。これは単なる冗長なやり方ではなく、様々な興味深い性質を持つ。 基本形は、aという値を渡すところを ∀r. (a -&gt; r) -&gt; r のような表現にする。たとえば、与えられた数の42倍を渡したいとき、そのまま\x -&gt; x * 42ではなく、\x f -&gt; f (x * 42)と書く。もちろんこれだけではありがたみが分からない。 さて、与えられた文字列の中のうち、大文字のアルファベットを取り出し、それがアルファベットの何番目か計算するプログラムを作りた…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/03/08/214505</id><title type="text">Haskellにおけるたった一つのデザインパターン</title><updated>2015-03-08T21:45:05+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/03/08/214505"/><summary type="html">デザインパターンを作らないこと。型とクラスがあんたの武器だ。</summary></entry><entry><id>http://lotz84.github.io/posts/the-way-of-separate-compilation-in-swift.html</id><title type="text">Swift で分割コンパイルする方法</title><updated>2015-02-07T00:00:00Z</updated><author><name>lotz</name></author><link href="http://lotz84.github.io/posts/the-way-of-separate-compilation-in-swift.html"/><summary type="html"></summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2015/02/05/174342</id><title type="text">出、出～～ｗｗｗｗｗ銀行員待行列解説奴～ｗｗｗｗｗｗｗ</title><updated>2015-02-06T14:16:34+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2015/02/05/174342"/><summary type="html">銀行員待行列(Banker's deque)、二つのリストで構成奴～～ｗｗｗｗｗ 入奴と出奴～ｗｗｗｗｗｗｗｗｗ ↓入奴 三(^o^)ノ [(^o^)ノ, (^o^)ノ, (^o^)ノ] ヽ(^o^)三 [ヽ(^o^), ヽ(^o^), ヽ(^o^)] ↑出奴 追加は入奴にcons、取り出しは出奴にuncons奴～ｗｗｗリストなので基本定数時間奴～ｗｗｗｗｗｗ リスト枯渇防止の為、リストの長さに以下の条件課奴～～～ｗｗｗｗｗｗ length (入奴) &lt;= length (出奴) * 3 + 1 length (出奴) &lt;= length (入奴) * 3 + 1 条件充足不能場合、|leng…</summary></entry><entry><id>http://fumieval.hatenablog.com/entry/2014/12/31/151953</id><title type="text">副作用の話</title><updated>2014-12-31T15:21:23+09:00</updated><author><name>Fumiaki Kinoshita</name></author><link href="http://fumieval.hatenablog.com/entry/2014/12/31/151953"/><summary type="html">最近、副作用や関数型言語についてもめているのをよく目にする。副作用と関数型言語に関する私の見解をここに示す。 処理系はソースコードを解釈し、コンピュータの入出力、つまり副作用に変換する。ほとんどのプログラミング言語は、副作用を表現するプリミティブとその組み合わせによってプログラムを記述する。副作用は実行時に生まれるものだから、「Cの関数は副作用がある」「Haskellのコードに副作用はない」といった議論は、残念ながら意味をなしていない。実行していないのに副作用が出てきたら、超自然的な力を信じざるを得ない。 副作用の扱いについてよく議論の的になる言語としてHaskellがある。Haskellが多…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2014/12/15/220409</id><title type="text">NGK2014B で SPIN について話してきました</title><updated>2014-12-15T22:04:09+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2014/12/15/220409"/><summary type="html">名古屋工業大学で行われた LT 大会 NGK2014B で発表しました。内容はタイトルそのままで、モデル検査ツール SPIN とその記述言語である Promela の特徴を概観する、というものです。 猫でもわかる！ モデル検査器 SPIN 入門 from y_taka_23 当日の動画は Youtube から見ることができます。ちなみに、発表順は乱数で決められているはずなのですが、なぜか去年の NGK と全く同じ 3 番目でした。 リソース共有問題の Promela モデル LT の冒頭に登場するリソース共有時のデッドロックについて、Promela で記述したモデルが Gist においてありま…</summary></entry><entry><id>http://lotz84.github.io/posts/use-selenium-by-haskell.html</id><title type="text">HaskellでSeleniumを使ってみる＠勉強会</title><updated>2014-12-14T00:00:00Z</updated><author><name>lotz</name></author><link href="http://lotz84.github.io/posts/use-selenium-by-haskell.html"/><summary type="html"></summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2013/02/03/133158</id><title type="text">Coq で Quine</title><updated>2013-03-11T23:24:40+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2013/02/03/133158"/><summary type="html">Coq で自己出力プログラム、いわゆる Quine を作成してみました。全体の流れとしては情報処理学会の連載「自分自身を出力するプログラム」の Haskell 版を参考にしてあります。今回のコードは短いので記事の最後に全体を載せてありますが、一応いつものごとく Gist 上 https://gist.github.com/4700318 にも同じものを置いておきました。 Coq の特性あれこれ Quine なるものを初めて聞いた人は wikipedia:クワイン_(プログラミング) あたりを見てみましょう。「自分自身のソースコードを標準出力する。ただし空ファイルでなく、入力は受け付けない」とい…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2013/01/20/205723</id><title type="text">Coq でクイックソート (2)</title><updated>2013-01-30T23:22:41+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2013/01/20/205723"/><summary type="html">Coq でクイックソートの検証、二回目です。コードは前回のものに追記する形で https://gist.github.com/4526374 に置いてあります。 アルゴリズムの定義 仕様の検証その 1 (この記事) 仕様の検証その 2 今回の目標 さて、前回の最後にも触れた通り、前回定義したクイックソート qsort について、 出力が昇順になっていること を保証することが第一の目標です。ここでは、標準ライブラリ Sorting モジュール内にある述語 Sorted を使うことにしました。Sorting.Sorted の中には、「リストが (ある関係 R に対して) 昇順である」ことを意味する…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2013/01/13/234925</id><title type="text">Coq でクイックソート (1)</title><updated>2013-01-30T23:20:51+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2013/01/13/234925"/><summary type="html">以前の記事「Coq で filter 関数」の最後にちょっと触れた通り、Coq でクイックソートを扱ってみます。ひとつの記事にすると長くなりそうなので、全 3 回に分割してみました。 アルゴリズムの定義 (この記事) 仕様の検証その 1 仕様の検証その 2 ちなみに、今回の分のコードは https://gist.github.com/4526374 に置いてあります。使い古されたネタではありますが、もしよろしければしばしお付き合いを。 おなじみのアルゴリズム 今更ですが、アルゴリズムの復習から始めましょう。深く考えずにクイックソートを書き下すと次のようになります。 Fixpoint qsort…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2013/01/27/201809</id><title type="text">Coq でクイックソート (3)</title><updated>2013-01-27T20:18:09+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2013/01/27/201809"/><summary type="html">Coq でクイックソートの検証、三回目です。今回は最後に残った部分をちょろっとだけ埋めましょう。コードは前回、前々回に追記する形で、https://gist.github.com/4526374 に置いてありますのでよかったらご参照を。 アルゴリズムの定義 仕様の検証その 1 仕様の検証その 2 (この記事) 今回の目標 今回は、最後に残った qsort の二つ目の仕様 出力が入力の置換 (並び替え) になっていること を証明します。モジュール Sorting.Permutation を使いましょう。前回の Sorted に比べ、Permutation はリスト操作とそれなりに相性がよく、証明…</summary></entry><entry><id>http://ccvanishing.hateblo.jp/entry/2013/01/06/212707</id><title type="text">Coq で位相空間</title><updated>2013-01-06T21:37:09+09:00</updated><author><name>y_taka_23</name></author><link href="http://ccvanishing.hateblo.jp/entry/2013/01/06/212707"/><summary type="html">前々回の記事「Coq でモジュラー束」で「群 G の部分群を述語 G -&gt; Prop で表す」という方針を採用したところ、割と上手くいくということがわかりました。今回は他の題材として、「連結集合の連続写像による像は連結」であることを、同じ方針により証明してみます。大学の学部で習う定番問題ですね。証明付きの完全なコードは https://gist.github.com/4466805 です。 とりあえず概念を準備しよう 位相空間 「X の部分集合」の型をいちいち X -&gt; Prop の形で書くと冗長になるため、シノニムを付けておきます。 Definition Subset (X : Set) :…</summary></entry></feed>